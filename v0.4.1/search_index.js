var documenterSearchIndex = {"docs":
[{"location":"advanced_operations.html#Advanced-operations-on-transfer-function-matrices-1","page":"Advanced operations on transfer function matrices","title":"Advanced operations on transfer function matrices","text":"","category":"section"},{"location":"advanced_operations.html#","page":"Advanced operations on transfer function matrices","title":"Advanced operations on transfer function matrices","text":"gsdec  Additive spectral decompositions.\ngrnull   Right nullspace basis of a transfer function matrix.\nglnull   Left nullspace basis of a transfer function matrix.\ngrsol   Solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglsol   Solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).\ngrmcover1  Right minimum dynamic cover of Type 1 based order reduction.\nglmcover1   Left minimum dynamic cover of Type 1 based order reduction.\ngrmcover2  Right minimum dynamic cover of Type 2 based order reduction.\nglmcover2  Left minimum dynamic cover of Type 2 based order reduction.","category":"page"},{"location":"advanced_operations.html#","page":"Advanced operations on transfer function matrices","title":"Advanced operations on transfer function matrices","text":"gsdec\ngrnull\nglnull\ngrsol\nglsol\ngrmcover1\nglmcover1\ngrmcover2\nglmcover2","category":"page"},{"location":"advanced_operations.html#DescriptorSystems.gsdec","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.gsdec","text":"gsdec(sys; job = \"finite\", smarg, fast = true,  atol = 0,  atol1 = atol, atol2 = atol, rtol = nϵ) -> (sys1, sys2)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the additive spectral decomposition G(λ) = G1(λ) + G2(λ) such that G1(λ),  the transfer function matrix of the descriptor system sys1 = (A1-λE1,B1,C1,D1),  has only poles in a certain domain of interest Cg of the complex plane and G2(λ),  the transfer function matrix of the descriptor system sys2 = (A2-λE2,B2,C2,0), has only poles outside of Cg. \n\nThe keyword argument smarg, if provided, specifies the stability margin for the stable eigenvalues of A-λE, such that, in the continuous-time case,  the stable eigenvalues have real parts less than or equal to smarg, and in the discrete-time case, the stable eigenvalues have moduli less than or equal to smarg. If smarg = missing, the used default values  are: smarg = -sqrt(ϵ), for a continuous-time system, and smarg = 1-sqrt(ϵ),  for a discrete-time system), where ϵ is the machine precision of the working accuracy. \n\nThe keyword argument job, in conjunction with smarg, defines the domain of  interest Cg, as follows:\n\nfor job = \"finite\", Cg is the whole complex plane without the point at infinity, and     sys1 has only finite poles and sys2 has only infinite poles (default);     the resulting A2 is nonsingular and upper triangular, while the    resulting E2 is nilpotent and upper triangular;   \n\nfor job = \"infinite\", Cg is the point at infinity, and     sys1 has only infinite poles and sys2 has only finite poles and     is the strictly proper part of sys;     the resulting A1 is nonsingular and upper triangular, while the    resulting E1 is nilpotent and upper triangular;   \n\nfor job = \"stable\", Cg is the stability domain of eigenvalues defined by smarg, and       sys1 has only stable poles and sys2 has only unstable and infinite poles;         the resulting pairs (A1,E1) and (A2,E2) are in generalized Schur form with     E1 upper triangular and nonsingular and E2 upper triangular;   \n\nfor job = \"unstable\", Cg is the complement of the stability domain of the      eigenvalues defined by smarg, and       sys1 has only unstable and infinite poles and sys2 has only stable poles;         the resulting pairs (A1,E1) and (A2,E2) are in generalized Schur form with     E1 upper triangular and E2 upper triangular  and nonsingular.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grnull","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grnull","text":"grnull(sys; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (sysrnull, info)\n\nDetermine for the descriptor systems sys = (A-λE,B,C,D) with the p x m transfer function matrix G(λ),  the descriptor system sysrnull = (Ar-λEr,Br,Cr,Dr) with the transfer function matrix Nr(λ)  such that Nr(λ) is a minimal rational right nullspace basis of G(λ) and satisfies G(λ)*Nr(λ) = 0.     \n\nFor the call with\n\ngrnull(sys, p2; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (sysrnull, info)\n\nsys contains the compound system sys = [sys1; sys2], with G(λ), the transfer function matrix of sys1, and  G2(λ), the transfer function matrix of sys2, and has the descriptor realization sys = (A-λE,B,[C;C2],[D;D2]),  where sys2 has p2 outputs. The resulting sysrnull contains the compound system  [sysrnull1; sys2*sysrnull1] = (Ar-λEr,Br,[Cr;Cr2],[Dr;Dr2]), where sysrnull1 = (Ar-λEr,Br,Cr,Dr) has the transfer function matrix Nr(λ), which is a rational right nullspace basis of G(λ) satisfying G(λ)*Nr(λ) = 0 and sys2*sysrnull1 = (Ar-λEr,Br,Cr2,Dr2) has the transfer function matrix G2(λ)*Nr(λ). \n\nThe returned named tuple info has the components info.nrank, info.stdim, info.degs, info.fnorm and info.tcond.\n\nIf polynomial = false, the resulting sysrnull has a proper transfer function matrix,  while for polynomial = true the resulting sysrnull has a polynomial transfer function matrix.  The resulting basis Nr(λ) contains m-r basis vectors, where r = rank G(λ). The rank r is returned in info.nrank. If simple = true, the resulting basis is simple and satisfies the condition that the sum of the  number of poles of the m-r basis vectors is equal to the number of poles of Nr(λ) (i.e., its McMillan degree) . \n\nFor a non-simple proper basis, the realization (Ar-λEr,Br,Cr,Dr) is controllable and the pencil [Br Ar-λEr] is in a controllable staircase form. The column dimensions of the full row rank diagonal blocks are returned in info.stdim and the corresponding right Kronecker indices are returned in info.degs.   For a simple basis, the regular pencil Ar-λEr is block diagonal, with the i-th block of size info.deg[i]  (the i-th right Kronecker index) for a proper basis and  info.deg[i]+1 for a polynomial basis.  The dimensions of the diagonal blocks are returned in this case in info.stdim, while the increasing numbers of poles of  the basis vectors are returned in info.degs. For the i-th basis vector vi(λ) (i.e., the i-th column of Nr(λ))  a minimal realization can be explicitly constructed as (Ari-λEri,Bri,Cr,Dr[:,i]), where Ari, Eri and Bri are the i-th diagonal blocks of Ar, Er, and Br, respectively, and Dr[:,i] is the i-th column of Dr.  The corresponding realization of G2(λ)*vi(λ) can be constructed as (Ari-λEri,Bri,Cr2,Dr2[:,i]), where Dr2[:,i] is the i-th column of Dr2.\n\nFor a proper basis, the poles of Nr(λ) can be freely assigned, by assigning the  eigenvalues of the pencil Ar-λEr. The vector poles, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree sdeg of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If inner = true, the resulting basis Nr(λ) is inner, i.e., Nr(λ)'*Nr(λ) = I, where Nr(s)' = transpose(Nr(-s)) for a  continuous-time system with λ = s and Nr(z)' = transpose(Nr(1/z)) for a discrete-time system with λ = z.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If sys2 has poles on the boundary of the appropriate stability domain Cs, which are not poles of sys1 too,  then there exists no inner Nr(λ) such that G2(λ)*Nr(λ) is stable. An offset can be specified via the keyword parameter offset = β to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations.  \n\nNote: The resulting realization of sysrnull is minimal provided the realization of sys is minimal.  However, sysrnull1 is a minimal basis only if the realization (A-lambda E,B,C,D) of sys1 is  minimal. In this case, info.degs are the degrees of the vectors of a minimal polynomial basis or,  if simple = true, of the resulting minimal simple proper basis. \n\nMethod: The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of Nr(λ) is explicitly  constructed using formulas given in [4]. \n\nReferences:\n\n[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.\n\n[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glnull","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glnull","text":"glnull(sys; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (syslnull, info)\n\nDetermine for the descriptor systems sys = (A-λE,B,C,D) with the p x m transfer function matrix G(λ),  the descriptor system syslnull = (Al-λEl,Bl,Cl,Dl) with the transfer function matrix Nl(λ)  such that Nl(λ) is a minimal rational left nullspace basis of G(λ) and satisfies Nl(λ)*G(λ) = 0.     \n\nFor the call with\n\nglnull(sys, m2; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (syslnull, info)\n\nsys contains the compound system sys = [sys1 sys2], with G(λ), the transfer function matrix of sys1, and  G2(λ), the transfer function matrix of sys2, and has the descriptor realization sys = (A-λE,[B B2],C,[D D2]),  where sys2 has m2 inputs. The resulting syslnull contains the compound system  [syslnull1 syslnull1*sys2] = (Al-λEl,[Bl Bl2],Cr,[Dl Dl2]), where syslnull1 = (Al-λEl,Bl,Cl,Dl) has the transfer function matrix Nl(λ), which is a rational left nullspace basis of G(λ) satisfying Nl(λ)*G(λ) = 0 and syslnull1*sys2 = (Al-λEl,Bl2,Cl,Dl2) has the transfer function matrix Nl(λ)*G2(λ). \n\nThe returned named tuple info has the components info.nrank, info.stdim, info.degs, info.fnorm and info.tcond.\n\nIf polynomial = false, the resulting syslnull has a proper transfer function matrix,  while for polynomial = true the resulting syslnull has a polynomial transfer function matrix.  The resulting basis Nl(λ) contains p-r basis vectors, where r = rank G(λ). The rank r is returned in info.nrank. If simple = true, the resulting basis is simple and satisfies the condition that the sum of the  number of poles of the p-r basis vectors is equal to the number of poles of Nl(λ) (i.e., its McMillan degree) . \n\nFor a non-simple proper basis, the realization (Al-λEl,Bl,Cl,Dl) is observable and the pencil [Al-λEl; Cl] is in an observable staircase form. The row dimensions of the full column rank diagonal blocks are returned in info.stdim and the corresponding left Kronecker indices are returned in info.degs.   For a simple basis, the regular pencil Al-λEl is block diagonal, with the i-th block of size info.stdim[i].  The increasing numbers of poles of the basis vectors are returned in info.degs.  For the i-th basis vector vi(λ) (i.e., the i-th row of Nl(λ))  a minimal realization can be explicitly constructed as (Ali-λEli,Bl,Cli,Dl[i,:]), where Ali, Eli and Cli are the i-th diagonal blocks of Al, El, and Cl, respectively, and Dl[i,:] is the i-th row of Dl.  The corresponding realization of vi(λ)*G2(λ) can be constructed as (Ali-λEli,Bl2,Cl2,Dl2[i,:]), where Dl2[i,:] is the i-th row of Dl2.\n\nFor a proper basis, the poles of Nl(λ) can be freely assigned, by assigning the eigenvalues of the pencil Al-λEl. The vector poles, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree sdeg of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If coinner = true, the resulting basis Nl(λ) is coinner, i.e., Nl(λ)*Nl(λ)' = I, where Nl(s)' = transpose(Nl(-s)) for a  continuous-time system with λ = s and Nl(z)' = transpose(Nl(1/z)) for a discrete-time system with λ = z.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If sys2 has poles on the boundary of the appropriate stability domain Cs, which are not poles of sys1 too,  then there exists no inner Nl(λ) such that Nl(λ)*G2(λ) is stable. An offset can be specified via the keyword parameter offset = β to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations.  \n\nNote: The resulting realization of syslnull is minimal provided the realization of sys is minimal.  However, syslnull1 is a minimal basis only if the realization (A-lambda E,B,C,D) of sys1 is  minimal. In this case, info.degs are the degrees of the vectors of a minimal polynomial basis or,  if simple = true, of the resulting minimal simple proper basis. \n\nMethod: The computation method for the computation of a right nullspace basis is applied to the dual of descriptor system sys. The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of Nl(λ) is explicitly  constructed using formulas given in [4]. \n\nReferences:\n\n[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.\n\n[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grsol","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grsol","text":"grsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and  sysf = (Af-λEf,Bf,Cf,Df) with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the solution of the linear rational equation\n\nG(λ)X(λ) = F(λ) .      (1)\n\nIf solgen = true, the descriptor system sysgen is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form GEN(λ) = [ X0(λ) XN(λ) ],  such that any X(λ) can be generated as\n\nX(λ) = X0(λ) + XN(λ)*Z(λ) ,\n\nwhere X0(λ) is a particular solution satisfying G(λ)X0(λ) = F(λ),  XN(λ) is a proper rational right nullspace basis of G(λ) satisfying G(λ)XN(λ) = 0, and  Z(λ) is an arbitrary rational matrix with suitable dimensions. If solgen = false, sysgen is set to nothing. \n\nThe call with\n\ngrsol(sysgf, mf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nuses the compound descriptor system sysgf = (A-λE,[Bg Bf],C,[Dg Df]),  where Bf has mf columns, to define   the descriptor systems sysg = (A-λE,Bg,C,Dg) and sysf = (A-λE,Bf,C,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Cg = Cf = C). \n\nThe generator sysgen has a descriptor system realization sysgen = (A0-λE0,[B0 BN],C0,[D0 DN]), which is usually not minimal  (uncontrollable and/or non-dynamic modes present), with  \n\n               ( Ar-λEr    *       *    )  \n   A0-λE0    = (   0     Af-λEf    *    ) , \n               (   0       0     Ai-λEi ) \n\n               ( B1 | Br )\n   [B0 | BN] = ( B2 | 0  ),  Cg  =   ( Cr   *    *  ) ,\n               ( B3 | 0  )\n\nwith Er, Ef and Ai invertible and upper triangular, Ei nillpotent and upper triangular, and DN full row rank. The dimensions of the diagonal blocks of A0-λE0 are  returned in the named tuple info as the components info.nr, info.nf, and info.ninf, respectively. \n\nA minimal order descriptor system realization of the proper basis XN(λ) is (Ar-λEr,Br,Cr,DN),  where Br and DN have mr columns (returned in info.mr), representing the dimension of the  right nullspace basis. The normal rank nrank of  G(λ) is returned in info.nrank. \n\nIf mindeg = false, the solution sysx is determined in the form sysx = (A0+BN*F-λE0,B0,C0+DN*F,D0), where the matrix F = 0, unless a nonzero stabilizing gain is used such that Ar+Br*F-λEr has stable eigenvalues.  The vector poles specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree sdeg of eigenvalues.  The dimension nr of Ar is the number of freely assignable poles of the solution X(λ) and is returned in info.nr.  The eigenvalues of Af-λEf contain the finite zeros of G(λ), while the zeros  of Ai-λEi contain the infinite zeros of G(λ).    The norm of the employed gain F is returned in info.fnorm. If G(λ) has infinite zeros, then the solution X(λ) may have infinite poles. The integer vector info.rdeg contains the relative column degrees of  X(λ) (i.e., the numbers of integrators/delays needed to make each column of X(λ) proper).  \n\nIf mindeg = true, a minimum degree solution is determined as X(λ) = X0(λ) + XN(λ)*Z(λ), where Z(λ) is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback and feedforward gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations. \n\nIf minreal = true, the computed realization sysx is minimal.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of Ag, Bg, Cg, Dg, Af, Bf, Cf, Df,  the absolute tolerance for the nonzero elements of Eg and Ef,   and the relative tolerance for the nonzero elements of     Ag, Bg, Cg, Dg, Af, Bf, Cf, Df, Eg and Ef.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sysg and sysf. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The method of [1] to solve rational systems is used.\n\nReferences:\n\n[1] A. Varga, \"Computation of least order solutions of linear rational equations\",  Proc. MTNS'04, Leuven, Belgium, 2004.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glsol","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glsol","text":"glsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and  sysf = (Af-λEf,Bf,Cf,Df) with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the solution of the linear rational equation\n\nX(λ)G(λ) = F(λ) .      (1)\n\nIf solgen = true, the descriptor system sysgen is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form GEN(λ) = [ X0(λ); XN(λ) ],  such that any X(λ) can be generated as\n\nX(λ) = X0(λ) + Z(λ)*XN(λ) ,\n\nwhere X0(λ) is a particular solution satisfying X0(λ)G(λ) = F(λ),  XN(λ) is a proper rational left nullspace basis of G(λ) satisfying XN(λ)G(λ) = 0, and  Z(λ) is an arbitrary rational matrix with suitable dimensions. If solgen = false, sysgen is set to nothing. \n\nThe call with\n\ngrsol(sysgf, pf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nuses the compound descriptor system sysgf = (A-λE,B,[Cg; Cf],[Dg; Df]),  where Cf has pf rows, to define   the descriptor systems sysg = (A-λE,B,Cg,Dg) and sysf = (A-λE,B,Cf,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Bg = Bf = B). \n\nThe generator sysgen has a descriptor system realization sysgen = (A0-λE0,B0, [C0; CN],[D0; DN]), which is usually not minimal  (unobservable and/or non-dynamic modes present), with  \n\n             ( Ai-λEi    *       *    )  \n   A0-λE0  = (   0     Af-λEf    *    ) , \n             (   0       0     Al-λEl ) \n\n             ( *  )\n       B0  = ( *  ),   ( C0 )  = ( C1 C2 C3 ) \n             ( Bl )    ( CN )    ( 0  0  Cl )\n\nwith El, Ef and Ai invertible and upper triangular, Ei nillpotent and upper triangular, and DN full column rank. The dimensions of the diagonal blocks of A0-λE0 are  returned in the named tuple info as the components info.nf, info.ninf and info.nl, respectively. \n\nA minimal order descriptor system realization of the proper basis XN(λ) is (Al-λEl,Bl,Cl,DN),  where Cl and DN have pr columns (returned in info.pr), representing the dimension of the  left nullspace basis. The normal rank nrank of  G(λ) is returned in info.nrank. \n\nIf mindeg = false, the solution sysx is determined in the form sysx = (A0+F*CN-λE0,B0+F*DN,C0,D0), where the matrix F = 0, unless a nonzero stabilizing gain is used such that Al+F*Bl-λEl has stable eigenvalues.  The vector poles specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree sdeg of eigenvalues.  The dimension nl of Al is the number of freely assignable poles of the solution X(λ) and is returned in info.nl.  The eigenvalues of Af-λEf contain the finite zeros of G(λ), while the zeros  of Ai-λEi contain the infinite zeros of G(λ).    The norm of the employed gain F is returned in info.fnorm. If G(λ) has infinite zeros, then the solution X(λ) may have infinite poles. The integer vector info.rdeg contains the relative row degrees of  X(λ) (i.e., the numbers of integrators/delays needed to make each row of X(λ) proper).  \n\nIf mindeg = true, a minimum degree solution is determined as X(λ) = X0(λ) + Z(λ)XN(λ), where Z(λ) is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback and feedforward gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations. \n\nIf minreal = true, the computed realization sysx is minimal.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of Ag, Bg, Cg, Dg, Af, Bf, Cf, Df,  the absolute tolerance for the nonzero elements of Eg and Ef,   and the relative tolerance for the nonzero elements of     Ag, Bg, Cg, Dg, Af, Bf, Cf, Df, Eg and Ef.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sysg and sysf. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The dual of method of [1] to solve rational systems is used.\n\nReferences:\n\n[1] A. Varga, \"Computation of least order solutions of linear rational equations\",  Proc. MTNS'04, Leuven, Belgium, 2004.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grmcover1","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grmcover1","text":"grmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a right minimum dynamic cover of Type 1 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + X2(λ)*Y(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\ngrmcover1(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,[B1 B2],C,[D1 D2]),  where B1 and D1 have m1 columns, to define   the proper descriptor systems sys1 = (A-λE,B1,C,D1) and sys2 = (A-λE,B2,C,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and C1 = C2 = C).   \n\nThe resulting descriptor systems sysx and sysy have controllable realizations of the form sysx = (Ar-λEr,Br,Cr1,D1) and sysy = (Ar-λEr,Br,Cr2,0),  where the pencil [Br Ar-λEr] is in a (controllability) staircase form,   with νr[i] x νr[i-1] full row rank diagonal blocks, for i = 1, ..., nr,  with νr[0] := m1. \n\nThe resulting named triple ìnfo contains (stdim, tcond, fnorm),  where ìnfo.stdim = νr is a vector which contains the row dimensions of the blocks of the staircase form [Br Ar-λEr], ìnfo.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and ìnfo.fnorm is  the Frobenius-norm of the (internally) employed state-feedback to reduce the order.  Large values of  ìnfo.tcond or ìnfo.fnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: grmcover1 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, ìnfo.stdim = νr contains the information corresponding to the proper part of sysx. \n\nMethod: The method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting order (McMillan degree) of sysx is the least achievable one provided the realization of sys2 is maximally observable  (i.e., the pair (A2+B2*F-λE2,C2+D2*F) is observable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glmcover1","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glmcover1","text":"glmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a left minimum dynamic cover of Type 1 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + Y(λ)*X2(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\nglmcover1(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,B,[C1; C2],[D1; D2]),  where C1 and D1 have p1 rows, to define   the proper descriptor systems sys1 = (A-λE,B,C1,D1) and sys2 = (A-λE,B,C2,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and B1 = B2 = B).   \n\nThe resulting descriptor systems sysx and sysy have observable realizations of the form sysx = (Ao-λEo,Bo1,Co,D1) and sysy = (Ao-λEo,Bo2,Co,0),  where the pencil [Ao-λEo; Co] is in a (observability) staircase form,   with νl[i] x νl[i+1] full row rank diagonal blocks, for i = 1, ..., nl,  with νl[nl+1] := p1. \n\nThe resulting named triple ìnfo contains (stdim, tcond, fnorm),  where ìnfo.stdim = νl is a vector which contains the column dimensions of the blocks of the staircase form [Ao-λEo; Co], ìnfo.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and ìnfo.fnorm is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order.  Large values of  ìnfo.tcond or ìnfo.fnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: glmcover1 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, ìnfo.stdim = νl contains the information corresponding to the proper part of sysx. \n\nMethod: The dual of method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally controllable  (i.e., the pair (A2+F*C2-λE2,B2+F*D2) is controllable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grmcover2","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grmcover2","text":"grmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a right minimum dynamic cover of Type 2 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + X2(λ)*Y(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\ngrmcover2(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,[B1 B2],C,[D1 D2]),  where B1 and D1 haves m1 columns, to define   the proper descriptor systems sys1 = (A-λE,B1,C,D1) and sys2 = (A-λE,B2,C,D2) (i.e., A1-λE1 = A2-λE2 =: A-λE and C1 = C2 =: C).   \n\nThe resulting descriptor systems sysx and sysy have controllable realizations of the form sysx = (Ar-λEr,Br,Cr1,Dr1) and sysy = (Ar-λEr,Br,Cr2,Dr2),  where the pencil [Br Ar-λEr] is in a (controllability) staircase form,   with νr[i] x νr[i-1] full row rank diagonal blocks, for i = 1, ..., nr,  with νr[0] := m1. \n\nThe resulting named triple ìnfo contains (stdim, tcond, fnorm, gnorm),  where ìnfo.stdim = νr is a vector which contains the row dimensions of the blocks of the staircase form [Br Ar-λEr], ìnfo.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, ìnfo.fnorm is  the Frobenius-norm of the (internally) employed state-feedback gain to reduce the order, ìnfo.gnorm is  the Frobenius-norm of the (internally) employed feedforward gain to reduce the order.  Large values of  ìnfo.tcond, ìnfo.fnorm  or  ìnfo.gnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of     A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: grmcover2 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, ìnfo.stdim = νr contains the information corresponding to the proper part of sysx. \n\nMethod: The method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally observable  (i.e., the pair (A2+B2*F-λE2,C2+D2*F) is observable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glmcover2","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glmcover2","text":"glmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a left minimum dynamic cover of Type 2 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + Y(λ)*X2(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\nglmcover2(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,B, [C1; C2],[D1; D2]),  where C1 and D1 have p1 rows and E is invertible, to define   the proper descriptor systems sys1 = (A-λE,B,C1,D1) and sys2 = (A-λE,B,C2,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and B1 = B2 = B).   \n\nThe resulting descriptor systems sysx and sysy have observable realizations of the form sysx = (Ao-λEo,Bo1,Co,Do1) and sysy = (Ao-λEo,Bo2,Co,Do2),  where the pencil [Ao-λEo; Co] is in a (observability) staircase form,   with νl[i] x νl[i+1] full row rank diagonal blocks, for i = 1, ..., nl,  with νl[nl+1] := p1. \n\nThe resulting named triple ìnfo contains (stdim, tcond, fnorm, gnorm),  where ìnfo.stdim = νl is a vector which contains the column dimensions of the blocks of the staircase form [Ao-λEo; Co], ìnfo.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, ìnfo.fnorm is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order, and  ìnfo.gnorm is the Frobenius-norm of the (internally) employed output-feedforward gain.  Large values of  ìnfo.tcond,ìnfo.fnorm or ìnfo.gnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: glmcover2 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, ìnfo.stdim = νl contains the information corresponding to the proper part of sysx. \n\nMethod: The dual of method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally controllable  (i.e., the pair (A2+F*C2-λE2,B2+F*D2) is controllable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#Interconnecting-descriptor-system-models-1","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"","category":"section"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append\nparallel\nseries\nhorzcat\nvertcat","category":"page"},{"location":"connections.html#DescriptorSystems.append","page":"Interconnecting descriptor system models","title":"DescriptorSystems.append","text":"sys = append(systems...)\n\nAppend the descriptor systems systems by concatenating the input and output vectors of individual systems. This corresponds to the block diagonal concatenation of  their transfer function matrices.  Appending systems with constant matrices, vectors or scalars or with UniformScalings is also supported. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.parallel","page":"Interconnecting descriptor system models","title":"DescriptorSystems.parallel","text":"sys = parallel(sys1, sys2) \nsys = sys1 + sys2\n\nConnect the descriptor systems sys1 and sys2 in parallel such that sys = sys1 + sys2.  This coupling corresponds to the addition of their transfer function matrices.  Parallel coupling of systems with constant matrices or vectors having the same row and column dimensions  or with UniformScalings is also supported.  Parallel coupling with a constant is equivalent to elementwise parallel coupling of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.series","page":"Interconnecting descriptor system models","title":"DescriptorSystems.series","text":" sys = series(sys1, sys2) \n sys = sys2*sys1\n\nConnect the descriptor systems sys1 and sys2 in series such that sys = sys2*sys1. This coupling corresponds to the multiplication of their transfer function matrices.  Series coupling of systems with constant matrices and vectors having suitable dimensions  or with UniformScalings is also supported.  Series coupling with a constant is equivalent to elementwise multiplication of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.horzcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.horzcat","text":"sys = horzcat(sys1,sys2)\nsys = [sys1 sys2]\nsys = horzcat(systems...)\n\nConcatenate horizontally two systems sys1 and sys2 or several descriptor systems systems...  by concatenating the input vectors of individual systems. This corresponds to the horizontal  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same row dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.vertcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.vertcat","text":"sys = vertcat(sys1,sys2)\nsys = [sys1; sys2]\nsys = vert(systems...)\n\nConcatenate vertically two descriptor systems sys1 and sys2 or several descriptor systems systems...  by concatenating the output vectors of individual systems. This corresponds to the vertical  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same column dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#Some-operations-on-rational-transfer-functions-and-matrices-1","page":"Some operations on rational transfer functions and matrices","title":"Some operations on rational transfer functions and matrices","text":"","category":"section"},{"location":"operations_rtf.html#","page":"Some operations on rational transfer functions and matrices","title":"Some operations on rational transfer functions and matrices","text":"simplify  Pole-zero cancellation.\nnormalize   Normalization of a rational transfer function to monic denominator.\nconfmap   Applying a conformal mapping transformation to a rational transfer function.\nrmconfmap   Applying a conformal mapping transformation to a rational transfer function matrix.\nzpk  Computation of zeros, poles and gain of a rational transfer function.\nrtfbilin  Generation of common bilinear transformations and their inverses.","category":"page"},{"location":"operations_rtf.html#","page":"Some operations on rational transfer functions and matrices","title":"Some operations on rational transfer functions and matrices","text":"simplify\nnormalize\nconfmap\nrmconfmap\nzpk\nrtfbilin","category":"page"},{"location":"operations_rtf.html#DescriptorSystems.simplify","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.simplify","text":" simplify(r; atol = 0, rtol = atol)\n\nSimplify the rational transfer function r(λ) by cancellation of common divisors of numerator and denominator.  The keyword arguments atol and rtol are the absolute and relative tolerances for the nonzero numerator and denominator coefficients. \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#LinearAlgebra.normalize","page":"Some operations on rational transfer functions and matrices","title":"LinearAlgebra.normalize","text":" normalize(r; atol = 0, rtol = atol)\n\nNormalize the rational transfer function r(λ) to have a monic denominator polynomial. \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.confmap","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.confmap","text":"rt = confmap(r, f)\n\nApply the conformal mapping transformation λ = f(δ) to the rational transfer function r(λ)  and return rt(δ) = r(f(δ)). The resulting rt inherits the sampling time and variable of f.\n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.rmconfmap","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.rmconfmap","text":"Rt = rmconfmap(R, f)\n\nApply elementwise the conformal mapping transformation λ = f(δ) to the rational transfer function matrix R(λ)  and return Rt(δ) = R(f(δ)). The resulting elements of Rt inherit the sampling time and variable of f.\n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.zpk","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.zpk","text":" zpk(r) -> (z, p, k)\n\nCompute the roots (zeros) z, poles p and gain k of the rational transfer function r(λ).\n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.rtfbilin","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.rtfbilin","text":" rtfbilin(type = \"c2d\"; Ts = T, Tis = Ti, a = val1, b = val2, c = val3, d = val4) -> (g, ginv)\n\nBuild the rational transfer functions of several commonly used bilinear transformations and their inverses.  The resulting g describes the rational transfer function g(δ) in the bilinear transformation λ = g(δ) and  ginv describes its inverse transformation ginv(λ) in the bilinear transformation δ = ginv(λ). In accordance with the values of type and the keyword argument values Ts, Tis, a, b, c, and d,  the resulting g and ginv contain first order rational transfer functions of the form g(δ) = (a*δ+b)/(c*δ+d)  and ginv(λ) = (d*λ-b)/(-c*λ+a), respectively, which satisfy g(ginv(λ)) = λ and ginv(g(δ)) = δ. \n\nDepending on the value of type, the following types of transformations can be generated  in conjunction with parameters specified in Ts, Tis, a, b, c, and d:\n\n\"Cayley\" - Cayley transformation: `s = g(z) = (z-1)/(z+1)` and `z = ginv(s) = (s+1)/(-s+1)`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n           g(z) and ginv(s) are also known as the continuous-to-discrete and discrete-to-continuous transformations, respectively; \n\n\"c2d\"    - is alias to \"Cayley\"\n\n\"Tustin\" - Tustin transformation (also known as trapezoidal integration): `s = g(z) = (2*z-2)/(T*z+T)` and `z = ginv(s) = (T*s+2)/(-T*s+2)`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n\n\"Euler\"  - Euler integration (or forward Euler integration): `s = g(z) = s = (z-1)/T` and `z = ginv(s) = T*s+1`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n\n\"BEuler\" - Backward Euler integration (or backward Euler integration): `s = g(z) = (z-1)/(T*z)` and `z = ginv(s) = 1/(-T*s+1)`;\n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n\n\"Moebius\" - general (Moebius ) bilinear transformation: `λ = g(δ) = (a*δ+b)/(c*δ+d)` and `δ = ginv(λ) = (d*λ-b)/(-c*λ+a)`;  \n            the sampling times `g.Ts` and `ginv.Ts` are  set to the values `T` and `Ti`, respectively;\n            the default values of the parameters `a`, `b`, `c`, and `d` are `a = 1`, `b = 0`, `c = 0`, and `d = 1`.\n            Some useful particular Moebius transformations correspond to the following choices of parameters: \n            - _translation_: `a = 1`, `b ≠ 0`, `c = 0`, `d = 1` (`λ = δ+b`)\n            - _scaling_: `a ≠ 0`, `b = 0`, `c = 0`, `d = 1` (`λ = a*δ`)\n            - _rotation_: `|a| = 1`, `b = 0`, `c = 0`, `d = 1` (`λ = a*δ`)\n            - _inversion_: `a = 0`, `b = 1`, `c = 1`, `d = 0`  (`λ = 1/δ`)\n\n\"lft\"     - alias to \"Moebius\" (linear fractional transformation).\n\n\n\n\n\n","category":"function"},{"location":"makeindex.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html#","page":"Index","title":"Index","text":"Pages = [ \"dss.md\",\n          \"rtf.md\",\n          \"operations.md\",\n          \"operations_rtf.md\",\n          \"connections.md\",\n          \"order_reduction.md\",\n          \"analysis.md\",\n          \"factorizations.md\",\n          \"advanced_operations.md\",\n          \"dstools.md\" ]\nModule = [\"DescriptorSystems\"]\nOrder = [:type, :function]","category":"page"},{"location":"analysis.html#Descriptor-system-analysis-1","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"","category":"section"},{"location":"analysis.html#","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"isregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.","category":"page"},{"location":"analysis.html#","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"isregular\ngpole\ngpoleinfo\nisproper\nisstable\ngzero\ngzeroinfo\ngnrank\nghanorm\ngl2norm\ngh2norm\nglinfnorm\nghinfnorm","category":"page"},{"location":"analysis.html#MatrixPencils.isregular","page":"Descriptor system analysis","title":"MatrixPencils.isregular","text":"isregular(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has a regular pole pencil A-λE and false otherwise.  \n\nTo test whether the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0),   the underlying computational procedure reduces the pencil A-λE to an appropriate Kronecker-like form,  which provides information on the rank of A-λE. \n\nThe keyword arguements atol1, atol2 and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E, and the relative tolerance  for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of  A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpole","page":"Descriptor system analysis","title":"DescriptorSystems.gpole","text":"val = gpole(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE.  The values in val are the poles of the transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor E nonsingular, val contains the generalized eigenvalues of the pair (A,E).  For E singular, val contains the zeros of P(λ), which are computed  by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe regularity of A-λE is implicitly checked. If check_reg = true, an error message is issued if the pencil    A-λE is singular. If check_reg = false and the pencil A-λE is singular, then n-r poles are set to NaN, where n is the system order and r is the normal rank of A-λE. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpoleinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gpoleinfo","text":"gpoleinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE and the named tuple info containing information on  the eigenvalue structure of the pole pencil P(λ). The values in val are the poles of the  transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite eigenvalues, in conjunction with a stability domain boundary offset β to numerically assess the  finite eigenvalues  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite eigenvalues having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite eigenvalues having moduli in the interval [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfev is the number of finite eigenvalues of the pencil A-λE (also the number of finite poles of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil A-λE;\n\ninfo.nisev is the number of simple infinite eigenvalues of the pencil A-λE (also known as non-dynamic modes); \n\ninfo.nip is the number of infinite poles of the system sys;\n\ninfo.nfsev is the number of finite stable eigenvalues, i.e., the finite eigenvalues having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbev is the number of finite eigenvalues on the boundary of the            stability domain, i.e., the finite eigenvalues           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuev is the number of finite unstable eigenvalues, i.e., the finite eigenvalues having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nhev is the number of hidden eigenvalues set to NaN          (can be nonzero only if the pencil A-λE is singular);  \n\ninfo.nrank is the normal rank of the pencil A-λE;\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil A-λE as follows:           the i-th element info.miev[i] is the order of an infinite elementary divisor            (i.e., the multiplicity of an infinite eigenvalue) and            the number of infinite poles is the sum of the components of info.miev;  \n\ninfo.mip is an integer vector, which contains the information on the              multiplicities of the infinite zeros of A-λE as follows:             the i-th element info.mip[i] is equal to k-1, where k is the order of an infinite elementary               divisor with k > 0 and the number of infinite poles is the sum of the components of info.mip; \n\ninfo.rki is an integer vector, which contains the right Kronecker indices             of the pencil A-λE (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices            of the pencil A-λE (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil A-λE is regular and set to   false, if the pencil A-λE is singular;\n\ninfo.proper is set to true, if the pencil A-λE is regular and all its infinite                   eigenvalues are simple (has only non-dynamic modes), or                   is set to false, if the pencil A-λE is singular or has higher order infinite eigenvalues;\n\ninfo.stable is set to true, if the pencil A-λE is regular, has only stable                   finite eigenvalues and all its infinite eigenvalues are                  simple (has only non-dynamic modes), and  is set to false otherwise.\n\nNote: The finite poles and the finite eigenvalues of the pencil P(λ) are the same,  but the multiplicities of infinite eigenvalues of P(λ) are in excess with one to the multiplicities of infinite poles.\n\nFor the reduction of the pencil P(λ) to an appropriate Kronecker-like form   orthonal similarity transformations are performed, which involve rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of P(λ), and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isproper","page":"Descriptor system analysis","title":"DescriptorSystems.isproper","text":"isproper(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = = n*ϵ, fast = true)\n\nReturn true if the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D) is proper and false otherwise.  \n\nFor a descriptor system realization sys = (A-λE,B,C,D) without uncontrollable and unobservable infinite eigenvalues, it is checked that the pencil A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple. If the original descriptor realization has uncontrollable or unobservable infinite eigenvalues, these are elliminated using orthogonal pencil reduction algorithms. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isstable","page":"Descriptor system analysis","title":"DescriptorSystems.isstable","text":"isstable(sys[, smarg]; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, offset = sqrt(ϵ))\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has only stable poles and false otherwise.  \n\nIt is checked that the pole pencil P(λ) := A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple, and additionally the real parts of all finite eigenvalues  are less than smarg-β for a continuous-time system or  have moduli less than smarg-β for a discrete-time system, where smarg is the stability margin and  β is the stability domain boundary offset.  The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system. The offset  β to be used to numerically assess the stability of eigenvalues  can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor E singular, the computation of the poles is performed by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzero","page":"Descriptor system analysis","title":"DescriptorSystems.gzero","text":"val = gzero(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing the  finite and infinite Smith zeros of the system matrix pencil  \n\n           | A-λE | B | \n   S(λ) := |------|---| .\n           |  C   | D |\n\nThe values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible.  \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzeroinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gzeroinfo","text":"gzeroinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite Smith zeros of the system matrix pencil S(λ) \n\n          | A-λE | B | \n   S(λ) = |------|---| \n          |  C   | D |\n\nand the named tuple info containing information on the Kronecker structure of the pencil S(λ).  The values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible. \n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite zeros, in conjunction with a stability domain boundary offset β to numerically assess the  finite zeros  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite zeros having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite zeros having moduli in the interva [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfz is the number of finite eigenvalues of the pencil S(λ) (also the number of finite zeros of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil S(λ);\n\ninfo.nisev is the number of  simple infinite eigenvalues of the pencil S(λ); \n\ninfo.niz is the number of infinite zeros of the system sys;\n\ninfo.nfsz is the number of finite stable zeros, i.e., the finite zeros having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbz is the number of finite zeros on the boundary of the            stability domain, i.e., the finite zeros           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuz is the number of finite unstable zeros, i.e., the finite zeros having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nrank is the normal rank of the pencil S(λ);\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil S(λ)              (also the dimensions of the elementary infinite blocks in the           Kronecker form of S(λ));\n\ninfo.miz is an integer vector, which contains the information on the              multiplicities of the infinite zeros of S(λ) as follows:             S(λ) has info.mip[i] infinite zeros of multiplicity i, and               is empty if S(λ) has no infinite zeros;\n\ninfo.rki is an integer vector, which contains the right Kronecker indices           of the pencil S(λ) (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices          of the pencil S(λ) (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil S(λ) is regular and set to   false, if the pencil S(λ) is singular;\n\ninfo.stable is set to true, if the pencil S(λ) has only stable                   finite zeros and all its infinite zeros are                  simple and  is set to false otherwise.\n\nNote: The finite zeros and the finite eigenvalues of the pencil S(λ) are the same, but the multiplicities of infinite eigenvalues     are in excess with one to the multiplicities of infinite zeros. \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gnrank","page":"Descriptor system analysis","title":"DescriptorSystems.gnrank","text":"r = gnrank(sys, fastrank = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCompute the normal rank r of the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D). \n\nThe normal rank of G(λ) is evaluated as r = k - n, where k is the normal rank of the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nand n is the order of the system sys (i.e., the size of A). \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting the singular values of S(γ) greater than max(max(atol1,atol2), rtol*σ₁),  where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghanorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghanorm","text":"ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hanorm, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the Hankel norm hanorm = small G(lambda)_H and the vector of Hankel singular values hs of the system.\n\nFor a proper system with E singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gl2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gl2norm","text":"gl2norm(sys, h2norm = false, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the L2 norm of its transfer function  matrix G(λ). The L2 norm is infinite if the pole pencil A-λE has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  The L2 norm is also infinite for a continuous-time system having a gain at infinity greater than atolinf. \n\nTo check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli in the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf h2norm = true, the H2 norm is computed.  The H2 norm is infinite if the pole pencil A-λE has unstable zeros (i.e., unstable poles), or for a continuous-time system having a gain at infinity greater than atolinf.   To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atol3 specifies the absolute tolerance for the nonzero elements of B and is only used if h2norm = false for controllability tests of unstable eigenvalues.  The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at  λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gh2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gh2norm","text":"gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the H2 norm of its transfer function  matrix G(λ). The H2 norm is infinite, if sys has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the pole pencil A-λE must have real parts less  than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol.  \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.glinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.glinfnorm","text":"glinfnorm(sys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (linfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the L∞ norm linfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The L∞ norm is infinite if the pole pencil A-λE has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.   To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli within the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nIf hinfnorm = true, the H∞ norm is computed. In this case, the stability of the zeros of A-λE is additionally checked and  the H∞ norm is infinite for an unstable system. To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghinfnorm","text":"ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hinfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the H∞ norm hinfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The H∞ norm is infinite if the pole pencil A-λE has unstable zeros (i.e., sys has unstable poles).  To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#System-utilities-1","page":"System utilities","title":"System utilities","text":"","category":"section"},{"location":"dstools.html#","page":"System utilities","title":"System utilities","text":"order   Order of a system.\nsize    Number of outputs and inputs of a descriptor system .\niszero   Checking whether the transfer function matrix of a descriptor system is zero.\nevalfr   Gain of the transfer function matrix at a single frequency value.\ndcgain   DC gain of a system.\nopnorm   L2- and L∞-norms of a descriptor system.\nrss   Generation of randomized standard state-space systems.\nrdss   Generation of randomized descriptor state-space systems.\ngsvselect   Building a descriptor systems by selecting a set of state variables.","category":"page"},{"location":"dstools.html#","page":"System utilities","title":"System utilities","text":"order\nDescriptorSystems.size\nDescriptorSystems.iszero\nevalfr\ndcgain\nDescriptorSystems.opnorm\nrss\nrdss\ngsvselect","category":"page"},{"location":"dstools.html#DescriptorSystems.order","page":"System utilities","title":"DescriptorSystems.order","text":"n = order(r)\n\nDetermine the order n of a rational transfer function r as the maximum of degrees of its numerator and denominator polynomials (n is also known as the McMillan degree of r).  \n\n\n\n\n\nnx = order(sys)\n\nReturn the order nx of the descriptor system sys as the dimension of the state variable vector.  For improper or non-minimal systems, nx is less than the McMillan degree of the system.   \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.size","page":"System utilities","title":"Base.size","text":"size(sys) -> (p,m)\nsize(sys,1) -> p\nsize(sys,2) -> m\n\nReturn the number of outputs p and the number of inputs m of a descriptor system sys.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.iszero","page":"System utilities","title":"Base.iszero","text":" iszero(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, fastrank = true)\n\nReturn true if the transfer function matrix of the descriptor system sys is zero.  For a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) it is checked  that the normal rank of G(λ) is zero, or equivalently (see [1]), that the normal rank of  the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nis equal to n, the order of the system sys. \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting how many singular values of S(γ) have magnitudes  greater than max(max(atol1,atol2), rtol*σ₁), where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl, are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga,  On checking null rank conditions of rational matrices, 2018.  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.evalfr","page":"System utilities","title":"DescriptorSystems.evalfr","text":"Rval = evalfr(R,val)\n\nEvaluate the rational transfer function matrix R(λ) for λ = val. \n\n\n\n\n\nRval = evalfr(R; fval = 0)\n\nEvaluate the rational transfer function matrix R(λ) for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*Ts) for a discrete-time system,  with Ts the system sampling time.  \n\n\n\n\n\nrval = evalfr(r,val)\n\nEvaluate the rational transfer function  r(λ) for λ = val. \n\n\n\n\n\nrval = evalfr(r; fval = 0)\n\nEvaluate the rational transfer function  r(λ) for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*Ts) for a discrete-time system,  with Ts the system sampling time.   \n\n\n\n\n\nGval = evalfr(sys, val; atol1 = 0, atol2 = 0, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\nGval = evalfr(sys; fval = 0, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*sys.Ts) for a discrete-time system.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dcgain","page":"System utilities","title":"DescriptorSystems.dcgain","text":"Gval = dcgain(sys; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the DC (or steady-state) gain. Gval is the value of the  rational matrix G(λ) for λ = val, where for a continuous-time system val = 0 and  for a discrete-time system val = 1. The computed Gval has infinite entries if val is a pole of G(λ). In this case (i.e., val*E-A is singular), the entries of Gval are evaluated separately for minimal realizations  of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation  algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#LinearAlgebra.opnorm","page":"System utilities","title":"LinearAlgebra.opnorm","text":" opnorm(sys[, p = Inf]; kwargs...) \n opnorm(sys, 2; kwargs...) -> sysnorm\n opnorm(sys, Inf; kwargs...) -> (sysnorm, fpeak)\n opnorm(sys; kwargs...) -> (sysnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the L2 or L∞ system norm sysnorm induced by the vector p-norm, where valid values of p are 2 or Inf.  For the L∞ norm, the frequency fpeak is also returned, where G(λ) achieves its peak gain.  See gh2norm and ghinfnorm for a description of the allowed keyword arguments.  \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rss","page":"System utilities","title":"DescriptorSystems.rss","text":"sys = rss(n, p, m; disc = false, T = Float64, stable = false, nuc = 0, nuo = 0, randt = true)\n\nGenerate a randomized n+nuc+nuo-th order standard state-space system sys = (A,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T. The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true. If stable = true, the resulting system is stable, with A having all eigenvalues with negative real parts for a continuous-time system,  or with moduli less than one for a discrete-time system.  If nuc+nuo > 0, the system sys is non-minimal, with A having nuc uncontrollable and nuo unobservable eigenvalues.  If  randt = true, a randomly generated orthogonal or unitary similarity transformation is additionally applied.     If randt = false, the system matrices A, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable eigenvalues of A:\n\nA = diag(A1, A2, A3),  B = [B1; 0; B3], C = [C1 C2 0]\n\nwith the diagonal blocks A1, A2, A3 of orders n, nuc, and nuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rdss","page":"System utilities","title":"DescriptorSystems.rdss","text":"sys = rdss(n, p, m; id = [ ], disc = false, T = Float64, stable = false, nfuc = 0, iduc = [ ], \n           nfuo = 0, iduo = [ ], randlt = true, randrt = true)\n\nGenerate a randomized descriptor state-space system sys = (A-λE,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T.  The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true.\n\nIf the vector id is nonempty, then id[i] specifies the order of the i-th infinite elementary divisor of the resulting pencil A-λE, which thus has n finite eigenvalues and ni = sum(id) infinite eigenvalues which are controllable and observable.  If nfuc+nfuo > 0, the system sys is non-minimal, with A having nfuc uncontrollable and nfuo unobservable finite eigenvalues.  If the vector iduc is a nonempty, then iduc[i] specifies the order of the i-th infinite elementary divisor  with uncontrollable infinite eigenvalues of the resulting pencil A-λE, which thus has niuc = sum(iduc) uncontrollable infinite eigenvalues.  If the vector iduo is a nonempty, then iduo[i] specifies the order of the i-th infinite elementary divisor with  unobservable infinite eigenvalues of the resulting pencil A-λE, which thus has niuo = sum(iduo) unobservable infinite eigenvalues.  If niuc+niuo > 0, the system sys is non-minimal, with A having niuc uncontrollable and niuo unobservable infinite eigenvalues. \n\nIt follows, that the resulting pencil A-λE has  n+nfuc+nfuo finite eigenvalues and ni+niuc+niuo infinite eigenvalues.  If stable = true, the proper part of the system sys is stable, with A having all finite eigenvalues with negative real parts  for a continuous-time system, or with moduli less than one for a discrete-time system. \n\nIf  randlt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E, and B from the left.     If  randrt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E,  and C from the right.     If randlt = false and randrt = false, the system matrices A, E, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable finite and infinite eigenvalues of A-λE:\n\nA-λE = diag(A1-λE1, A2-λE2, A3-λE3, A4-λE4, A5-λE5, A6-λE6),  \nB = [B1; B2; 0; 0; B5; B6 ], \nC = [C1 C2 C3 C4 0 0]\n\nwith the diagonal blocks A1, A2, A3, A4, A5, A6 of orders n, ni, nfuc, niuc, nfuo and niuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.gsvselect","page":"System utilities","title":"DescriptorSystems.gsvselect","text":"sysr = gsvselect(sys,ind)\n\nConstruct for the descriptor system sys = (A-λE,B,C,D) of order n the descriptor system   sysr = (A[ind,ind]-λE[ind,ind],B[ind,:],C[:,ind],D) of order nr = length(ind),  by selecting the state variables of sys with indices specified by ind.  If ind is a permutation vector of length n, then sysr has the same transfer function matrix as sys  and permuted state variables. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#Simplification-of-descriptor-system-models-1","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"","category":"section"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.\ngss2ss   Conversion to SVD-like forms without non-dynamic modes.","category":"page"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal\ngir\ngbalmr\ngss2ss","category":"page"},{"location":"order_reduction.html#DescriptorSystems.gminreal","page":"Simplification of descriptor system models","title":"DescriptorSystems.gminreal","text":"sysr = gminreal(sys; contr = true, obs = true, noseig = true, fast = true, \n                atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if contr = true, obs = true and nseig = true.  Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced.\n\nIf nseig = false, then condition (5) on the lack of simple infinite eigenvalues is not enforced. \n\nTo enforce conditions (1)-(4), orthogonal similarity transformations are performed on  the matrices of the original realization (A-λE,B,C,D) to obtain an irreducible realization using structured pencil reduction algorithms, as the fast versions of the reduction techniques of the  full row rank pencil [B A-λE] and full column rank pencil [A-λE;C] proposed in [1].  To enforce condition (5), residualization formulas (see, e.g., [2, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gir","page":"Simplification of descriptor system models","title":"DescriptorSystems.gir","text":"sysr = gir(sys; finite = true, infinite = true, contr = true, obs = true, noseig = false,\n           fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if finite = true, infinite = true, contr = true,  obs = true and nseig = true. Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible and is computed by default. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs, finite, infinite and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced.  If contr = true and finite = true, then the finite controllability condition (1) is enforced.  If contr = true and finite = false, then the finite controllability condition (1) is not enforced.  If contr = true and infinite = true, then the infinite controllability condition (2) is enforced.  If contr = true and infinite = false, then the infinite controllability condition (2) is not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced. If obs = true and finite = true, then the finite observability condition (3) is enforced. If obs = true and finite = false, then the finite observability condition (3) is not enforced. If obs = true and infinite = true, then the infinite observability condition (4) is enforced. If obs = true and infinite = false, then the infinite observability condition (4) is not enforced.\n\nIf nseig = true, then condition (5) on the lack of simple infinite eigenvalues is also enforced. \n\nTo enforce conditions (1)-(4), the Procedure GIR in [1, page 328] is employed, which performs  orthogonal similarity transformations on the matrices of the original realization (A-λE,B,C,D)  to obtain an irreducible realization using structured pencil reduction algorithms.  To enforce condition (5), residualization formulas (see, e.g., [1, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gbalmr","page":"Simplification of descriptor system models","title":"DescriptorSystems.gbalmr","text":"gbalmr(sys, balance = false, matchdc = false, ord = missing, atolhsv = 0, rtolhsv = nϵ, \n       atolmin = atolhsv, rtolmin = rtolhsv, \n       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -> (sysr, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nIf E is singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gss2ss","page":"Simplification of descriptor system models","title":"DescriptorSystems.gss2ss","text":"gss2ss(sys; Eshape = \"ident\", atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ) -> (sysr, r)\n\nConvert the descriptor system sys = (A-λE,B,C,D) to an input-output equivalent descriptor system realization  sysr = (Ar-λEr,Br,Cr,Dr) without non-dynamic modes and having the same transfer function matrix. The resulting Er is in the SVD-like form Er = blockdiag(E1,0), with E1 an r × r nonsingular matrix,  where r is the rank of E.\n\nThe keyword argument Eshape specifies the shape of E1 as follows:\n\nif Eshape = \"ident\" (the default option), E1 is an identity matrix of order r and if E is nonsingular,  then the resulting system sysr is a standard state-space system;\n\nif Eshape = \"diag\", E1 is a diagonal matrix of order r, where the diagonal elements are the  decreasingly ordered nonzero singular values of E;\n\nif Eshape = \"triu\", E1 is an upper triangular nonsingular matrix of order r. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nIf Eshape = \"triu\", the reductions of E and A are performed using rank decisions based on rank revealing  QR-decompositions with column pivoting.  If Eshape = \"ident\" or Eshape = \"diag\" the reductions are performed using the more reliable SVD-decompositions.\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#Factorization-of-descriptor-system-transfer-function-matrices-1","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"","category":"section"},{"location":"factorizations.html#","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"grcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.","category":"page"},{"location":"factorizations.html#","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"grcf\nglcf\ngrcfid\nglcfid\ngiofac\ngoifac","category":"page"},{"location":"factorizations.html#DescriptorSystems.grcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcf","text":"grcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper right coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg < 0,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Bn = Bm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The Procedure GRCF from [2] is implemented, which represents an extension of the recursive factorization approach of [1] to cope with   infinite eigenvalues. All infinite poles are assigned to finite real values.  If evals is missing or does not contain a sufficient   number of real values, then a part or all of infinite eigenvalues of A-λE are   assigned to the value specified by sdeg. The pairs (An,En) and (Am,Em)  result in generalized Schur form with both An and Am quasi-upper triangular   and En and Em either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcf","text":"glcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper left coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Cn = Cm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A and n is the order of the system sys.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The dual of Procedure GRCF from [2] is used, which represents an extension of the recursive factorization approach of [1] to cope with   infinite poles. All infinite eigenvalues are assigned to finite real values.  If evals is missing or does not contain a sufficient  number of real values, then a part or all of infinite eigenvalues of A-λE are  assigned to the value specified by sdeg.   The pairs (An,En) and (Am,Em)  result in generalized Schur form with  both An and Am quasi-upper triangular  and En and Em either both upper triangular or both UniformScalings.\n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.grcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcfid","text":"grcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  right coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in (generalized) Schur form.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Bni = Bmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1]  is used (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcfid","text":"glcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  left coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in Schur forms.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Cni = Cmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1] is used  to the dual system (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.giofac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.giofac","text":"giofac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full row rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Gi[:,1:r](λ)*Go(λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full row rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended QR-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple ìnfo contains (nrank, nfuz, niuz), where ìnfo.nrank = r,  the normal rank of G(λ), ìnfo.nfuz is the number of finite zeros of syso on  the boundary of Cs, and ìnfo.niuz is the number of infinite zeros of syso.  ìnfo.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and B,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the system pencil [A-λE B; C D] is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the factorization algorithm of [1] is used, while  for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307-2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.goifac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.goifac","text":"goifac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full column rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Go(λ)*Gi[1:r,:](λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full column rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended RQ-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple ìnfo contains (nrank, nfuz, niuz), where ìnfo.nrank = r,  the normal rank of G(λ), ìnfo.nfuz is the number of finite zeros of syso on  the boundary of Cs, and ìnfo.niuz is the number of infinite zeros of syso.  ìnfo.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and C,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the dual system pencil transpose([A-λE B; C D]) is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the dual system is formed and the factorization algorithm  of [1] is used, while for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307–2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"rtf.html#Building-rational-transfer-functions-1","page":"Building rational transfer functions","title":"Building rational transfer functions","text":"","category":"section"},{"location":"rtf.html#","page":"Building rational transfer functions","title":"Building rational transfer functions","text":"RationalTransferFunction  Construction of rational transfer function object.\nrtf  Building rational transfer functions.","category":"page"},{"location":"rtf.html#","page":"Building rational transfer functions","title":"Building rational transfer functions","text":"RationalTransferFunction\nrtf","category":"page"},{"location":"rtf.html#DescriptorSystems.RationalTransferFunction","page":"Building rational transfer functions","title":"DescriptorSystems.RationalTransferFunction","text":" RationalTransferFunction{T}(num::Polynomial{T}, den::Polynomial{T}, Ts::Union{Real,Nothing}) where T <: Number\n\nConstruct a rational transfer function model from its numerator and denominator polynomials num and den, respectively, and a sampling time Ts. \n\nIf r::RationalTransferFunction{T} is a rational transfer function system model object  defined as r(λ) = num(λ)/den(λ), where  num(λ) and den(λ) are polynomials in the indeterminate λ, then:\n\nr.num is the numerator polynomial num(λ) with coefficients of type T and  indeterminate λ; \n\nr.den is the denominator polynomial den(λ) with coefficients of type T and  indeterminate λ; \n\nr.Ts is the sampling time Ts, where Ts can have the following values:\n\nTs = 0 for a continuous-time system and           λ = s is the complex variable in the Laplace transform; \nTs > 0 or Ts = -1 for a discrete-time system and           λ = z is the complex variable in the Z-transform;           Ts = -1 indicates a discrete-time system with an unspecified sampling time;\nTs = nothing for a general rational function with indeterminate λ.             \n\nThe symbol (or variable) used for the indeterminate λ is the common symbol used for the  indeterminates of the polynomials num(λ) and den(λ) and can be obtained as r.var.  The roots of the numerator polynomial num(λ) (also called zeros of r(λ)) can be obtained as r.zeros, while the roots of the denominator polynomial den(λ)  (also called poles of r(λ)) can be obtained as r.poles.  The ratio of the leading polynomial coefficients of num(λ) and den(λ)  (also called gain of r(λ)) can be obtained as r.gain.\n\n\n\n\n\n","category":"type"},{"location":"rtf.html#DescriptorSystems.rtf","page":"Building rational transfer functions","title":"DescriptorSystems.rtf","text":"r = rtf(num, den; Ts = 0, var = Polynomials.indeterminate(num))\n\nCreate for the polynomials num(λ) and den(λ), sampling time Ts and variable name var the rational transfer function r(λ) = num(λ)/den(λ) of a single-input single-output system of the form\n\nY(λ) = r(λ) U(λ),\n\nwhere U(λ) and Y(λ) are the Laplace transformed, if Ts = 0, or Z-transformed, if Ts ≠ 0, system input u(t) and system output y(t), respectively, and  λ = s,  if Ts = 0, or  λ = z,  if Ts ≠ 0. For Ts = nothing, r(λ) represents a general  rational function of indeterminate λ. The resulting r is such that r.Ts = Ts and r.var = var.  \n\nBoth num(λ) and den(λ) can be real or complex numbers as well. \n\n\n\n\n\nr = rtf(f; Ts = nothing, var = :λ)\n\nSet for the rational transfer function r(λ) = f(λ) the sampling time to Ts and variable name to var such that r(λ) = f(λ), r.Ts = Ts (default r.Ts = f.Ts) and r.var = var (default r.var = f.var).\n\n\n\n\n\nr = rtf(p; Ts = nothing, var = :λ)\n\nCreate for the polynomial p(λ), sampling time Ts and variable var the rational transfer function r(λ) = p(λ) such that r.Ts = Ts (default r.Ts = nothing) and r.var = var (default  (default r.var = Polynomials.indeterminate(f)). p(λ) can be a real or complex number as well. \n\n\n\n\n\nr = rtf(var; Ts = nothing)\nr = rtf('s') or r = rtf('z') \nr = rtf(\"s\") or r = rtf(\"z\") \nr = rtf(:s) or r = rtf(:z)\n\nCreate the rational transfer function r(λ) = λ, such that r.var and r.Ts are set as follows:     (1) r.var = :s and r.Ts = 0 if var = 's', or var = \"s\" or var = :s ;     (2) r.var = :z and r.Ts = Ts if var = 'z', or var = \"z\" or var = :z;     (3) r.var = var and r.Ts = Ts (default Ts = nothing) otherwise.  \n\n\n\n\n\nr = rtf(z, p, k; Ts = nothing, var = :λ)\n\nCreate from the roots (zeros) z, poles p, gain k, sampling time Ts and variable name var the rational transfer function r(λ) = k*num(λ)/den(λ), where num(λ) and den(λ) are monic polynomials with roots equal z and p, respectively, and such that r.Ts = Ts (default r.Ts = nothing)  and r.var = var (default r.var = :λ if r.Ts = nothing, or r.var = :s if r.Ts = 0 or   r.var = :z if r.Ts ≠ 0). \n\n\n\n\n\n","category":"function"},{"location":"operations.html#Basic-operations-on-system-models-1","page":"Basic operations on system models","title":"Basic operations on system models","text":"","category":"section"},{"location":"operations.html#","page":"Basic operations on system models","title":"Basic operations on system models","text":"inv  Inversion of a system.\nldiv   Left division for two systems (also overloaded with \\).\nrdiv   Right division for two systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a system (also overloaded with adjoint and ').\nadjoint  Building the adjoint of a system.\ngbilin  Generalized bilinear transformation of a descriptor system.","category":"page"},{"location":"operations.html#","page":"Basic operations on system models","title":"Basic operations on system models","text":"DescriptorSystems.inv\nldiv\nrdiv\ngdual\nctranspose\nDescriptorSystems.adjoint\ngbilin","category":"page"},{"location":"operations.html#Base.inv","page":"Basic operations on system models","title":"Base.inv","text":"rinv = inv(r)\n\nBuild the inverse rinv of a nonzero rational transfer function r such that rinv(λ) = 1/r(λ). \n\n\n\n\n\nsysinv = inv(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a descriptor realization of its inverse system sysinv = (Ai-λEi,Bi,Ci,Di), such that the transfer function matrix Ginv(λ) of sysinv is the inverse of G(λ) (i.e., G(λ)*Ginv(λ) = I).  The realization of sysinv is determined using inversion-free formulas and the invertibility condition is checked, unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ldiv","page":"Basic operations on system models","title":"DescriptorSystems.ldiv","text":"sysldiv = ldiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, checkinv = true)\nsysldiv = sys1 \\ sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysldiv = (Ai-λEi,Bi,Ci,Di) of sysldiv = inv(sys1)*sys2, whose transfer-function matrix Gli(λ) represents the result of the left division Gli(λ) = inv(G1(λ))*G2(λ).  The realization of sysldiv is determined using inversion-free formulas and the invertibility condition for sys1 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.rdiv","page":"Basic operations on system models","title":"DescriptorSystems.rdiv","text":"sysrdiv = rdiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, checkinv = true)  \nsysrdiv = sys1 / sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysrdiv = (Ai-λEi,Bi,Ci,Di) of sysrdiv = sys1*inv(sys2), whose transfer-function matrix Gri(λ) represents the result of the right division Gri(λ) = G1(λ)*inv(G2(λ)).  The realization of sysrdiv is determined using inversion-free formulas and the invertibility condition for sys2 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2,  and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.gdual","page":"Basic operations on system models","title":"DescriptorSystems.gdual","text":"sysdual = gdual(sys, rev = false) \nsysdual = transpose(sys, rev = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its dual system  sysdual = (Ad-λEd,Bd,Cd,Dd), where Ad = transpose(A), Ed = transpose(E), Bd = transpose(C),  Cd = transpose(B) and Dd = transpose(D),  such that the transfer function matrix Gdual(λ) of sysdual is the transpose of G(λ)  (i.e., Gdual(λ) = transpose(G(λ))). \n\nIf rev = true, the tranposition is combined with the reverse permutation of the state variables, such that sysdual = (P*Ad*P-λP*Ed*P,P*Bd,Cd*P,Dd), where P is the permutation matrix with ones down the second diagonal. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ctranspose","page":"Basic operations on system models","title":"DescriptorSystems.ctranspose","text":"sysconj = ctranspose(sys) \nsysconj = sys'\n\nCompute the conjugate transpose (or adjoint) of a descriptor system (see adjoint). \n\n\n\n\n\n","category":"function"},{"location":"operations.html#Base.adjoint","page":"Basic operations on system models","title":"Base.adjoint","text":" rt = adjoint(r)\n\nCompute the adjoint rt(λ) of the rational transfer function r(λ) such that for  r(λ) = num(λ)/den(λ) we have:\n\n(1) `rt(λ) = conj(num(-λ))/conj(num(-λ))`, if `r.Ts = 0`; \n\n(2) `rt(λ) = conj(num(1/λ))/conj(num(1/λ))`, if `r.Ts = -1` or `r.Ts > 0`; \n\n(3) `rt(λ) = conj(num(λ))/conj(num(λ))`, if `r.Ts = nothing`.\n\n\n\n\n\nsysconj = adjoint(sys) \nsysconj = sys'\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its adjoint (also called conjugate transpose) system  sysconj = (Ac-λEc,Bc,Cc,Dc), such that the transfer function matrix Gconj(λ) of sysconj  is the appropriate conjugate transpose of G(λ), as follows:  for a continuous-time system with λ = s, Gconj(s) := transpose(G(-s)), while  for a discrete-time system with λ = z, Gconj(z) := transpose(G(1/z)).\n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.gbilin","page":"Basic operations on system models","title":"DescriptorSystems.gbilin","text":"gbilin(sys, g, compact = true, minimal = false, ss = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (syst, ginv)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) and  a first degree real rational transfer function g = g(δ),  the descriptor system realization syst = (At-δEt,Bt,Ct,Dt) of G(g(δ)) corresponding to the bilinear transformation  λ = g(δ) = (aδ+b)/(cδ+d). For a continuous-time transfer function g(δ), δ = s, the complex variable in  the Laplace transform, while for a discrete-time transfer function,   δ = z, the complex variable in the Z-transform. syst inherits the sampling-time of sys1.  sysi1 is the transfer function ginv(λ) = (d*λ-b)/(-c*λ+a) representing the inverse of the bilinear transformation g(δ)  (i.e., g(ginv(λ)) = 1).\n\nThe keyword argument compact can be used to specify the option to compute a compact descriptor realization without non-dynamic modes, if compact = true (the default option) or to disable the ellimination of non-dynamic modes if compact = false. \n\nThe keyword argument minimal specifies the option to compute minimal descriptor realization, if  minimal = true, or a nonminimal realization if minimal = false (the default option).\n\nThe keyword argument ss specifies the  option to compute a standard state-space (if possible) realizations of syst, if ss = true (default), or a descriptor system realization if ss = false.  \n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dss.html#Building-descriptor-system-state-space-models-1","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"","category":"section"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"DescriptorStateSpace  Descriptor state-space object.\ndss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix data from a descriptor state-space model.","category":"page"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"DescriptorStateSpace\ndss\ndssdata","category":"page"},{"location":"dss.html#DescriptorSystems.DescriptorStateSpace","page":"Building descriptor system state-space models","title":"DescriptorSystems.DescriptorStateSpace","text":"DescriptorStateSpace{T}(A::AbstractMatrix{T}, E::Union{AbstractMatrix{T},UniformScaling}, \n                        B::AbstractMatrix{T}, C::AbstractMatrix{T}, D::AbstractMatrix{T},  \n                        Ts::Real) where T <: Number\n\nConstruct a descriptor state-space model from a quintuple of matrices (A,E,B,C,D) and a sampling time Ts.\n\nIf SYS::DescriptorStateSpace{T} is a descriptor system model object  defined by the 4-tuple SYS = (A-λE,B,C,D), then:\n\nSYS.A is the nx × nx state matrix A with elements of type T. \n\nSYS.E is the nx × nx descriptor matrix E with elements of type T.  For a standard state-space system SYS.E = I, the UniformScaling of type Bool. \n\nSYS.B is the nx × nu system input matrix B with elements of type T. \n\nSYS.C is the ny × nx system output matrix C with elements of type T. \n\nSYS.D is the ny × nu system feedthrough matrix D with elements of type T. \n\nSYS.Ts is the real sampling time Ts, where Ts = 0 for a continuous-time system,     and Ts > 0 or Ts = -1 for a discrete-time system.      Ts = -1 indicates a discrete-time system with an unspecified sampling time. \n\nSYS.nx is the system state vector dimension nx. \n\nSYS.ny is the system output vector dimension ny. \n\nSYS.nu is the system input vector dimension nu. \n\n\n\n\n\n","category":"type"},{"location":"dss.html#DescriptorSystems.dss","page":"Building descriptor system state-space models","title":"DescriptorSystems.dss","text":"sys = dss(A, E, B, C, D; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCreate for Ts = 0 a descriptor system model sys = (A-λE,B,C,D) for a continuous-time state space system of the form\n\nEdx(t)/dt = Ax(t) + Bu(t) ,\ny(t)      = Cx(t) + Du(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector, system input vector and system output vector, respectively,  for the continuous time variable t. \n\nFor a nonzero positive sampling time Ts = ΔT, the descriptor system model specifies a discrete-time state space system of the form  \n\nEx(t+ΔT) = Ax(t) + Bu(t)\ny(t)     = Cx(t) + Du(t)\n\nfor the discrete values of the time variable t = 0, ΔT, 2ΔT, ....  Use Ts = -1 if the sampling time is not specified. In this case, by convention  ΔT = 1. \n\nFor a system with zero feedthrough matrix D, it is possible to set D = 0 (the scalar zero).  \n\nFor a standard state space system, E is the identity matrix. In this case, it is possible to set E = I (the boolean uniform scaling). Alternatively, use \n\nsys = dss(A, B, C, D; Ts = 0)\n\nto create a standard system.\n\nFor a system corresponding to a static gain D, use\n\nsys = dss(D; Ts = 0)\n\nIt is possible to specify a descriptor system via all or part of its matrices using the form \n\nsys = dss(A = mat1, E = mat2, B = mat3, C = mat4, D = mat5; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nwhere A, E, B, C, and D are keyword parameters set to appropriate matrix values  mat1, mat2, mat3, mat4, and mat5, respectively. If some of the system matrices are omited, then zero matrices of appropriate sizes are employed instead.  \n\nIt is assumed that the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0), and therefore, in the interest of efficiency, the regularity of A-λE is by default not tested. If check_reg = true, the regularity of A-λE is  additionally checked. In this case, the keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n sys = dss(A, E, B, F, C, G, D, H; compacted = false, \n           atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = min(atol1,atol2,atol3)>0 ? 0 : n*ϵ)\n\nConstruct an input-output equivalent descriptor system representation sys = (Ad-λdE,Bd,Cd,Dd) to a pencil based linearization  (A-λE,B-λF,C-λG,D-λH) satisfying \n\n            -1                        -1\n Cd*(λEd-Ad)  *Bd + Dd = (C-λG)*(λE-A)  *(B-λF) + D-λH .\n\nIf compacted = true, a compacted descriptor system realization is determined by exploiting possible rank defficiencies of the matrices F, G, and H. Any of the matrices F, G, and H can be set to missing. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of F, the absolute tolerance for the nonzero elements of G,  the absolute tolerance for the nonzero elements of H  and the relative tolerance  for the nonzero elements of F, G and H. The default relative tolerance is n*ϵ, where n is the size of  of A, and ϵ is the machine epsilon of the element type of A. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\nsys = dss(NUM, DEN; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational matrix R(λ) = NUM(λ) ./ DEN(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ).\n\nNUM(λ) is a polynomial matrix of the form NUM(λ) = N_1 + λ N_2 + ... + λ**k N_(k+1), for which   the coefficient matrices N_i, i = 1, ..., k+1 are stored in the 3-dimensional matrix NUM,  where NUM[:,:,i] contains the i-th coefficient matrix N_i (multiplying λ**(i-1)). \n\nDEN(λ) is a polynomial matrix of the form DEN(λ) = D_1 + λ D_2 + ... + λ**l D_(l+1), for which  the coefficient matrices D_i, i = 1, ..., l+1, are stored in the 3-dimensional matrix DEN,  where DEN[:,:,i] contain the i-th coefficient matrix D_i (multiplying λ**(i-1)). \n\nAlternatively, NUM(λ) and DEN(λ) can be specified as matrices of elements of the Polynomial type  provided by the Polynomials package. \n\nIf n is the order of A-λE, then the computed linearization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe descriptor system based realization is built using the methods described in [1] in conjunction with pencil manipulation algorithms [2] and [3] to compute reduced order realization. These algorithms  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances, respectively, for the  nonzero coefficients of NUM(λ) and DEN(λ).\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n[2] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[3] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(R; Ts=missing, contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational transfer function matrix R(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ). The resulting sys is a continuous-time system if Ts = 0 or  discrete-time system if Ts = -1 or Ts > 0.  If Ts = missing, the sampling time of sys is inherited from the sampling time TRs of the elements of R, unless TRs = nothing,  in which case Ts = 0 is used (by default).  \n\nR(λ) is a matrix with rational transfer function entries (see RationalTransferFunction ) corresponding to a multiple-input multiple-outputs system or a rational transfer function corresponding to a single-input single-output system. The numerators and denominators of the elements of R are of type  Polynomial as provided by the Polynomials package.   \n\nIf n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of R(λ).\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(P; Ts = 0, contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the polynomial matrix P(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is P(λ). The resulting sys is a continuous-time system if Ts = 0 or  discrete-time system if Ts = -1 or Ts > 0. \n\nP(λ) can be specified as a grade k polynomial matrix of the form P(λ) = P_1 + λ P_2 + ... + λ**k P_(k+1),  for which the coefficient matrices P_i, i = 1, ..., k+1, are stored in the 3-dimensional matrix P,  where P[:,:,i] contains the i-th coefficient matrix P_i (multiplying λ**(i-1)). \n\nP(λ) can also be specified as a matrix, vector or scalar of elements of the Polynomial type  provided by the Polynomials package.   \n\nIf d is the degree of P(λ) and n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and P(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of P(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of P(λ), respectively.\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(T, U, V, W; fast = true, contr = false, obs = false, minimal = false, atol = 0, rtol)\n\nConstruct an input-output equivalent descriptor system representation sys = (A-λE,B,C,D)  to a polynomial model specified by the polynomial matrices T(λ), U(λ), V(λ), and W(λ) such that \n\n  V(λ)*inv(T(λ))*U(λ)+W(λ) = C*inv(λE-A)*B+D.\n\nIf minimal = true, the resulting realization (A-λE,B,C,D) has the least possible order n of A-λE. \n\nT(λ), U(λ), V(λ), and W(λ) can be specified as polynomial matrices of the form X(λ) = X_1 + λ X_2 + ... + λ**k X_(k+1),  for X = T, U, V, and W, for which the coefficient matrices X_i, i = 1, ..., k+1, are stored in  the 3-dimensional matrices X, where X[:,:,i] contains the i-th coefficient matrix X_i (multiplying λ**(i-1)). \n\nT(λ), U(λ), V(λ), and W(λ) can also be specified as matrices, vectors or scalars of elements of the Polynomial type  provided by the Polynomials package.    In this case, no check is performed that T(λ), U(λ), V(λ)  and W(λ) have the same indeterminates.\n\nThe computed descriptor realization satisfies:\n\n(1) A-λE is regular;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no simple infinite eigenvalues if minimal = true.\n\nThe keyword arguments atol and rtol, specify, respectively, the absolute and relative tolerance for the  nonzero coefficients of the matrices T(λ), U(λ), V(λ) and W(λ). The default relative tolerance is nt*ϵ,  where nt is the size of the square matrix T(λ) and ϵ is the machine epsilon of the element type of its coefficients. \n\nThe descriptor realization is built using the methods described in [1].\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dss.html#DescriptorSystems.dssdata","page":"Building descriptor system state-space models","title":"DescriptorSystems.dssdata","text":"A, E, B, C, D  = dssdata([T,] sys)\n\nExtract the matrices A, E, B, C, D of a descriptor system model sys = (A-λE,B,C,D).  If the type T is specified, the resulting matrices are converted to this type. \n\n\n\n\n\n","category":"function"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = DescriptorSystems\nDocTestSetup = quote\n    using DescriptorSystems\nend","category":"page"},{"location":"index.html#DescriptorSystems.jl-1","page":"Home","title":"DescriptorSystems.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A descriptor system is a generalized state-space representation of the form","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Eλx(t) = Ax(t) + Bu(t),\ny(t)   = Cx(t) + Du(t),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where x(t) is the state vector, u(t) is the input vector, and y(t) is the output vector, and where λ is either the differential operator λx(t) = dx(t)/dt  for a continuous-time system or the advance operator λx(t) = x(t + ΔT) for a discrete-time system with the sampling time ΔT. In all what follows, we assume E is square and possibly singular, and the pencil A − λE is regular (i.e., det(A − λE) ̸≡ 0). If E = I, we call the above representation a  standard state-space system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The corresponding input-output representation is","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Y(λ) = G(λ)U(λ),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where, depending on the system type, λ = s, the complex variable in the Laplace transform for a continuous-time system, or λ = z, the complex variable in the Z-transform for a discrete-time system, Y(λ) and U(λ) are the Laplace- or Z-transformed output and input vectors, respectively, and G(λ) is the rational transfer function matrix (TFM) of the system, defined as","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"                -1\nG(λ) = C(λE − A)  B + D.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It is well known that the descriptor system representation is the most general description for a linear time-invariant system. Continuous-time descriptor systems arise frequently from modelling interconnected systems containing algebraic loops or constrained mechanical systems which describe contact phenomena. Discrete-time descriptor representations are frequently used to model economic processes. A main apeal of descriptor system models is that the manipulation of rational and polynomial matrices can be easily performed via their descriptor system representations, since each rational or polynomial matrix can be interpreted as the TFM of a descriptor system. For an introductory presentation of the main concepts, see [1].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The theoretical background for the analysis of descriptor systems closely relies on investigating the properties of certain linear matrix pencils, as the regular pole pencil P(λ) = A-λE, or the generally singular system matrix pencil S(λ) = [A-λE B; C D]. Therefore, the main analysis tools of descriptor systems are pencil manipulation techniques (e.g., reductions to various Kronecker-like forms), as available in the MatrixPencils package [2]. Among the main applications of pencil manipulation algorithms, we mention  the computation of minimal nullspace bases, the computation of poles and zeros, the determination of the normal rank of polynomial and rational matrices, computation of various factorizations of rational matrices, as well as the solution of linear equations with polynomial or rational matrices. Important additional computational ingredients in these applications are tools for solving matrix equations, as various Lyapunov, Sylvester and Riccati equations. These tools are provided by the MatrixEquations package [3].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The available functions in the DescriptorSystems.jl package cover both standard and descriptor systems with real or complex coefficient matrices. The current version of the package includes the following functions:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Building descriptor system state-space models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"dss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix-data from a descriptor state-space model.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Building rational transfer functions","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"RationalTransferFunction  Construction of rational transfer function objects.\nrtf  Building rational transfer functions.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Interconnecting descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Basic operations on descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"inv  Inversion of a system.\nldiv   Left division for two systems (also overloaded with \\).\nrdiv   Right division for two systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a system (also overloaded with adjoint and ').\nadjoint  Building the adjoint of a system.\ngbilin  Generalized bilinear transformation of a descriptor system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Some operations on rational transfer functions and matrices","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"simplify  Pole-zero cancellation.\nnormalize   Normalization of a rational transfer function to monic denominator.\nconfmap   Applying a conformal mapping transformation to a rational transfer function.\nrmconfmap   Applying a conformal mapping transformation to a rational transfer function matrix.\nzpk  Computation of zeros, poles and gain of a rational transfer function.\nrtfbilin  Generation of common bilinear transformations and their inverses.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simplification of descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.\ngss2ss   Conversion to SVD-like forms without non-dynamic modes.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Descriptor system analysis","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"isregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Factorization of descriptor systems","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"grcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Advanced operations on transfer function matrices","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"gsdec  Additive spectral decompositions.\ngrnull   Right nullspace basis of a transfer function matrix.\nglnull   Left nullspace basis of a transfer function matrix.\ngrsol   Solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglsol   Solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).\ngrmcover1  Right minimum dynamic cover of Type 1 based order reduction.\nglmcover1   Left minimum dynamic cover of Type 1 based order reduction.\ngrmcover2  Right minimum dynamic cover of Type 2 based order reduction.\nglmcover2  Left minimum dynamic cover of Type 2 based order reduction.","category":"page"},{"location":"index.html#Future-plans-1","page":"Home","title":"Future plans","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This is a rapidly evolving software project for which new functionality will be frequently added.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/ReleaseNotes.md)-1","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer-1","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[2]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"}]
}
