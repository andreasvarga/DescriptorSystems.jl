var documenterSearchIndex = {"docs":
[{"location":"operations.html#Basic-operations-on-descriptor-system-models-1","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"","category":"section"},{"location":"operations.html#","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"inv  Inversion of a descriptor system.\nldiv   Left division for two descriptor systems (also overloaded with \\).\nrdiv   Right division for two descriptor systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a descriptor system (also overloaded with adjoint`](@ref) and ').","category":"page"},{"location":"operations.html#","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"DescriptorSystems.inv\nldiv\nrdiv\ngdual\nctranspose","category":"page"},{"location":"operations.html#Base.inv","page":"Basic operations on descriptor system models","title":"Base.inv","text":"sysinv = inv(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a descriptor realization of its inverse system sysinv = (Ai-λEi,Bi,Ci,Di), such that the transfer function matrix Ginv(λ) of sysinv is the inverse of G(λ) (i.e., G(λ)*Ginv(λ) = I).  The realization of sysinv is determined using inversion-free formulas and the invertibility condition is checked, unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ldiv","page":"Basic operations on descriptor system models","title":"DescriptorSystems.ldiv","text":"sysldiv = ldiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\nsysldiv = sys1 \\ sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysldiv = (Ai-λEi,Bi,Ci,Di) of sysldiv = inv(sys1)*sys2, whose transfer-function matrix Gli(λ) represents the result of the left division Gli(λ) = inv(G1(λ))*G2(λ).  The realization of sysldiv is determined using inversion-free formulas and the invertibility condition for sys1 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.rdiv","page":"Basic operations on descriptor system models","title":"DescriptorSystems.rdiv","text":"sysrdiv = rdiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)  \nsysrdiv = sys1 / sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysrdiv = (Ai-λEi,Bi,Ci,Di) of sysrdiv = sys1*inv(sys2), whose transfer-function matrix Gri(λ) represents the result of the right division Gri(λ) = G1(λ)*inv(G2(λ)).  The realization of sysrdiv is determined using inversion-free formulas and the invertibility condition for sys2 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2,  and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.gdual","page":"Basic operations on descriptor system models","title":"DescriptorSystems.gdual","text":"sysdual = gdual(sys, rev = false) \nsysdual = transpose(sys, rev = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its dual system  sysdual = (Ad-λEd,Bd,Cd,Dd), where Ad = transpose(A), Ed = transpose(E), Bd = transpose(C),  Cd = transpose(B) and Dd = transpose(D),  such that the transfer function matrix Gdual(λ) of sysdual is the transpose of G(λ)  (i.e., Gdual(λ) = transpose(G(λ))). \n\nIf rev = true, the tranposition is combined with the reverse permutation of the state variables, such that sysdual = (P*Ad*P-λP*Ed*P,P*Bd,Cd*P,Dd), where P is the permutation matrix with ones down the second diagonal. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ctranspose","page":"Basic operations on descriptor system models","title":"DescriptorSystems.ctranspose","text":"sysconj = ctranspose(sys) \nsysconj = sys'\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its conjugate transpose system  sysconj = (Ac-λEc,Bc,Cc,Dc), such that the transfer function matrix Gconj(λ) of sysconj  is the appropriate conjugate transpose (also adjoint) of G(λ).  For a continuous-time system with λ = s, Gconj(s) := transpose(G(-s)), while  for a discrete-time system with λ = z, Gconj(z) := transpose(G(1/z)).\n\n\n\n\n\n","category":"function"},{"location":"connections.html#Interconnecting-descriptor-system-models-1","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"","category":"section"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append\nparallel\nseries\nhorzcat\nvertcat","category":"page"},{"location":"connections.html#DescriptorSystems.append","page":"Interconnecting descriptor system models","title":"DescriptorSystems.append","text":"sys = append(systems...)\n\nAppend the descriptor systems systems by concatenating the input and output vectors of individual systems. This corresponds to the block diagonal concatenation of  their transfer function matrices.  Appending systems with constant matrices, vectors or scalars or with UniformScalings is also supported. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.parallel","page":"Interconnecting descriptor system models","title":"DescriptorSystems.parallel","text":"sys = parallel(sys1, sys2) \nsys = sys1 + sys2\n\nConnect the descriptor systems sys1 and sys2 in parallel such that sys = sys1 + sys2.  This coupling corresponds to the addition of their transfer function matrices.  Parallel coupling of systems with constant matrices or vectors having the same row and column dimensions  or with UniformScalings is also supported.  Parallel coupling with a constant is equivalent to elementwise parallel coupling of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.series","page":"Interconnecting descriptor system models","title":"DescriptorSystems.series","text":" sys = series(sys1, sys2) \n sys = sys2*sys1\n\nConnect the descriptor systems sys1 and sys2 in series such that sys = sys2*sys1. This coupling corresponds to the multiplication of their transfer function matrices.  Series coupling of systems with constant matrices and vectors having suitable dimensions  or with UniformScalings is also supported.  Series coupling with a constant is equivalent to elementwise multiplication of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.horzcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.horzcat","text":"sys = horzcat(sys1,sys2)\nsys = [sys1 sys2]\nsys = horzcat(systems...)\n\nConcatenate horizontally two systems sys1 and sys2 or several descriptor systems systems...  by concatenating the input vectors of individual systems. This corresponds to the horizontal  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same row dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.vertcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.vertcat","text":"sys = vertcat(sys1,sys2)\nsys = [sys1; sys2]\nsys = vert(systems...)\n\nConcatenate vertically two descriptor systems sys1 and sys2 or several descriptor systems systems...  by concatenating the output vectors of individual systems. This corresponds to the vertical  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same column dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"dss.html#Building-descriptor-system-state-space-models-1","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"","category":"section"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"dss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix data from a descriptor state-space model.","category":"page"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"DescriptorStateSpace\ndss\ndssdata\n","category":"page"},{"location":"dss.html#DescriptorSystems.DescriptorStateSpace","page":"Building descriptor system state-space models","title":"DescriptorSystems.DescriptorStateSpace","text":"Descriptor state-space model definition\n\nIf SYS::DescriptorStateSpace{T} is a descriptor system model object  defined by the 4-tuple SYS = (A-λE,B,C,D), then:\n\nSYS.A is the nx × nx state matrix A with elements of type T. \n\nSYS.E is the nx × nx descriptor matrix E with elements of type T.  For a standard state-space system SYS.E = I, the UniformScaling of type Bool. \n\nSYS.B is the nx × nu system input matrix B with elements of type T. \n\nSYS.C is the ny × nx system output matrix C with elements of type T. \n\nSYS.D is the ny × nu system feedthrough matrix D with elements of type T. \n\nSYS.Ts is the real sampling time Ts, where Ts = 0 for a continuous-time system,     and Ts > 0 or Ts = -1 for a discrete-time system.      Ts = -1 indicates a discrete-time system with an unspecified sampling time. \n\nSYS.nx is the system state vector dimension nx. \n\nSYS.ny is the system output vector dimension ny. \n\nSYS.nu is the system input vector dimension nu. \n\n\n\n\n\n","category":"type"},{"location":"dss.html#DescriptorSystems.dss","page":"Building descriptor system state-space models","title":"DescriptorSystems.dss","text":"sys = dss(A, E, B, C, D; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCreate for Ts = 0 a descriptor system model sys = (A-λE,B,C,D) for a continuous-time state space system of the form\n\nEdx(t)/dt = Ax(t) + Bu(t) ,\ny(t)      = Cx(t) + Du(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector, system input vector and system output vector, respectively,  for the continuous time variable t. \n\nFor a nonzero positive sampling time Ts = ΔT, the descriptor system model specifies a discrete-time state space system of the form  \n\nEx(t+ΔT) = Ax(t) + Bu(t)\ny(t)     = Cx(t) + Du(t)\n\nfor the discrete values of the time variable t = 0, ΔT, 2ΔT, ....  Use Ts = -1 if the sampling time is not specified. In this case, by convention  ΔT = 1. \n\nFor a system with zero feedthrough matrix D, it is possible to set D = 0 (the scalar zero).  \n\nFor a standard state space system, E is the identity matrix. In this case, it is possible to set E = I (the boolean uniform scaling). Alternatively, use \n\nsys = dss(A, B, C, D; Ts = 0)\n\nto create a standard system.\n\nFor a system corresponding to a static gain D, use\n\nsys = dss(D; Ts = 0)\n\nIt is possible to specify a descriptor system via all or part of its matrices using the form \n\nsys = dss(A = mat1, E = mat2, B = mat3, C = mat4, D = mat5; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nwhere A, E, B, C, and D are keyword parameters set to appropriate matrix values  mat1, mat2, mat3, mat4, and mat5, respectively. If some of the system matrices are omited, then zero matrices of appropriate sizes are employed instead.  \n\nIt is assumed that the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0), and therefore, in the interest of efficiency, the regularity of A-λE is by default not tested. If check_reg = true, the regularity of A-λE is  additionally checked. In this case, the keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n sys = dss(A, E, B, F, C, G, D, H; compacted = false, \n           atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = min(atol1,atol2,atol3)>0 ? 0 : n*ϵ)\n\nConstruct an input-output equivalent descriptor system representation sys = (Ad-λdE,Bd,Cd,Dd) to a pencil based linearization  (A-λE,B-λF,C-λG,D-λH) satisfying \n\n            -1                        -1\n Cd*(λEd-Ad)  *Bd + Dd = (C-λG)*(λE-A)  *(B-λF) + D-λH .\n\nIf compacted = true, a compacted descriptor system realization is determined by exploiting possible rank defficiencies of the matrices F, G, and H. Any of the matrices F, G, and H can be set to missing. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of F, the absolute tolerance for the nonzero elements of G,  the absolute tolerance for the nonzero elements of H  and the relative tolerance  for the nonzero elements of F, G and H. The default relative tolerance is n*ϵ, where n is the size of  of A, and ϵ is the machine epsilon of the element type of A. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\nsys = dss(NUM, DEN; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational matrix R(λ) = NUM(λ) ./ DEN(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ).\n\nNUM(λ) is a polynomial matrix of the form NUM(λ) = N_1 + λ N_2 + ... + λ**k N_(k+1), for which   the coefficient matrices N_i, i = 1, ..., k+1 are stored in the 3-dimensional matrix NUM,  where NUM[:,:,i] contains the i-th coefficient matrix N_i (multiplying λ**(i-1)). \n\nDEN(λ) is a polynomial matrix of the form DEN(λ) = D_1 + λ D_2 + ... + λ**l D_(l+1), for which  the coefficient matrices D_i, i = 1, ..., l+1, are stored in the 3-dimensional matrix DEN,  where DEN[:,:,i] contain the i-th coefficient matrix D_i (multiplying λ**(i-1)). \n\nAlternatively, NUM(λ) and DEN(λ) can be specified as matrices of elements of the Polynomial type  provided by the Polynomials package. \n\nIf n is the order of A-λE, then the computed linearization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe descriptor system based realization is built using the methods described in [1] in conjunction with pencil manipulation algorithms [2] and [3] to compute reduced order realization. These algorithms  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances, respectively, for the  nonzero coefficients of NUM(λ) and DEN(λ).\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n[2] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[3] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(P; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the polynomial matrix P(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is P(λ).\n\nP(λ) can be specified as a grade k polynomial matrix of the form P(λ) = P_1 + λ P_2 + ... + λ**k P_(k+1),  for which the coefficient matrices P_i, i = 1, ..., k+1, are stored in the 3-dimensional matrix P,  where P[:,:,i] contains the i-th coefficient matrix P_i (multiplying λ**(i-1)). \n\nP(λ) can also be specified as a matrix, vector or scalar of elements of the Polynomial type  provided by the Polynomials package.   \n\nIf d is the degree of P(λ) and n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and P(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of P(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of P(λ), respectively.\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(T, U, V, W; fast = true, contr = false, obs = false, minimal = false, atol = 0, rtol)\n\nConstruct an input-output equivalent descriptor system representation sys = (A-λE,B,C,D)  to a polynomial model specified by the polynomial matrices T(λ), U(λ), V(λ), and W(λ) such that \n\n  V(λ)*inv(T(λ))*U(λ)+W(λ) = C*inv(λE-A)*B+D.\n\nIf minimal = true, the resulting realization (A-λE,B,C,D) has the least possible order n of A-λE. \n\nT(λ), U(λ), V(λ), and W(λ) can be specified as polynomial matrices of the form X(λ) = X_1 + λ X_2 + ... + λ**k X_(k+1),  for X = T, U, V, and W, for which the coefficient matrices X_i, i = 1, ..., k+1, are stored in  the 3-dimensional matrices X, where X[:,:,i] contains the i-th coefficient matrix X_i (multiplying λ**(i-1)). \n\nT(λ), U(λ), V(λ), and W(λ) can also be specified as matrices, vectors or scalars of elements of the Polynomial type  provided by the Polynomials package.   \n\nThe computed descriptor realization satisfies:\n\n(1) A-λE is regular;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no simple infinite eigenvalues if minimal = true.\n\nThe keyword arguments atol and rtol, specify, respectively, the absolute and relative tolerance for the  nonzero coefficients of the matrices T(λ), U(λ), V(λ) and W(λ). The default relative tolerance is nt*ϵ,  where nt is the size of the square matrix T(λ) and ϵ is the machine epsilon of the element type of its coefficients. \n\nThe descriptor realization is built using the methods described in [1].\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dss.html#DescriptorSystems.dssdata","page":"Building descriptor system state-space models","title":"DescriptorSystems.dssdata","text":"A, E, B, C, D  = dssdata([T,] sys)\n\nExtract the matrices A, E, B, C, D of a descriptor system model sys = (A-λE,B,C,D).  If the type T is specified, the resulting matrices are converted to this type. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#Descriptor-system-analysis-1","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"","category":"section"},{"location":"analysis.html#","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"isregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.","category":"page"},{"location":"analysis.html#","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"isregular\ngpole\ngpoleinfo\nisproper\nisstable\ngzero\ngzeroinfo\ngnrank\nghanorm\ngl2norm\ngh2norm\nglinfnorm\nghinfnorm","category":"page"},{"location":"analysis.html#MatrixPencils.isregular","page":"Descriptor system analysis","title":"MatrixPencils.isregular","text":"isregular(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has a regular pole pencil A-λE and false otherwise.  \n\nTo test whether the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0),   the underlying computational procedure reduces the pencil A-λE to an appropriate Kronecker-like form,  which provides information on the rank of A-λE. \n\nThe keyword arguements atol1, atol2 and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E, and the relative tolerance  for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of  A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpole","page":"Descriptor system analysis","title":"DescriptorSystems.gpole","text":"val = gpole(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE.  The values in val are the poles of the transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor E nonsingular, val contains the generalized eigenvalues of the pair (A,E).  For E singular, val contains the zeros of P(λ), which are computed  by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe regularity of A-λE is implicitly checked. If check_reg = true, an error message is issued if the pencil    A-λE is singular. If check_reg = false and the pencil A-λE is singular, then n-r poles are set to NaN, where n is the system order and r is the normal rank of A-λE. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpoleinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gpoleinfo","text":"gpoleinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE and the named tuple info containing information on  the eigenvalue structure of the pole pencil P(λ). The values in val are the poles of the  transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite eigenvalues, in conjunction with a stability domain boundary offset β to numerically assess the  finite eigenvalues  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite eigenvalues having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite eigenvalues having moduli in the interval [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfev is the number of finite eigenvalues of the pencil A-λE (also the number of finite poles of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil A-λE;\n\ninfo.nisev is the number of simple infinite eigenvalues of the pencil A-λE (also known as non-dynamic modes); \n\ninfo.nip is the number of infinite poles of the system sys;\n\ninfo.nfsev is the number of finite stable eigenvalues, i.e., the finite eigenvalues having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbev is the number of finite eigenvalues on the boundary of the            stability domain, i.e., the finite eigenvalues           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuev is the number of finite unstable eigenvalues, i.e., the finite eigenvalues having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nhev is the number of hidden eigenvalues set to NaN          (can be nonzero only if the pencil A-λE is singular);  \n\ninfo.nrank is the normal rank of the pencil A-λE;\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil A-λE              (also the dimensions of the elementary infinite blocks in the           Kronecker form of A-λE);\n\ninfo.mip is an integer vector, which contains the information on the              multiplicities of the infinite zeros of A-λE as follows:             A-λE has info.mip[i] infinite zeros of multiplicity i, and               is empty if A-λE has no infinite zeros;\n\ninfo.rki is an integer vector, which contains the right Kronecker indices             of the pencil A-λE (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices            of the pencil A-λE (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil A-λE is regular and set to   false, if the pencil A-λE is singular;\n\ninfo.proper is set to true, if the pencil A-λE is regular and all its infinite                   eigenvalues are simple (has only non-dynamic modes), or                   is set to false, if the pencil A-λE is singular or has higher order infinite eigenvalues;\n\ninfo.stable is set to true, if the pencil A-λE is regular, has only stable                   finite eigenvalues and all its infinite eigenvalues are                  simple (has only non-dynamic modes), and  is set to false otherwise.\n\nNote: The finite poles and the finite eigenvalues of the pencil P(λ) are the same,  but the multiplicities of infinite eigenvalues of P(λ) are in excess with one to the multiplicities of infinite poles.\n\nFor the reduction of the pencil P(λ) to an appropriate Kronecker-like form   orthonal similarity transformations are performed, which involve rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of P(λ), and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isproper","page":"Descriptor system analysis","title":"DescriptorSystems.isproper","text":"isproper(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = = n*ϵ, fast = true)\n\nReturn true if the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D) is proper and false otherwise.  \n\nFor a descriptor system realization sys = (A-λE,B,C,D) without uncontrollable and unobservable infinite eigenvalues, it is checked that the pencil A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple. If the original descriptor realization has uncontrollable or unobservable infinite eigenvalues, these are elliminated using orthogonal pencil reduction algorithms. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isstable","page":"Descriptor system analysis","title":"DescriptorSystems.isstable","text":"isstable(sys[, smarg]; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, offset = sqrt(ϵ))\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has only stable poles and false otherwise.  \n\nIt is checked that the pole pencil P(λ) := A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple, and additionally the real parts of all finite eigenvalues  are less than smarg-β for a continuous-time system or  have moduli less than smarg-β for a discrete-time system, where smarg is the stability margin and  β is the stability domain boundary offset.  The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system. The offset  β to be used to numerically assess the stability of eigenvalues  can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor E singular, the computation of the poles is performed by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzero","page":"Descriptor system analysis","title":"DescriptorSystems.gzero","text":"val = gzero(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing the  finite and infinite Smith zeros of the system matrix pencil  \n\n           | A-λE | B | \n   S(λ) := |------|---| .\n           |  C   | D |\n\nThe values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible.  \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzeroinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gzeroinfo","text":"gzeroinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite Smith zeros of the system matrix pencil S(λ) \n\n          | A-λE | B | \n   S(λ) = |------|---| \n          |  C   | D |\n\nand the named tuple info containing information on the Kronecker structure of the pencil S(λ).  The values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible. \n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite zeros, in conjunction with a stability domain boundary offset β to numerically assess the  finite zeros  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite zeros having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite zeros having moduli in the interva [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfz is the number of finite eigenvalues of the pencil S(λ) (also the number of finite zeros of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil S(λ);\n\ninfo.nisev is the number of  simple infinite eigenvalues of the pencil S(λ); \n\ninfo.niz is the number of infinite zeros of the system sys;\n\ninfo.nfsz is the number of finite stable zeros, i.e., the finite zeros having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbz is the number of finite zeros on the boundary of the            stability domain, i.e., the finite zeros           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuz is the number of finite unstable zeros, i.e., the finite zeros having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nrank is the normal rank of the pencil S(λ);\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil S(λ)              (also the dimensions of the elementary infinite blocks in the           Kronecker form of S(λ));\n\ninfo.miz is an integer vector, which contains the information on the              multiplicities of the infinite zeros of S(λ) as follows:             S(λ) has info.mip[i] infinite zeros of multiplicity i, and               is empty if S(λ) has no infinite zeros;\n\ninfo.rki is an integer vector, which contains the right Kronecker indices           of the pencil S(λ) (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices          of the pencil S(λ) (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil S(λ) is regular and set to   false, if the pencil S(λ) is singular;\n\ninfo.stable is set to true, if the pencil S(λ) has only stable                   finite zeros and all its infinite zeros are                  simple and  is set to false otherwise.\n\nNote: The finite zeros and the finite eigenvalues of the pencil S(λ) are the same, but the multiplicities of infinite eigenvalues     are in excess with one to the multiplicities of infinite zeros. \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gnrank","page":"Descriptor system analysis","title":"DescriptorSystems.gnrank","text":"r = gnrank(sys, fastrank = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCompute the normal rank r of the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D). \n\nThe normal rank of G(λ) is evaluated as r = k - n, where k is the normal rank of the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nand n is the order of the system sys (i.e., the size of A). \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting the singular values of S(γ) greater than max(max(atol1,atol2), rtol*σ₁),  where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghanorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghanorm","text":"ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hanorm, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the Hankel norm hanorm = small G(lambda)_H and the vector of Hankel singular values hs of the system.\n\nFor a proper system with E singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gl2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gl2norm","text":"gl2norm(sys, h2norm = false, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the L2 norm of its transfer function  matrix G(λ). The L2 norm is infinite if the pole pencil A-λE has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  The L2 norm is also infinite for a continuous-time system having a gain at infinity greater than atolinf. \n\nTo check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli in the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf h2norm = true, the H2 norm is computed.  The H2 norm is infinite if the pole pencil A-λE has unstable zeros (i.e., unstable poles), or for a continuous-time system having a gain at infinity greater than atolinf.   To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atol3 specifies the absolute tolerance for the nonzero elements of B and is only used if h2norm = false for controllability tests of unstable eigenvalues.  The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at  λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gh2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gh2norm","text":"gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the H2 norm of its transfer function  matrix G(λ). The H2 norm is infinite, if sys has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the pole pencil A-λE must have real parts less  than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol.  \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.glinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.glinfnorm","text":"glinfnorm(sys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (linfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the L∞ norm linfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The L∞ norm is infinite if the pole pencil A-λE has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.   To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli within the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nIf hinfnorm = true, the H∞ norm is computed. In this case, the stability of the zeros of A-λE is additionally checked and  the H∞ norm is infinite for an unstable system. To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghinfnorm","text":"ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hinfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the H∞ norm hinfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The H∞ norm is infinite if the pole pencil A-λE has unstable zeros (i.e., sys has unstable poles).  To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Descriptor-system-utilities-1","page":"Descriptor system utilities","title":"Descriptor system utilities","text":"","category":"section"},{"location":"dstools.html#","page":"Descriptor system utilities","title":"Descriptor system utilities","text":"order   Order (also the number of state variables) of a descriptor system.\nsize   Number of outputs and inputs of a descriptor system .\niszero   Checking whether the transfer function matrix of a descriptor system is zero.\nevalfr   Gain of the transfer function matrix of a descriptor system at a single frequency value.\ndcgain   DC gain of a descriptor system.\nopnorm   L2- and L∞-norms of a descriptor system.\nrss   Generation of randomized standard state-space systems.\nrdss   Generation of randomized descriptor state-space systems.\ngsvselect   Building a descriptor systems by selecting a set of state variables.","category":"page"},{"location":"dstools.html#","page":"Descriptor system utilities","title":"Descriptor system utilities","text":"order\nDescriptorSystems.size\nDescriptorSystems.iszero\nevalfr\ndcgain\nDescriptorSystems.opnorm\nrss\nrdss\ngsvselect","category":"page"},{"location":"dstools.html#DescriptorSystems.order","page":"Descriptor system utilities","title":"DescriptorSystems.order","text":"order(sys)\n\nReturn the order (also the number of state variables) of the descriptor system sys. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.size","page":"Descriptor system utilities","title":"Base.size","text":"size(sys) -> (p,m)\nsize(sys,1) -> p\nsize(sys,2) -> m\n\nReturn the number of outputs p and the number of inputs m of a descriptor system sys.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.iszero","page":"Descriptor system utilities","title":"Base.iszero","text":" iszero(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, fastrank = true)\n\nReturn true if the transfer function matrix of the descriptor system sys is zero.  For a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) it is checked  that the normal rank of G(λ) is zero, or equivalently (see [1]), that the normal rank of  the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nis equal to n, the order of the system sys. \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting how many singular values of S(γ) have magnitudes  greater than max(max(atol1,atol2), rtol*σ₁), where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl, are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga,  On checking null rank conditions of rational matrices, 2018.  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.evalfr","page":"Descriptor system utilities","title":"DescriptorSystems.evalfr","text":"Gval = evalfr(sys, val; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dcgain","page":"Descriptor system utilities","title":"DescriptorSystems.dcgain","text":"Gval = dcgain(sys; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the DC (or steady-state) gain. Gval is the value of the  rational matrix G(λ) for λ = val, where for a continuous-time system val = 0 and  for a discrete-time system val = 1. The computed Gval has infinite entries if val is a pole of G(λ). In this case (i.e., val*E-A is singular), the entries of Gval are evaluated separately for minimal realizations  of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation  algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#LinearAlgebra.opnorm","page":"Descriptor system utilities","title":"LinearAlgebra.opnorm","text":" opnorm(sys[, p = Inf]; kwargs...) \n opnorm(sys, 2; kwargs...) -> sysnorm\n opnorm(sys, Inf; kwargs...) -> (sysnorm, fpeak)\n opnorm(sys; kwargs...) -> (sysnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the L2 or L∞ system norm sysnorm induced by the vector p-norm, where valid values of p are 2 or Inf.  For the L∞ norm, the frequency fpeak is also returned, where G(λ) achieves its peak gain.  See gh2norm and ghinfnorm for a description of the allowed keyword arguments.  \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rss","page":"Descriptor system utilities","title":"DescriptorSystems.rss","text":"sys = rss(n, p, m; disc = false, T = Float64, stable = false, nuc = 0, nuo = 0, randt = true)\n\nGenerate a randomized n+nuc+nuo-th order standard state-space system sys = (A,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T. The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true. If stable = true, the resulting system is stable, with A having all eigenvalues with negative real parts for a continuous-time system,  or with moduli less than one for a discrete-time system.  If nuc+nuo > 0, the system sys is non-minimal, with A having nuc uncontrollable and nuo unobservable eigenvalues.  If  randt = true, a randomly generated orthogonal or unitary similarity transformation is additionally applied.     If randt = false, the system matrices A, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable eigenvalues of A:\n\nA = diag(A1, A2, A3),  B = [B1; 0; B3], C = [C1 C2 0]\n\nwith the diagonal blocks A1, A2, A3 of orders n, nuc, and nuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rdss","page":"Descriptor system utilities","title":"DescriptorSystems.rdss","text":"sys = rdss(n, p, m; id = [ ], disc = false, T = Float64, stable = false, nfuc = 0, iduc = [ ], \n           nfuo = 0, iduo = [ ], randlt = true, randrt = true)\n\nGenerate a randomized descriptor state-space system sys = (A-λE,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T.  The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true.\n\nIf the vector id is nonempty, then id[i] specifies the order of the i-th infinite elementary divisor of the resulting pencil A-λE, which thus has n finite eigenvalues and ni = sum(id) infinite eigenvalues which are controllable and observable.  If nfuc+nfuo > 0, the system sys is non-minimal, with A having nfuc uncontrollable and nfuo unobservable finite eigenvalues.  If the vector iduc is a nonempty, then iduc[i] specifies the order of the i-th infinite elementary divisor  with uncontrollable infinite eigenvalues of the resulting pencil A-λE, which thus has niuc = sum(iduc) uncontrollable infinite eigenvalues.  If the vector iduo is a nonempty, then iduo[i] specifies the order of the i-th infinite elementary divisor with  unobservable infinite eigenvalues of the resulting pencil A-λE, which thus has niuo = sum(iduo) unobservable infinite eigenvalues.  If niuc+niuo > 0, the system sys is non-minimal, with A having niuc uncontrollable and niuo unobservable infinite eigenvalues. \n\nIt follows, that the resulting pencil A-λE has  n+nfuc+nfuo finite eigenvalues and ni+niuc+niuo infinite eigenvalues.  If stable = true, the proper part of the system sys is stable, with A having all finite eigenvalues with negative real parts  for a continuous-time system, or with moduli less than one for a discrete-time system. \n\nIf  randlt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E, and B from the left.     If  randrt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E,  and C from the right.     If randlt = false and randrt = false, the system matrices A, E, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable finite and infinite eigenvalues of A-λE:\n\nA-λE = diag(A1-λE1, A2-λE2, A3-λE3, A4-λE4, A5-λE5, A6-λE6),  \nB = [B1; B2; 0; 0; B5; B6 ], \nC = [C1 C2 C3 C4 0 0]\n\nwith the diagonal blocks A1, A2, A3, A4, A5, A6 of orders n, ni, nfuc, niuc, nfuo and niuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.gsvselect","page":"Descriptor system utilities","title":"DescriptorSystems.gsvselect","text":"sysr = gsvselect(sys,ind)\n\nConstruct for the descriptor system sys = (A-λE,B,C,D) of order n the descriptor system   sysr = (A[ind,ind]-λE[ind,ind],B[ind,:],C[:,ind],D) of order nr = length(ind),  by selecting the state variables of sys with indices specified by ind.  If ind is a permutation vector of length n, then sysr has the same transfer function matrix as sys  and permuted state variables. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#Simplification-of-descriptor-system-models-1","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"","category":"section"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.","category":"page"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal\ngir\ngbalmr","category":"page"},{"location":"order_reduction.html#DescriptorSystems.gminreal","page":"Simplification of descriptor system models","title":"DescriptorSystems.gminreal","text":"sysr = gminreal(sys; fast = true, atol1 = 0, atol2, rtol, contr = true, obs = true, noseig = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if contr = true, obs = true and nseig = true.  Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced.\n\nIf nseig = false, then condition (5) on the lack of simple infinite eigenvalues is not enforced. \n\nTo enforce conditions (1)-(4), orthogonal similarity transformations are performed on  the matrices of the original realization (A-λE,B,C,D) to obtain an irreducible realization using structured pencil reduction algorithms, as the fast versions of the reduction techniques of the  full row rank pencil [B A-λE] and full column rank pencil [A-λE;C] proposed in [1].  To enforce condition (5), residualization formulas (see, e.g., [2, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gir","page":"Simplification of descriptor system models","title":"DescriptorSystems.gir","text":"sysr = gir(sys; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol, \n           finite = true, infinite = true, contr = true, obs = true, noseig = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if finite = true, infinite = true, contr = true,  obs = true and nseig = true. Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible and is computed by default. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs, finite, infinite and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced.  If contr = true and finite = true, then the finite controllability condition (1) is enforced.  If contr = true and finite = false, then the finite controllability condition (1) is not enforced.  If contr = true and infinite = true, then the infinite controllability condition (2) is enforced.  If contr = true and infinite = false, then the infinite controllability condition (2) is not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced. If obs = true and finite = true, then the finite observability condition (3) is enforced. If obs = true and finite = false, then the finite observability condition (3) is not enforced. If obs = true and infinite = true, then the infinite observability condition (4) is enforced. If obs = true and infinite = false, then the infinite observability condition (4) is not enforced.\n\nIf nseig = true, then condition (5) on the lack of simple infinite eigenvalues is also enforced. \n\nTo enforce conditions (1)-(4), the Procedure GIR in [1, page 328] is employed, which performs  orthogonal similarity transformations on the matrices of the original realization (A-λE,B,C,D)  to obtain an irreducible realization using structured pencil reduction algorithms.  To enforce condition (5), residualization formulas (see, e.g., [1, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gbalmr","page":"Simplification of descriptor system models","title":"DescriptorSystems.gbalmr","text":"gbalmr(sys, balance = false, matchdc = false, ord = missing, atolhsv = 0, rtolhsv = nϵ, \n       atolmin = atolhsv, rtolmin = rtolhsv, \n       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -> (sysr, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nIf E is singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#Factorization-of-descriptor-system-transfer-function-matrices-1","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"","category":"section"},{"location":"factorizations.html#","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"grcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.","category":"page"},{"location":"factorizations.html#","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"grcf\nglcf\ngrcfid\nglcfid\ngiofac\ngoifac","category":"page"},{"location":"factorizations.html#DescriptorSystems.grcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcf","text":"grcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper right coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg < 0,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Bn = Bm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The Procedure GRCF from [2] is implemented, which represents an extension of the recursive factorization approach of [1] to cope with   infinite eigenvalues. All infinite poles are assigned to finite real values.  If evals is missing or does not contain a sufficient   number of real values, then a part or all of infinite eigenvalues of A-λE are   assigned to the value specified by sdeg. The pairs (An,En) and (Am,Em)  result in generalized Schur form with both An and Am quasi-upper triangular   and En and Em either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcf","text":"glcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper left coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Cn = Cm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A and n is the order of the system sys.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The dual of Procedure GRCF from [2] is used, which represents an extension of the recursive factorization approach of [1] to cope with   infinite poles. All infinite eigenvalues are assigned to finite real values.  If evals is missing or does not contain a sufficient  number of real values, then a part or all of infinite eigenvalues of A-λE are  assigned to the value specified by sdeg.   The pairs (An,En) and (Am,Em)  result in generalized Schur form with  both An and Am quasi-upper triangular  and En and Em either both upper triangular or both UniformScalings.\n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.grcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcfid","text":"grcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  right coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in (generalized) Schur form.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Bni = Bmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1]  is used (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcfid","text":"glcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  left coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in Schur forms.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Cni = Cmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1] is used  to the dual system (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.giofac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.giofac","text":"giofac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full row rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Gi[:,1:r](λ)*Go(λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full row rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended QR-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple ìnfo contains (nrank, nfuz, niuz), where ìnfo.nrank = r,  the normal rank of G(λ), ìnfo.nfuz is the number of finite zeros of syso on  the boundary of Cs, and ìnfo.niuz is the number of infinite zeros of syso.  ìnfo.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and B,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the system pencil [A-λE B; C D] is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the factorization algorithm of [1] is used, while  for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307-2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.goifac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.goifac","text":"goifac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full column rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Go(λ)*Gi[1:r,:](λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full column rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended RQ-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple ìnfo contains (nrank, nfuz, niuz), where ìnfo.nrank = r,  the normal rank of G(λ), ìnfo.nfuz is the number of finite zeros of syso on  the boundary of Cs, and ìnfo.niuz is the number of infinite zeros of syso.  ìnfo.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and C,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the dual system pencil transpose([A-λE B; C D]) is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the dual system is formed and the factorization algorithm  of [1] is used, while for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307–2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = DescriptorSystems\nDocTestSetup = quote\n    using DescriptorSystems\nend","category":"page"},{"location":"index.html#DescriptorSystems.jl-1","page":"Home","title":"DescriptorSystems.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A descriptor system is a generalized state-space representation of the form","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Eλx(t) = Ax(t) + Bu(t),\ny(t)   = Cx(t) + Du(t),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where x(t) is the state vector, u(t) is the input vector, and y(t) is the output vector, and where λ is either the differential operator λx(t) = dx(t)/dt  for a continuous-time system or the advance operator λx(t) = x(t + ΔT) for a discrete-time system with the sampling time ΔT. In all what follows, we assume E is square and possibly singular, and the pencil A − λE is regular (i.e., det(A − λE) ̸≡ 0). If E = I, we call the above representation a  standard state-space system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The corresponding input-output representation is","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Y(λ) = G(λ)U(λ),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where, depending on the system type, λ = s, the complex variable in the Laplace transform for a continuous-time system, or λ = z, the complex variable in the Z-transform for a discrete-time system, Y(λ) and U(λ) are the Laplace- or Z-transformed output and input vectors, respectively, and G(λ) is the rational transfer function matrix (TFM) of the system, defined as","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"                -1\nG(λ) = C(λE − A)  B + D.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It is well known that the descriptor system representation is the most general description for a linear time-invariant system. Continuous-time descriptor systems arise frequently from modelling interconnected systems containing algebraic loops or constrained mechanical systems which describe contact phenomena. Discrete-time descriptor representations are frequently used to model economic processes. A main apeal of descriptor system models is that the manipulation of rational and polynomial matrices can be easily performed via their descriptor system representations, since each rational or polynomial matrix can be interpreted as the TFM of a descriptor system. For an introductory presentation of the main concepts, see [1].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The theoretical background for the analysis of descriptor systems closely relies on investigating the properties of certain linear matrix pencils, as the regular pole pencil P(λ) = A-λE, or the generally singular system matrix pencil S(λ) = [A-λE B; C D]. Therefore, the main analysis tools of descriptor systems are pencil manipulation techniques (e.g., reductions to various Kronecker-like forms), as available in the MatrixPencils package [2]. Among the main applications of pencil manipulation algorithms, we mention  the computation of minimal nullspace bases, the computation of poles and zeros, the determination of the normal rank of polynomial and rational matrices, computation of various factorizations of rational matrices, as well as the solution of linear equations with polynomial or rational matrices. Important additional computational ingredients in these applications are tools for solving matrix equations, as various Lyapunov, Sylvester and Riccati equations. These tools are provided by the MatrixEquations package [3].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The available functions in the DescriptorSystems.jl package cover both standard and descriptor systems with real or complex coefficient matrices. The current version of the package includes the following functions:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Building descriptor system state-space models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"dss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix-data from a descriptor state-space model.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Interconnecting descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Basic operations on descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"inv  Inversion of a descriptor system.\nldiv   Left division for two descriptor systems (also overloaded with \\).\nrdiv   Right division for two descriptor systems (also overloaded with /).\ngdual   Construction of the dual of a descriptor system (also overloaded with transpose)\nctranspose  Construction of the conjugate transpose of a descriptor system (also overloaded with ').","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simplification of descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Descriptor system analysis","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"isregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Factorization of descriptor systems","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"grcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.","category":"page"},{"location":"index.html#Future-plans-1","page":"Home","title":"Future plans","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This is a rapidly evolving software project for which new functionality will be frequently added.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/ReleaseNotes.md)-1","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer-1","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[2]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"},{"location":"makeindex.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html#","page":"Index","title":"Index","text":"Pages = [ \"dss.md\",\n          \"operations.md\",\n          \"connections.md\",\n          \"order_reduction.md\",\n          \"analysis.md\",\n          \"factorizations.md\",\n          \"dstools.md\" ]\nModule = [\"DescriptorSystems\"]\nOrder = [:type, :function]","category":"page"}]
}
