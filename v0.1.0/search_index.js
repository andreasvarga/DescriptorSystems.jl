var documenterSearchIndex = {"docs":
[{"location":"connections.html#Interconnecting-descriptor-system-models-1","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"","category":"section"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"connections.html#","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append\nparallel\nseries\nhorzcat\nvertcat","category":"page"},{"location":"connections.html#DescriptorSystems.append","page":"Interconnecting descriptor system models","title":"DescriptorSystems.append","text":"sys = append(systems...)\n\nAppend the descriptor systems systems by concatenating the input and output vectors of individual systems. This corresponds to the block diagonal concatenation of  their transfer function matrices.  Appending systems with constant matrices, vectors or scalars or with UniformScalings is also supported. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.parallel","page":"Interconnecting descriptor system models","title":"DescriptorSystems.parallel","text":"sys = parallel(sys1, sys2) \nsys = sys1 + sys2\n\nConnect the descriptor systems sys1 and sys2 in parallel such that sys = sys1 + sys2.  This coupling corresponds to the addition of their transfer function matrices.  Parallel coupling of systems with constant matrices or vectors having the same row and column dimensions  or with UniformScalings is also supported.  Parallel coupling with a constant is equivalent to elementwise parallel coupling of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.series","page":"Interconnecting descriptor system models","title":"DescriptorSystems.series","text":" sys = series(sys1, sys2) \n sys = sys2*sys1\n\nConnect the descriptor systems sys1 and sys2 in series such that sys = sys2*sys1. This coupling corresponds to the multiplication of their transfer function matrices.  Series coupling of systems with constant matrices and vectors having suitable dimensions  or with UniformScalings is also supported.  Series coupling with a constant is equivalent to elementwise multiplication of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.horzcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.horzcat","text":"sys = horzcat(sys1,sys2)\nsys = [sys1 sys2]\nsys = horzcat(systems...)\n\nConcatenate horizontally two systems sys1 and sys2 or several descriptor systems systems...  by concatenating the input vectors of individual systems. This corresponds to the horizontal  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same row dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.vertcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.vertcat","text":"sys = vertcat(sys1,sys2)\nsys = [sys1; sys2]\nsys = vert(systems...)\n\nConcatenate vertically two descriptor systems sys1 and sys2 or several descriptor systems systems...  by concatenating the output vectors of individual systems. This corresponds to the vertical  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same column dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"dss.html#Building-descriptor-system-state-space-models-1","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"","category":"section"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"dss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix data from a descriptor state-space model.","category":"page"},{"location":"dss.html#","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"DescriptorStateSpace\ndss\ndssdata\n","category":"page"},{"location":"dss.html#DescriptorSystems.DescriptorStateSpace","page":"Building descriptor system state-space models","title":"DescriptorSystems.DescriptorStateSpace","text":"Descriptor state-space model definition\n\nIf SYS::DescriptorStateSpace{T} is a descriptor system model object  defined by the 4-tuple SYS = (A-λE,B,C,D), then:\n\nSYS.A is the nx × nx state matrix A with elements of type T. \n\nSYS.E is the nx × nx descriptor matrix E with elements of type T.  For a standard state-space system SYS.E = I, the UniformScaling of type Bool. \n\nSYS.B is the nx × nu system input matrix B with elements of type T. \n\nSYS.C is the ny × nx system output matrix C with elements of type T. \n\nSYS.D is the ny × nu system feedthrough matrix D with elements of type T. \n\nSYS.Ts is the real sampling time Ts, where Ts = 0 for a continuous-time system,     and Ts > 0 or Ts = -1 for a discrete-time system.      Ts = -1 indicates a discrete-time system with an unspecified sampling time. \n\nSYS.nx is the system state vector dimension nx. \n\nSYS.ny is the system output vector dimension ny. \n\nSYS.nu is the system input vector dimension nu. \n\n\n\n\n\n","category":"type"},{"location":"dss.html#DescriptorSystems.dss","page":"Building descriptor system state-space models","title":"DescriptorSystems.dss","text":"sys = dss(A, E, B, C, D; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCreate for Ts = 0 a descriptor system model sys = (A-λE,B,C,D) for a continuous-time state space system of the form\n\nEdx(t)/dt = Ax(t) + Bu(t) ,\ny(t)      = Cx(t) + Du(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector, system input vector and system output vector, respectively,  for the continuous time variable t. \n\nFor a nonzero positive sampling time Ts = ΔT, the descriptor system model specifies a discrete-time state space system of the form  \n\nEx(t+ΔT) = Ax(t) + Bu(t)\ny(t)     = Cx(t) + Du(t)\n\nfor the discrete values of the time variable t = 0, ΔT, 2ΔT, ....  Use Ts = -1 if the sampling time is not specified. In this case, by convention  ΔT = 1. \n\nFor a system with zero feedthrough matrix D, it is possible to set D = 0 (the scalar zero).  \n\nFor a standard state space system, E is the identity matrix. In this case, it is possible to set E = I (the boolean uniform scaling). Alternatively, use \n\nsys = dss(A, B, C, D; Ts = 0)\n\nto create a standard system.\n\nFor a system corresponding to a static gain D, use\n\nsys = dss(D; Ts = 0)\n\nIt is possible to specify a descriptor system via all or part of its matrices using the form \n\nsys = dss(A = mat1, E = mat2, B = mat3, C = mat4, D = mat5; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nwhere A, E, B, C, and D are keyword parameters set to appropriate matrix values  mat1, mat2, mat3, mat4, and mat5, respectively. If some of the system matrices are omited, then zero matrices of appropriate sizes are employed instead.  \n\nIt is assumed that the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0), and therefore, in the interest of efficiency, the regularity of A-λE is by default not tested. If check_reg = true, the regularity of A-λE is  additionally checked. In this case, the keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n sys = dss(A, E, B, F, C, G, D, H; compacted = false, \n           atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = min(atol1,atol2,atol3)>0 ? 0 : n*ϵ)\n\nConstruct an input-output equivalent descriptor system representation sys = (Ad-λdE,Bd,Cd,Dd) to a pencil based linearization  (A-λE,B-λF,C-λG,D-λH) satisfying \n\n            -1                        -1\n Cd*(λEd-Ad)  *Bd + Dd = (C-λG)*(λE-A)  *(B-λF) + D-λH .\n\nIf compacted = true, a compacted descriptor system realization is determined by exploiting possible rank defficiencies of the matrices F, G, and H. Any of the matrices F, G, and H can be set to missing. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of F, the absolute tolerance for the nonzero elements of G,  the absolute tolerance for the nonzero elements of H  and the relative tolerance  for the nonzero elements of F, G and H. The default relative tolerance is n*ϵ, where n is the size of  of A, and ϵ is the machine epsilon of the element type of A. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\nsys = dss(NUM, DEN; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational matrix R(λ) = NUM(λ) ./ DEN(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ).\n\nNUM(λ) is a polynomial matrix of the form NUM(λ) = N_1 + λ N_2 + ... + λ**k N_(k+1), for which   the coefficient matrices N_i, i = 1, ..., k+1 are stored in the 3-dimensional matrix NUM,  where NUM[:,:,i] contains the i-th coefficient matrix N_i (multiplying λ**(i-1)). \n\nDEN(λ) is a polynomial matrix of the form DEN(λ) = D_1 + λ D_2 + ... + λ**l D_(l+1), for which  the coefficient matrices D_i, i = 1, ..., l+1, are stored in the 3-dimensional matrix DEN,  where DEN[:,:,i] contain the i-th coefficient matrix D_i (multiplying λ**(i-1)). \n\nAlternatively, NUM(λ) and DEN(λ) can be specified as matrices of elements of the Polynomial type  provided by the Polynomials package. \n\nIf n is the order of A-λE, then the computed linearization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe descriptor system based realization is built using the methods described in [1] in conjunction with pencil manipulation algorithms [2] and [3] to compute reduced order realization. These algorithms  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances, respectively, for the  nonzero coefficients of NUM(λ) and DEN(λ).\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n[2] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[3] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(P; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the polynomial matrix P(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is P(λ).\n\nP(λ) can be specified as a grade k polynomial matrix of the form P(λ) = P_1 + λ P_2 + ... + λ**k P_(k+1),  for which the coefficient matrices P_i, i = 1, ..., k+1, are stored in the 3-dimensional matrix P,  where P[:,:,i] contains the i-th coefficient matrix P_i (multiplying λ**(i-1)). \n\nP(λ) can also be specified as a matrix, vector or scalar of elements of the Polynomial type  provided by the Polynomials package.   \n\nIf d is the degree of P(λ) and n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and P(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of P(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of P(λ), respectively.\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(T, U, V, W; fast = true, contr = false, obs = false, minimal = false, atol = 0, rtol)\n\nConstruct an input-output equivalent descriptor system representation sys = (A-λE,B,C,D)  to a polynomial model specified by the polynomial matrices T(λ), U(λ), V(λ), and W(λ) such that \n\n  V(λ)*inv(T(λ))*U(λ)+W(λ) = C*inv(λE-A)*B+D.\n\nIf minimal = true, the resulting realization (A-λE,B,C,D) has the least possible order n of A-λE. \n\nT(λ), U(λ), V(λ), and W(λ) can be specified as polynomial matrices of the form X(λ) = X_1 + λ X_2 + ... + λ**k X_(k+1),  for X = T, U, V, and W, for which the coefficient matrices X_i, i = 1, ..., k+1, are stored in  the 3-dimensional matrices X, where X[:,:,i] contains the i-th coefficient matrix X_i (multiplying λ**(i-1)). \n\nT(λ), U(λ), V(λ), and W(λ) can also be specified as matrices, vectors or scalars of elements of the Polynomial type  provided by the Polynomials package.   \n\nThe computed descriptor realization satisfies:\n\n(1) A-λE is regular;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no simple infinite eigenvalues if minimal = true.\n\nThe keyword arguments atol and rtol, specify, respectively, the absolute and relative tolerance for the  nonzero coefficients of the matrices T(λ), U(λ), V(λ) and W(λ). The default relative tolerance is nt*ϵ,  where nt is the size of the square matrix T(λ) and ϵ is the machine epsilon of the element type of its coefficients. \n\nThe descriptor realization is built using the methods described in [1].\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dss.html#DescriptorSystems.dssdata","page":"Building descriptor system state-space models","title":"DescriptorSystems.dssdata","text":"A, E, B, C, D  = dssdata([T,] sys)\n\nExtract the matrices A, E, B, C, D of a descriptor system model sys = (A-λE,B,C,D).  If the type T is specified, the resulting matrices are converted to this type. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Various-descriptor-system-utilities-1","page":"Various descriptor system utilities","title":"Various descriptor system utilities","text":"","category":"section"},{"location":"dstools.html#","page":"Various descriptor system utilities","title":"Various descriptor system utilities","text":"order   Order (also the number of state variables) of a descriptor system.\nsize   Number of outputs and inputs of a descriptor system .\niszero   Checking whether the transfer function matrix of a descriptor system is zero.\nevalfr   Gain of the transfer function matrix of a descriptor system at a single frequency value.\ndcgain   DC gain of a descriptor system.\nrss   Generation of randomized standard state-space systems.\nrdss   Generation of randomized descriptor state-space systems.\ngsvselect   Building a descriptor systems by selecting a set of state variables.","category":"page"},{"location":"dstools.html#","page":"Various descriptor system utilities","title":"Various descriptor system utilities","text":"order\nDescriptorSystems.size\nDescriptorSystems.iszero\nevalfr\ndcgain\nrss\nrdss\ngsvselect","category":"page"},{"location":"dstools.html#DescriptorSystems.order","page":"Various descriptor system utilities","title":"DescriptorSystems.order","text":"order(sys)\n\nReturn the order (also the number of state variables) of the descriptor system sys. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.size","page":"Various descriptor system utilities","title":"Base.size","text":"size(sys) -> (p,m)\nsize(sys,1) -> p\nsize(sys,2) -> m\n\nReturn the number of outputs p and the number of inputs m of a descriptor system sys.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.iszero","page":"Various descriptor system utilities","title":"Base.iszero","text":" iszero(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, fastrank = true)\n\nReturn true if the transfer function matrix of the descriptor system sys is zero.  For a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) it is checked  that the normal rank of G(λ) is zero, or equivalently (see [1]), that the normal rank of  the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nis equal to n, the order of the system sys. \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting how many singular values of S(γ) have magnitudes  greater than max(max(atol1,atol2), rtol*σ₁), where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl, are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga,  On checking null rank conditions of rational matrices, 2018.  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.evalfr","page":"Various descriptor system utilities","title":"DescriptorSystems.evalfr","text":"Gval = evalfr(sys, val; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dcgain","page":"Various descriptor system utilities","title":"DescriptorSystems.dcgain","text":"Gval = dcgain(sys; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the DC (or steady-state) gain. Gval is the value of the  rational matrix G(λ) for λ = val, where for a continuous-time system val = 0 and  for a discrete-time system val = 1. The computed Gval has infinite entries if val is a pole of G(λ). In this case (i.e., val*E-A is singular), the entries of Gval are evaluated separately for minimal realizations  of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation  algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rss","page":"Various descriptor system utilities","title":"DescriptorSystems.rss","text":"sys = rss(n, p, m; disc = false, T = Float64, stable = false, nuc = 0, nuo = 0, randt = true)\n\nGenerate a randomized n+nuc+nuo-th order standard state-space system sys = (A,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T. The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true. If stable = true, the resulting system is stable, with A having all eigenvalues with negative real parts for a continuous-time system,  or with moduli less than one for a discrete-time system.  If nuc+nuo > 0, the system sys is non-minimal, with A having nuc uncontrollable and nuo unobservable eigenvalues.  If  randt = true, a randomly generated orthogonal or unitary similarity transformation is additionally applied.     If randt = false, the system matrices A, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable eigenvalues of A:\n\nA = diag(A1, A2, A3),  B = [B1; 0; B3], C = [C1 C2 0]\n\nwith the diagonal blocks A1, A2, A3 of orders n, nuc, and nuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rdss","page":"Various descriptor system utilities","title":"DescriptorSystems.rdss","text":"sys = rdss(n, p, m; id = [ ], disc = false, T = Float64, stable = false, nfuc = 0, iduc = [ ], \n           nfuo = 0, iduo = [ ], randlt = true, randrt = true)\n\nGenerate a randomized descriptor state-space system sys = (A-λE,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T.  The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true.\n\nIf the vector id is nonempty, then id[i] specifies the order of the i-th infinite elementary divisor of the resulting pencil A-λE, which thus has n finite eigenvalues and ni = sum(id) infinite eigenvalues which are controllable and observable.  If nfuc+nfuo > 0, the system sys is non-minimal, with A having nfuc uncontrollable and nfuo unobservable finite eigenvalues.  If the vector iduc is a nonempty, then iduc[i] specifies the order of the i-th infinite elementary divisor  with uncontrollable infinite eigenvalues of the resulting pencil A-λE, which thus has niuc = sum(iduc) uncontrollable infinite eigenvalues.  If the vector iduo is a nonempty, then iduo[i] specifies the order of the i-th infinite elementary divisor with  unobservable infinite eigenvalues of the resulting pencil A-λE, which thus has niuo = sum(iduo) unobservable infinite eigenvalues.  If niuc+niuo > 0, the system sys is non-minimal, with A having niuc uncontrollable and niuo unobservable infinite eigenvalues. \n\nIt follows, that the resulting pencil A-λE has  n+nfuc+nfuo finite eigenvalues and ni+niuc+niuo infinite eigenvalues.  If stable = true, the proper part of the system sys is stable, with A having all finite eigenvalues with negative real parts  for a continuous-time system, or with moduli less than one for a discrete-time system. \n\nIf  randlt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E, and B from the left.     If  randrt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E,  and C from the right.     If randlt = false and randrt = false, the system matrices A, E, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable finite and infinite eigenvalues of A-λE:\n\nA-λE = diag(A1-λE1, A2-λE2, A3-λE3, A4-λE4, A5-λE5, A6-λE6),  \nB = [B1; B2; 0; 0; B5; B6 ], \nC = [C1 C2 C3 C4 0 0]\n\nwith the diagonal blocks A1, A2, A3, A4, A5, A6 of orders n, ni, nfuc, niuc, nfuo and niuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.gsvselect","page":"Various descriptor system utilities","title":"DescriptorSystems.gsvselect","text":"sysr = gsvselect(sys,ind)\n\nConstruct for the descriptor system sys = (A-λE,B,C,D) of order n the descriptor system   sysr = (A[ind,ind]-λE[ind,ind],B[ind,:],C[:,ind],D) of order nr = length(ind),  by selecting the state variables of sys with indices specified by ind.  If ind is a permutation vector of length n, then sysr has the same transfer function matrix as sys  and permuted state variables. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#Simplification-of-descriptor-system-models-1","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"","category":"section"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.","category":"page"},{"location":"order_reduction.html#","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal\ngir\ngbalmr","category":"page"},{"location":"order_reduction.html#DescriptorSystems.gminreal","page":"Simplification of descriptor system models","title":"DescriptorSystems.gminreal","text":"sysr = gminreal(sys; fast = true, atol1 = 0, atol2, rtol, contr = true, obs = true, noseig = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if contr = true, obs = true and nseig = true.  Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced.\n\nIf nseig = false, then condition (5) on the lack of simple infinite eigenvalues is not enforced. \n\nTo enforce conditions (1)-(4), orthogonal similarity transformations are performed on  the matrices of the original realization (A-λE,B,C,D) to obtain an irreducible realization using structured pencil reduction algorithms, as the fast versions of the reduction techniques of the  full row rank pencil [B A-λE] and full column rank pencil [A-λE;C] proposed in [1].  To enforce condition (5), residualization formulas (see, e.g., [2, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gir","page":"Simplification of descriptor system models","title":"DescriptorSystems.gir","text":"sysr = gir(sys; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol, \n           finite = true, infinite = true, contr = true, obs = true, noseig = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if finite = true, infinite = true, contr = true,  obs = true and nseig = true. Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible and is computed by default. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs, finite, infinite and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced.  If contr = true and finite = true, then the finite controllability condition (1) is enforced.  If contr = true and finite = false, then the finite controllability condition (1) is not enforced.  If contr = true and infinite = true, then the infinite controllability condition (2) is enforced.  If contr = true and infinite = false, then the infinite controllability condition (2) is not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced. If obs = true and finite = true, then the finite observability condition (3) is enforced. If obs = true and finite = false, then the finite observability condition (3) is not enforced. If obs = true and infinite = true, then the infinite observability condition (4) is enforced. If obs = true and infinite = false, then the infinite observability condition (4) is not enforced.\n\nIf nseig = true, then condition (5) on the lack of simple infinite eigenvalues is also enforced. \n\nTo enforce conditions (1)-(4), the Procedure GIR in [1, page 328] is employed, which performs  orthogonal similarity transformations on the matrices of the original realization (A-λE,B,C,D)  to obtain an irreducible realization using structured pencil reduction algorithms.  To enforce condition (5), residualization formulas (see, e.g., [1, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gbalmr","page":"Simplification of descriptor system models","title":"DescriptorSystems.gbalmr","text":"gbalmr(sys, balance = false, matchdc = false, ord = missing, atolhsv = 0, rtolhsv = nϵ, \n       atolmin = atolhsv, rtolmin = rtolhsv, \n       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -> (sysr, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nIf E is singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n\n\n\n\n","category":"function"},{"location":"index.html#","page":"Home","title":"Home","text":"CurrentModule = DescriptorSystems\nDocTestSetup = quote\n    using DescriptorSystems\nend","category":"page"},{"location":"index.html#DescriptorSystems.jl-1","page":"Home","title":"DescriptorSystems.jl","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"(Image: DocBuild) (Image: Code on Github.)","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"A descriptor system is a generalized state-space representation of the form","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Eλx(t) = Ax(t) + Bu(t),\ny(t)   = Cx(t) + Du(t),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where x(t) is the state vector, u(t) is the input vector, and y(t) is the output vector, and where λ is either the differential operator λx(t) = dx(t)/dt  for a continuous-time system or the advance operator λx(t) = x(t + ΔT) for a discrete-time system with the sampling time ΔT. In all what follows, we assume E is square and possibly singular, and the pencil A − λE is regular (i.e., det(A − λE) ̸≡ 0). If E = I, we call the above representation a  standard state-space system.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The corresponding input-output representation is","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Y(λ) = G(λ)U(λ),","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"where, depending on the system type, λ = s, the complex variable in the Laplace transform for a continuous-time system, or λ = z, the complex variable in the Z-transform for a discrete-time system, Y(λ) and U(λ) are the Laplace- or Z-transformed output and input vectors, respectively, and G(λ) is the rational transfer function matrix (TFM) of the system, defined as","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"                -1\nG(λ) = C(λE − A)  B + D.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"It is well known that the descriptor system representation is the most general description for a linear time-invariant system. Continuous-time descriptor systems arise frequently from modelling interconnected systems containing algebraic loops or constrained mechanical systems which describe contact phenomena. Discrete-time descriptor representations are frequently used to model economic processes. A main apeal of descriptor system models is that the manipulation of rational and polynomial matrices can be easily performed via their descriptor system representations, since each rational or polynomial matrix can be interpreted as the TFM of a descriptor system. For an introductory presentation of the main concepts, see [1].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The theoretical background for the analysis of descriptor systems closely relies on investigating the properties of certain linear matrix pencils, as the regular pole pencil P(λ) = A-λE, or the generally singular system matrix pencil S(λ) = [A-λE B; C D]. Therefore, the main analysis tools of descriptor systems are pencil manipulation techniques (e.g., reductions to various Kronecker-like forms), as available in the MatrixPencils package [2]. Among the main applications of pencil manipulation algorithms, we mention  the computation of minimal nullspace bases, the computation of poles and zeros, the determination of the normal rank of polynomial and rational matrices, computation of various factorizations of rational matrices, as well as the solution of linear equations with polynomial or rational matrices. Important additional computational ingredients in these applications are tools for solving matrix equations, as various Lyapunov, Sylvester and Riccati equations. These tools are provided by the MatrixEquations package [3].","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"The available functions in the DescriptorSystems.jl package cover both standard and descriptor systems with real or complex coefficient matrices. The current version of the package includes the following functions:","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Building descriptor system state-space models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"dss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix-data from a descriptor state-space model.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Interconnecting descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Basic operations on descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"inv  Inversion of a descriptor system.\nldiv   Left division for two descriptor systems (also overloaded with \\).\nrdiv   Right division for two descriptor systems (also overloaded with /).\ngdual   Construction of the dual of a descriptor system (also overloaded with transpose)\nctranspose  Construction of the conjugate transpose of a descriptor system (also overloaded with ').","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Simplification of descriptor system models","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.","category":"page"},{"location":"index.html#Future-plans-1","page":"Home","title":"Future plans","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"This is a rapidly evolving software project for which new functionality will be frequently added.","category":"page"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/ReleaseNotes.md)-1","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer-1","page":"Home","title":"Main developer","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Andreas Varga","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"License: MIT (expat)","category":"page"},{"location":"index.html#References-1","page":"Home","title":"References","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[2]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"[3]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"page"},{"location":"makeindex.html#Index-1","page":"Index","title":"Index","text":"","category":"section"},{"location":"makeindex.html#","page":"Index","title":"Index","text":"Pages = [ \"dss.md\",\n          \"operations.md\",\n          \"connections.md\",\n          \"order_reduction.md\",\n          \"dstools.md\" ]\nModule = [\"DescriptorSystems\"]\nOrder = [:type, :function]","category":"page"},{"location":"operations.html#Basic-operations-on-descriptor-system-models-1","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"","category":"section"},{"location":"operations.html#","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"inv  Inversion of a descriptor system.\nldiv   Left division for two descriptor systems (also overloaded with \\).\nrdiv   Right division for two descriptor systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a descriptor system (also overloaded with adjoint and ').","category":"page"},{"location":"operations.html#","page":"Basic operations on descriptor system models","title":"Basic operations on descriptor system models","text":"DescriptorSystems.inv\nldiv\nrdiv\ngdual\nctranspose","category":"page"},{"location":"operations.html#Base.inv","page":"Basic operations on descriptor system models","title":"Base.inv","text":"sysinv = inv(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a descriptor realization of its inverse system sysinv = (Ai-λEi,Bi,Ci,Di), such that the transfer function matrix Ginv(λ) of sysinv is the inverse of G(λ) (i.e., G(λ)*Ginv(λ) = I).  The realization of sysinv is determined using inversion-free formulas and the invertibility condition is checked, unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ldiv","page":"Basic operations on descriptor system models","title":"DescriptorSystems.ldiv","text":"sysldiv = ldiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\nsysldiv = sys1 \\ sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysldiv = (Ai-λEi,Bi,Ci,Di) of sysldiv = inv(sys1)*sys2, whose transfer-function matrix Gli(λ) represents the result of the left division Gli(λ) = inv(G1(λ))*G2(λ).  The realization of sysldiv is determined using inversion-free formulas and the invertibility condition for sys1 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.rdiv","page":"Basic operations on descriptor system models","title":"DescriptorSystems.rdiv","text":"sysrdiv = rdiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)  \nsysrdiv = sys1 / sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysrdiv = (Ai-λEi,Bi,Ci,Di) of sysrdiv = sys1*inv(sys2), whose transfer-function matrix Gri(λ) represents the result of the right division Gri(λ) = G1(λ)*inv(G2(λ)).  The realization of sysrdiv is determined using inversion-free formulas and the invertibility condition for sys2 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2,  and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.gdual","page":"Basic operations on descriptor system models","title":"DescriptorSystems.gdual","text":"sysdual = gdual(sys, rev = false) \nsysdual = transpose(sys, rev = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its dual system  sysdual = (Ad-λEd,Bd,Cd,Dd), where Ad = transpose(A), Ed = transpose(E), Bd = transpose(C),  Cd = transpose(B) and Dd = transpose(D),  such that the transfer function matrix Gdual(λ) of sysdual is the transpose of G(λ)  (i.e., Gdual(λ) = transpose(G(λ))). \n\nIf rev = true, the tranposition is combined with the reverse permutation of the state variables, such that sysdual = (P*Ad*P-λP*Ed*P,P*Bd,Cd*P,Dd), where P is the permutation matrix with ones down the second diagonal. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ctranspose","page":"Basic operations on descriptor system models","title":"DescriptorSystems.ctranspose","text":"sysconj = ctranspose(sys) \nsysconj = sys'\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its conjugate transpose system  sysconj = (Ac-λEc,Bc,Cc,Dc), such that the transfer function matrix Gconj(λ) of sysconj  is the appropriate conjugate transpose (also adjoint) of G(λ).  For a continuous-time system with λ = s, Gconj(s) := transpose(G(-s)), while  for a discrete-time system with λ = z, Gconj(z) := transpose(G(1/z)).\n\n\n\n\n\n","category":"function"}]
}
