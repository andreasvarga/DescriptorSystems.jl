<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Advanced operations on transfer function matrices · DescriptorSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DescriptorSystems.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="rtf.html">Building rational transfer functions</a></li><li><a class="tocitem" href="operations.html">Basic operations on system models</a></li><li><a class="tocitem" href="operations_rtf.html">Some operations on rational transfer functions and matrices</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li><li class="is-active"><a class="tocitem" href="advanced_operations.html">Advanced operations on transfer function matrices</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="dstools.html">System utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="advanced_operations.html">Advanced operations on transfer function matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="advanced_operations.html">Advanced operations on transfer function matrices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/master/docs/src/advanced_operations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Advanced-operations-on-transfer-function-matrices-1"><a class="docs-heading-anchor" href="#Advanced-operations-on-transfer-function-matrices-1">Advanced operations on transfer function matrices</a><a class="docs-heading-anchor-permalink" href="#Advanced-operations-on-transfer-function-matrices-1" title="Permalink"></a></h1><ul><li><strong><a href="advanced_operations.html#DescriptorSystems.gsdec"><code>gsdec</code></a></strong>  Additive spectral decompositions.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.grnull"><code>grnull</code></a></strong>   Right nullspace basis of a transfer function matrix.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.glnull"><code>glnull</code></a></strong>   Left nullspace basis of a transfer function matrix.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.grsol"><code>grsol</code></a></strong>   Solution of the linear rational matrix equation <code>G(λ)*X(λ) = F(λ)</code>.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.glsol"><code>glsol</code></a></strong>   Solution of the linear rational matrix equation <code>X(λ)*G(λ) = F(λ)</code>.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.grmcover1"><code>grmcover1</code></a></strong>  Right minimum dynamic cover of Type 1 based order reduction.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.glmcover1"><code>glmcover1</code></a></strong>   Left minimum dynamic cover of Type 1 based order reduction.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.grmcover2"><code>grmcover2</code></a></strong>  Right minimum dynamic cover of Type 2 based order reduction.</li><li><strong><a href="advanced_operations.html#DescriptorSystems.glmcover2"><code>glmcover2</code></a></strong>  Left minimum dynamic cover of Type 2 based order reduction.</li></ul><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gsdec" href="#DescriptorSystems.gsdec"><code>DescriptorSystems.gsdec</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gsdec(sys; job = &quot;finite&quot;, smarg, fast = true,  atol = 0,  atol1 = atol, atol2 = atol, rtol = nϵ) -&gt; (sys1, sys2)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the additive spectral decomposition <code>G(λ) = G1(λ) + G2(λ)</code> such that <code>G1(λ)</code>,  the transfer function matrix of the descriptor system <code>sys1 = (A1-λE1,B1,C1,D1)</code>,  has only poles in a certain domain of interest <code>Cg</code> of the complex plane and <code>G2(λ)</code>,  the transfer function matrix of the descriptor system <code>sys2 = (A2-λE2,B2,C2,0)</code>, has only poles outside of <code>Cg</code>. </p><p>The keyword argument <code>smarg</code>, if provided, specifies the stability margin for the stable eigenvalues of <code>A-λE</code>, such that, in the continuous-time case,  the stable eigenvalues have real parts less than or equal to <code>smarg</code>, and in the discrete-time case, the stable eigenvalues have moduli less than or equal to <code>smarg</code>. If <code>smarg = missing</code>, the used default values  are: <code>smarg = -sqrt(ϵ)</code>, for a continuous-time system, and <code>smarg = 1-sqrt(ϵ)</code>,  for a discrete-time system), where <code>ϵ</code> is the machine precision of the working accuracy. </p><p>The keyword argument <code>job</code>, in conjunction with <code>smarg</code>, defines the domain of  interest <code>Cg</code>, as follows:</p><p>for <code>job = &quot;finite&quot;</code>, <code>Cg</code> is the whole complex plane without the point at infinity, and     <code>sys1</code> has only finite poles and <code>sys2</code> has only infinite poles (default);     the resulting <code>A2</code> is nonsingular and upper triangular, while the    resulting <code>E2</code> is nilpotent and upper triangular;   </p><p>for <code>job = &quot;infinite&quot;</code>, <code>Cg</code> is the point at infinity, and     <code>sys1</code> has only infinite poles and <code>sys2</code> has only finite poles and     is the strictly proper part of <code>sys</code>;     the resulting <code>A1</code> is nonsingular and upper triangular, while the    resulting <code>E1</code> is nilpotent and upper triangular;   </p><p>for <code>job = &quot;stable&quot;</code>, <code>Cg</code> is the stability domain of eigenvalues defined by <code>smarg</code>, and       <code>sys1</code> has only stable poles and <code>sys2</code> has only unstable and infinite poles;         the resulting pairs <code>(A1,E1)</code> and <code>(A2,E2)</code> are in generalized Schur form with     <code>E1</code> upper triangular and nonsingular and <code>E2</code> upper triangular;   </p><p>for <code>job = &quot;unstable&quot;</code>, <code>Cg</code> is the complement of the stability domain of the      eigenvalues defined by <code>smarg</code>, and       <code>sys1</code> has only unstable and infinite poles and <code>sys2</code> has only stable poles;         the resulting pairs <code>(A1,E1)</code> and <code>(A2,E2)</code> are in generalized Schur form with     <code>E1</code> upper triangular and <code>E2</code> upper triangular  and nonsingular.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/decompositions.jl#L1-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grnull" href="#DescriptorSystems.grnull"><code>DescriptorSystems.grnull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grnull(sys; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  
       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -&gt; (sysrnull, info)</code></pre><p>Determine for the descriptor systems <code>sys = (A-λE,B,C,D)</code> with the <code>p x m</code> transfer function matrix <code>G(λ)</code>,  the descriptor system <code>sysrnull = (Ar-λEr,Br,Cr,Dr)</code> with the transfer function matrix <code>Nr(λ)</code>  such that <code>Nr(λ)</code> is a minimal rational right nullspace basis of <code>G(λ)</code> and satisfies <code>G(λ)*Nr(λ) = 0</code>.     </p><p>For the call with</p><pre><code class="language-none">grnull(sys, p2; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  
       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -&gt; (sysrnull, info)</code></pre><p><code>sys</code> contains the compound system <code>sys = [sys1; sys2]</code>, with <code>G(λ)</code>, the transfer function matrix of <code>sys1</code>, and  <code>G2(λ)</code>, the transfer function matrix of <code>sys2</code>, and has the descriptor realization <code>sys = (A-λE,B,[C;C2],[D;D2])</code>,  where <code>sys2</code> has <code>p2</code> outputs. The resulting <code>sysrnull</code> contains the compound system  <code>[sysrnull1; sys2*sysrnull1] = (Ar-λEr,Br,[Cr;Cr2],[Dr;Dr2])</code>, where <code>sysrnull1 = (Ar-λEr,Br,Cr,Dr)</code> has the transfer function matrix <code>Nr(λ)</code>, which is a rational right nullspace basis of <code>G(λ)</code> satisfying <code>G(λ)*Nr(λ) = 0</code> and <code>sys2*sysrnull1 = (Ar-λEr,Br,Cr2,Dr2)</code> has the transfer function matrix <code>G2(λ)*Nr(λ)</code>. </p><p>The returned named tuple <code>info</code> has the components <code>info.nrank</code>, <code>info.stdim</code>, <code>info.degs</code>, <code>info.fnorm</code> and <code>info.tcond</code>.</p><p>If <code>polynomial = false</code>, the resulting <code>sysrnull</code> has a proper transfer function matrix,  while for <code>polynomial = true</code> the resulting <code>sysrnull</code> has a polynomial transfer function matrix.  The resulting basis <code>Nr(λ)</code> contains <code>m-r</code> basis vectors, where <code>r = rank G(λ)</code>. The rank <code>r</code> is returned in <code>info.nrank</code>. If <code>simple = true</code>, the resulting basis is <em>simple</em> and satisfies the condition that the sum of the  number of poles of the <code>m-r</code> basis vectors is equal to the number of poles of <code>Nr(λ)</code> (i.e., its McMillan degree) . </p><p>For a non-simple proper basis, the realization <code>(Ar-λEr,Br,Cr,Dr)</code> is controllable and the pencil <code>[Br Ar-λEr]</code> is in a controllable staircase form. The column dimensions of the full row rank diagonal blocks are returned in <code>info.stdim</code> and the corresponding right Kronecker indices are returned in <code>info.degs</code>.   For a simple basis, the regular pencil <code>Ar-λEr</code> is block diagonal, with the <code>i</code>-th block of size <code>info.deg[i]</code>  (the <code>i</code>-th right Kronecker index) for a proper basis and  <code>info.deg[i]+1</code> for a polynomial basis.  The dimensions of the diagonal blocks are returned in this case in <code>info.stdim</code>, while the increasing numbers of poles of  the basis vectors are returned in <code>info.degs</code>. For the <code>i</code>-th basis vector <code>vi(λ)</code> (i.e., the <code>i</code>-th column of <code>Nr(λ)</code>)  a minimal realization can be explicitly constructed as <code>(Ari-λEri,Bri,Cr,Dr[:,i])</code>, where <code>Ari</code>, <code>Eri</code> and <code>Bri</code> are the <code>i</code>-th diagonal blocks of <code>Ar</code>, <code>Er</code>, and <code>Br</code>, respectively, and <code>Dr[:,i]</code> is the <code>i</code>-th column of <code>Dr</code>.  The corresponding realization of <code>G2(λ)*vi(λ)</code> can be constructed as <code>(Ari-λEri,Bri,Cr2,Dr2[:,i])</code>, where <code>Dr2[:,i]</code> is the <code>i</code>-th column of <code>Dr2</code>.</p><p>For a proper basis, the poles of <code>Nr(λ)</code> can be freely assigned, by assigning the  eigenvalues of the pencil <code>Ar-λEr</code>. The vector <code>poles</code>, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If <code>inner = true</code>, the resulting basis <code>Nr(λ)</code> is <em>inner</em>, i.e., <code>Nr(λ)&#39;*Nr(λ) = I</code>, where <code>Nr(s)&#39; = transpose(Nr(-s))</code> for a  continuous-time system with <code>λ = s</code> and <code>Nr(z)&#39; = transpose(Nr(1/z))</code> for a discrete-time system with <code>λ = z</code>.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If <code>sys2</code> has poles on the boundary of the appropriate stability domain <code>Cs</code>, which are not poles of <code>sys1</code> too,  then there exists no inner <code>Nr(λ)</code> such that <code>G2(λ)*Nr(λ)</code> is stable. An offset can be specified via the keyword parameter <code>offset = β</code> to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in <code>info.tcond</code>, in conjunction with  using feedback gains, whose norms are returned in <code>info.fnorm</code>. High values of these quantities indicate a potential loss of numerical stability of computations.  </p><p><em>Note:</em> The resulting realization of <code>sysrnull</code> is minimal provided the realization of <code>sys</code> is minimal.  However, <code>sysrnull1</code> is a minimal basis only if the realization (A-lambda E,B,C,D) of <code>sys1</code> is  minimal. In this case, <code>info.degs</code> are the degrees of the vectors of a minimal polynomial basis or,  if <code>simple = true</code>, of the resulting minimal simple proper basis. </p><p><em>Method:</em> The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of <code>Nr(λ)</code> is explicitly  constructed using formulas given in [4]. </p><p><em>References:</em></p><p>[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.</p><p>[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS&#39;03 Symposium, Washington DC, USA, 2003.</p><p>[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.</p><p>[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/nullrange.jl#L364-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glnull" href="#DescriptorSystems.glnull"><code>DescriptorSystems.glnull</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glnull(sys; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  
       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -&gt; (syslnull, info)</code></pre><p>Determine for the descriptor systems <code>sys = (A-λE,B,C,D)</code> with the <code>p x m</code> transfer function matrix <code>G(λ)</code>,  the descriptor system <code>syslnull = (Al-λEl,Bl,Cl,Dl)</code> with the transfer function matrix <code>Nl(λ)</code>  such that <code>Nl(λ)</code> is a minimal rational left nullspace basis of <code>G(λ)</code> and satisfies <code>Nl(λ)*G(λ) = 0</code>.     </p><p>For the call with</p><pre><code class="language-none">glnull(sys, m2; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  
       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -&gt; (syslnull, info)</code></pre><p><code>sys</code> contains the compound system <code>sys = [sys1 sys2]</code>, with <code>G(λ)</code>, the transfer function matrix of <code>sys1</code>, and  <code>G2(λ)</code>, the transfer function matrix of <code>sys2</code>, and has the descriptor realization <code>sys = (A-λE,[B B2],C,[D D2])</code>,  where <code>sys2</code> has <code>m2</code> inputs. The resulting <code>syslnull</code> contains the compound system  <code>[syslnull1 syslnull1*sys2] = (Al-λEl,[Bl Bl2],Cr,[Dl Dl2])</code>, where <code>syslnull1 = (Al-λEl,Bl,Cl,Dl)</code> has the transfer function matrix <code>Nl(λ)</code>, which is a rational left nullspace basis of <code>G(λ)</code> satisfying <code>Nl(λ)*G(λ) = 0</code> and <code>syslnull1*sys2 = (Al-λEl,Bl2,Cl,Dl2)</code> has the transfer function matrix <code>Nl(λ)*G2(λ)</code>. </p><p>The returned named tuple <code>info</code> has the components <code>info.nrank</code>, <code>info.stdim</code>, <code>info.degs</code>, <code>info.fnorm</code> and <code>info.tcond</code>.</p><p>If <code>polynomial = false</code>, the resulting <code>syslnull</code> has a proper transfer function matrix,  while for <code>polynomial = true</code> the resulting <code>syslnull</code> has a polynomial transfer function matrix.  The resulting basis <code>Nl(λ)</code> contains <code>p-r</code> basis vectors, where <code>r = rank G(λ)</code>. The rank <code>r</code> is returned in <code>info.nrank</code>. If <code>simple = true</code>, the resulting basis is <em>simple</em> and satisfies the condition that the sum of the  number of poles of the <code>p-r</code> basis vectors is equal to the number of poles of <code>Nl(λ)</code> (i.e., its McMillan degree) . </p><p>For a non-simple proper basis, the realization <code>(Al-λEl,Bl,Cl,Dl)</code> is observable and the pencil <code>[Al-λEl; Cl]</code> is in an observable staircase form. The row dimensions of the full column rank diagonal blocks are returned in <code>info.stdim</code> and the corresponding left Kronecker indices are returned in <code>info.degs</code>.   For a simple basis, the regular pencil <code>Al-λEl</code> is block diagonal, with the <code>i</code>-th block of size <code>info.stdim[i]</code>.  The increasing numbers of poles of the basis vectors are returned in <code>info.degs</code>.  For the <code>i</code>-th basis vector <code>vi(λ)</code> (i.e., the <code>i</code>-th row of <code>Nl(λ)</code>)  a minimal realization can be explicitly constructed as <code>(Ali-λEli,Bl,Cli,Dl[i,:])</code>, where <code>Ali</code>, <code>Eli</code> and <code>Cli</code> are the <code>i</code>-th diagonal blocks of <code>Al</code>, <code>El</code>, and <code>Cl</code>, respectively, and <code>Dl[i,:]</code> is the <code>i</code>-th row of <code>Dl</code>.  The corresponding realization of <code>vi(λ)*G2(λ)</code> can be constructed as <code>(Ali-λEli,Bl2,Cl2,Dl2[i,:])</code>, where <code>Dl2[i,:]</code> is the <code>i</code>-th row of <code>Dl2</code>.</p><p>For a proper basis, the poles of <code>Nl(λ)</code> can be freely assigned, by assigning the eigenvalues of the pencil <code>Al-λEl</code>. The vector <code>poles</code>, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If <code>coinner = true</code>, the resulting basis <code>Nl(λ)</code> is <em>coinner</em>, i.e., <code>Nl(λ)*Nl(λ)&#39; = I</code>, where <code>Nl(s)&#39; = transpose(Nl(-s))</code> for a  continuous-time system with <code>λ = s</code> and <code>Nl(z)&#39; = transpose(Nl(1/z))</code> for a discrete-time system with <code>λ = z</code>.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If <code>sys2</code> has poles on the boundary of the appropriate stability domain <code>Cs</code>, which are not poles of <code>sys1</code> too,  then there exists no inner <code>Nl(λ)</code> such that <code>Nl(λ)*G2(λ)</code> is stable. An offset can be specified via the keyword parameter <code>offset = β</code> to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in <code>info.tcond</code>, in conjunction with  using feedback gains, whose norms are returned in <code>info.fnorm</code>. High values of these quantities indicate a potential loss of numerical stability of computations.  </p><p><em>Note:</em> The resulting realization of <code>syslnull</code> is minimal provided the realization of <code>sys</code> is minimal.  However, <code>syslnull1</code> is a minimal basis only if the realization (A-lambda E,B,C,D) of <code>sys1</code> is  minimal. In this case, <code>info.degs</code> are the degrees of the vectors of a minimal polynomial basis or,  if <code>simple = true</code>, of the resulting minimal simple proper basis. </p><p><em>Method:</em> The computation method for the computation of a right nullspace basis is applied to the dual of descriptor system <code>sys</code>. The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of <code>Nl(λ)</code> is explicitly  constructed using formulas given in [4]. </p><p><em>References:</em></p><p>[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.</p><p>[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS&#39;03 Symposium, Washington DC, USA, 2003.</p><p>[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.</p><p>[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/nullrange.jl#L248-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grsol" href="#DescriptorSystems.grsol"><code>DescriptorSystems.grsol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, 
      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -&gt; (sysx, info, sysgen)</code></pre><p>Determine for the descriptor systems <code>sysg = (Ag-λEg,Bg,Cg,Dg)</code> and  <code>sysf = (Af-λEf,Bf,Cf,Df)</code> with the transfer function matrices <code>G(λ)</code> and <code>F(λ)</code>,  respectively, the descriptor system <code>sysx</code> with the transfer function matrix <code>X(λ)</code>  such that <code>X(λ)</code> is the solution of the linear rational equation</p><pre><code class="language-none">G(λ)X(λ) = F(λ) .      (1)</code></pre><p>If <code>solgen = true</code>, the descriptor system <code>sysgen</code> is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form <code>GEN(λ) = [ X0(λ) XN(λ) ]</code>,  such that any <code>X(λ)</code> can be generated as</p><pre><code class="language-none">X(λ) = X0(λ) + XN(λ)*Z(λ) ,</code></pre><p>where <code>X0(λ)</code> is a particular solution satisfying <code>G(λ)X0(λ) = F(λ)</code>,  <code>XN(λ)</code> is a proper rational right nullspace basis of <code>G(λ)</code> satisfying <code>G(λ)XN(λ) = 0</code>, and  <code>Z(λ)</code> is an arbitrary rational matrix with suitable dimensions. If <code>solgen = false</code>, <code>sysgen</code> is set to <code>nothing</code>. </p><p>The call with</p><pre><code class="language-none">grsol(sysgf, mf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, 
      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -&gt; (sysx, info, sysgen)</code></pre><p>uses the compound descriptor system <code>sysgf = (A-λE,[Bg Bf],C,[Dg Df])</code>,  where <code>Bf</code> has <code>mf</code> columns, to define   the descriptor systems <code>sysg = (A-λE,Bg,C,Dg)</code> and <code>sysf = (A-λE,Bf,C,Df)</code> (i.e., <code>Ag-λEg = Af-λEf = A-λE</code> and <code>Cg = Cf = C</code>). </p><p>The generator <code>sysgen</code> has a descriptor system realization <code>sysgen = (A0-λE0,[B0 BN],C0,[D0 DN])</code>, which is usually not minimal  (uncontrollable and/or non-dynamic modes present), with  </p><pre><code class="language-none">               ( Ar-λEr    *       *    )  
   A0-λE0    = (   0     Af-λEf    *    ) , 
               (   0       0     Ai-λEi ) 

               ( B1 | Br )
   [B0 | BN] = ( B2 | 0  ),  Cg  =   ( Cr   *    *  ) ,
               ( B3 | 0  )</code></pre><p>with <code>Er</code>, <code>Ef</code> and <code>Ai</code> invertible and upper triangular, <code>Ei</code> nillpotent and upper triangular, and <code>DN</code> full row rank. The dimensions of the diagonal blocks of <code>A0-λE0</code> are  returned in the named tuple <code>info</code> as the components <code>info.nr</code>, <code>info.nf</code>, and <code>info.ninf</code>, respectively. </p><p>A minimal order descriptor system realization of the proper basis <code>XN(λ)</code> is <code>(Ar-λEr,Br,Cr,DN)</code>,  where <code>Br</code> and <code>DN</code> have <code>mr</code> columns (returned in <code>info.mr</code>), representing the dimension of the  right nullspace basis. The normal rank <code>nrank</code> of  <code>G(λ)</code> is returned in <code>info.nrank</code>. </p><p>If <code>mindeg = false</code>, the solution <code>sysx</code> is determined in the form <code>sysx = (A0+BN*F-λE0,B0,C0+DN*F,D0)</code>, where the matrix <code>F = 0</code>, unless a nonzero stabilizing gain is used such that <code>Ar+Br*F-λEr</code> has stable eigenvalues.  The vector <code>poles</code> specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of eigenvalues.  The dimension <code>nr</code> of <code>Ar</code> is the number of freely assignable poles of the solution <code>X(λ)</code> and is returned in <code>info.nr</code>.  The eigenvalues of <code>Af-λEf</code> contain the finite zeros of <code>G(λ)</code>, while the zeros  of <code>Ai-λEi</code> contain the infinite zeros of <code>G(λ)</code>.    The norm of the employed gain <code>F</code> is returned in <code>info.fnorm</code>. If <code>G(λ)</code> has infinite zeros, then the solution <code>X(λ)</code> may have infinite poles. The integer vector <code>info.rdeg</code> contains the relative column degrees of  <code>X(λ)</code> (i.e., the numbers of integrators/delays needed to make each column of <code>X(λ)</code> proper).  </p><p>If <code>mindeg = true</code>, a minimum degree solution is determined as <code>X(λ) = X0(λ) + XN(λ)*Z(λ)</code>, where <code>Z(λ)</code> is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in <code>info.tcond</code>, in conjunction with  using feedback and feedforward gains, whose norms are returned in <code>info.fnorm</code>. High values of these quantities indicate a potential loss of numerical stability of computations. </p><p>If <code>minreal = true</code>, the computed realization <code>sysx</code> is minimal.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>Ag</code>, <code>Bg</code>, <code>Cg</code>, <code>Dg</code>, <code>Af</code>, <code>Bf</code>, <code>Cf</code>, <code>Df</code>,  the absolute tolerance for the nonzero elements of <code>Eg</code> and <code>Ef</code>,   and the relative tolerance for the nonzero elements of     <code>Ag</code>, <code>Bg</code>, <code>Cg</code>, <code>Dg</code>, <code>Af</code>, <code>Bf</code>, <code>Cf</code>, <code>Df</code>, <code>Eg</code> and <code>Ef</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sysg</code> and <code>sysf</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  The method of [1] to solve rational systems is used.</p><p><em>References:</em></p><p>[1] A. Varga, &quot;Computation of least order solutions of linear rational equations&quot;,  Proc. MTNS&#39;04, Leuven, Belgium, 2004.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/linsol.jl#L105-L194">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glsol" href="#DescriptorSystems.glsol"><code>DescriptorSystems.glsol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, 
      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -&gt; (sysx, info, sysgen)</code></pre><p>Determine for the descriptor systems <code>sysg = (Ag-λEg,Bg,Cg,Dg)</code> and  <code>sysf = (Af-λEf,Bf,Cf,Df)</code> with the transfer function matrices <code>G(λ)</code> and <code>F(λ)</code>,  respectively, the descriptor system <code>sysx</code> with the transfer function matrix <code>X(λ)</code>  such that <code>X(λ)</code> is the solution of the linear rational equation</p><pre><code class="language-none">X(λ)G(λ) = F(λ) .      (1)</code></pre><p>If <code>solgen = true</code>, the descriptor system <code>sysgen</code> is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form <code>GEN(λ) = [ X0(λ); XN(λ) ]</code>,  such that any <code>X(λ)</code> can be generated as</p><pre><code class="language-none">X(λ) = X0(λ) + Z(λ)*XN(λ) ,</code></pre><p>where <code>X0(λ)</code> is a particular solution satisfying <code>X0(λ)G(λ) = F(λ)</code>,  <code>XN(λ)</code> is a proper rational left nullspace basis of <code>G(λ)</code> satisfying <code>XN(λ)G(λ) = 0</code>, and  <code>Z(λ)</code> is an arbitrary rational matrix with suitable dimensions. If <code>solgen = false</code>, <code>sysgen</code> is set to <code>nothing</code>. </p><p>The call with</p><pre><code class="language-none">grsol(sysgf, pf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, 
      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -&gt; (sysx, info, sysgen)</code></pre><p>uses the compound descriptor system <code>sysgf = (A-λE,B,[Cg; Cf],[Dg; Df])</code>,  where <code>Cf</code> has <code>pf</code> rows, to define   the descriptor systems <code>sysg = (A-λE,B,Cg,Dg)</code> and <code>sysf = (A-λE,B,Cf,Df)</code> (i.e., <code>Ag-λEg = Af-λEf = A-λE</code> and <code>Bg = Bf = B</code>). </p><p>The generator <code>sysgen</code> has a descriptor system realization <code>sysgen = (A0-λE0,B0, [C0; CN],[D0; DN])</code>, which is usually not minimal  (unobservable and/or non-dynamic modes present), with  </p><pre><code class="language-none">             ( Ai-λEi    *       *    )  
   A0-λE0  = (   0     Af-λEf    *    ) , 
             (   0       0     Al-λEl ) 

             ( *  )
       B0  = ( *  ),   ( C0 )  = ( C1 C2 C3 ) 
             ( Bl )    ( CN )    ( 0  0  Cl )</code></pre><p>with <code>El</code>, <code>Ef</code> and <code>Ai</code> invertible and upper triangular, <code>Ei</code> nillpotent and upper triangular, and <code>DN</code> full column rank. The dimensions of the diagonal blocks of <code>A0-λE0</code> are  returned in the named tuple <code>info</code> as the components <code>info.nf</code>, <code>info.ninf</code> and <code>info.nl</code>, respectively. </p><p>A minimal order descriptor system realization of the proper basis <code>XN(λ)</code> is <code>(Al-λEl,Bl,Cl,DN)</code>,  where <code>Cl</code> and <code>DN</code> have <code>pr</code> columns (returned in <code>info.pr</code>), representing the dimension of the  left nullspace basis. The normal rank <code>nrank</code> of  <code>G(λ)</code> is returned in <code>info.nrank</code>. </p><p>If <code>mindeg = false</code>, the solution <code>sysx</code> is determined in the form <code>sysx = (A0+F*CN-λE0,B0+F*DN,C0,D0)</code>, where the matrix <code>F = 0</code>, unless a nonzero stabilizing gain is used such that <code>Al+F*Bl-λEl</code> has stable eigenvalues.  The vector <code>poles</code> specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of eigenvalues.  The dimension <code>nl</code> of <code>Al</code> is the number of freely assignable poles of the solution <code>X(λ)</code> and is returned in <code>info.nl</code>.  The eigenvalues of <code>Af-λEf</code> contain the finite zeros of <code>G(λ)</code>, while the zeros  of <code>Ai-λEi</code> contain the infinite zeros of <code>G(λ)</code>.    The norm of the employed gain <code>F</code> is returned in <code>info.fnorm</code>. If <code>G(λ)</code> has infinite zeros, then the solution <code>X(λ)</code> may have infinite poles. The integer vector <code>info.rdeg</code> contains the relative row degrees of  <code>X(λ)</code> (i.e., the numbers of integrators/delays needed to make each row of <code>X(λ)</code> proper).  </p><p>If <code>mindeg = true</code>, a minimum degree solution is determined as <code>X(λ) = X0(λ) + Z(λ)XN(λ)</code>, where <code>Z(λ)</code> is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in <code>info.tcond</code>, in conjunction with  using feedback and feedforward gains, whose norms are returned in <code>info.fnorm</code>. High values of these quantities indicate a potential loss of numerical stability of computations. </p><p>If <code>minreal = true</code>, the computed realization <code>sysx</code> is minimal.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>Ag</code>, <code>Bg</code>, <code>Cg</code>, <code>Dg</code>, <code>Af</code>, <code>Bf</code>, <code>Cf</code>, <code>Df</code>,  the absolute tolerance for the nonzero elements of <code>Eg</code> and <code>Ef</code>,   and the relative tolerance for the nonzero elements of     <code>Ag</code>, <code>Bg</code>, <code>Cg</code>, <code>Dg</code>, <code>Af</code>, <code>Bf</code>, <code>Cf</code>, <code>Df</code>, <code>Eg</code> and <code>Ef</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sysg</code> and <code>sysf</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  The dual of method of [1] to solve rational systems is used.</p><p><em>References:</em></p><p>[1] A. Varga, &quot;Computation of least order solutions of linear rational equations&quot;,  Proc. MTNS&#39;04, Leuven, Belgium, 2004.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/linsol.jl#L1-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grmcover1" href="#DescriptorSystems.grmcover1"><code>DescriptorSystems.grmcover1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>Determine for the proper descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> with the transfer function matrices <code>X1(λ)</code> and <code>X2(λ)</code>,  respectively, using a right minimum dynamic cover of Type 1 based  order reduction, the descriptor systems <code>sysx</code> and <code>sysy</code> with the  transfer function matrices <code>X(λ)</code> and <code>Y(λ)</code>, respectively, such that </p><pre><code class="language-none">X(λ) = X1(λ) + X2(λ)*Y(λ) ,</code></pre><p>and <code>sysx</code> has order less than the order of <code>sys1</code>.  </p><p>The call with</p><pre><code class="language-none">grmcover1(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>uses the compound descriptor system <code>sys = (A-λE,[B1 B2],C,[D1 D2])</code>,  where <code>B1</code> and <code>D1</code> have <code>m1</code> columns, to define   the proper descriptor systems <code>sys1 = (A-λE,B1,C,D1)</code> and <code>sys2 = (A-λE,B2,C,D2)</code> (i.e., <code>A1-λE1 = A2-λE2 = A-λE</code> and <code>C1 = C2 = C</code>).   </p><p>The resulting descriptor systems <code>sysx</code> and <code>sysy</code> have controllable realizations of the form <code>sysx = (Ar-λEr,Br,Cr1,D1)</code> and <code>sysy = (Ar-λEr,Br,Cr2,0)</code>,  where the pencil <code>[Br Ar-λEr]</code> is in a (controllability) staircase form,   with <code>νr[i] x νr[i-1]</code> full row rank diagonal blocks, for <code>i = 1, ..., nr</code>,  with <code>νr[0] := m1</code>. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(stdim, tcond, fnorm)</code>,  where <code>ìnfo.stdim = νr</code> is a vector which contains the row dimensions of the blocks of the staircase form <code>[Br Ar-λEr]</code>, <code>ìnfo.tcond</code> is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and <code>ìnfo.fnorm</code> is  the Frobenius-norm of the (internally) employed state-feedback to reduce the order.  Large values of  <code>ìnfo.tcond</code> or <code>ìnfo.fnorm</code> indicate possible loss of  numerical stability of computations. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>,  the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,   and the relative tolerance for the nonzero elements of  <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>, <code>E1</code> and <code>E2</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sys1</code> and <code>sys2</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Note:</em> <code>grmcover1</code> also works for arbitrary descriptor system <code>sys1</code>,  if <code>sys2</code> is proper. For an improper system <code>sys1</code>, the order  reduction is performed only for the proper part of <code>sys1</code>, while the  polynomial part of <code>sys1</code> is included without modification in the   resulting realization of <code>sysx</code>. In this case, <code>ìnfo.stdim = νr</code> contains the information corresponding to the proper part of <code>sysx</code>. </p><p><em>Method:</em> The method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting order (McMillan degree) of <code>sysx</code> is the least achievable one provided the realization of <code>sys2</code> is maximally observable  (i.e., the pair <code>(A2+B2*F-λE2,C2+D2*F)</code> is observable for any <code>F</code>). </p><p>References:</p><p>[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC&#39;03, Maui, Hawaii, 2003.</p><p>[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/covers.jl#L170-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glmcover1" href="#DescriptorSystems.glmcover1"><code>DescriptorSystems.glmcover1</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>Determine for the proper descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> with the transfer function matrices <code>X1(λ)</code> and <code>X2(λ)</code>,  respectively, using a left minimum dynamic cover of Type 1 based  order reduction, the descriptor systems <code>sysx</code> and <code>sysy</code> with the  transfer function matrices <code>X(λ)</code> and <code>Y(λ)</code>, respectively, such that </p><pre><code class="language-none">X(λ) = X1(λ) + Y(λ)*X2(λ) ,</code></pre><p>and <code>sysx</code> has order less than the order of <code>sys1</code>.  </p><p>The call with</p><pre><code class="language-none">glmcover1(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>uses the compound descriptor system <code>sys = (A-λE,B,[C1; C2],[D1; D2])</code>,  where <code>C1</code> and <code>D1</code> have <code>p1</code> rows, to define   the proper descriptor systems <code>sys1 = (A-λE,B,C1,D1)</code> and <code>sys2 = (A-λE,B,C2,D2)</code> (i.e., <code>A1-λE1 = A2-λE2 = A-λE</code> and <code>B1 = B2 = B</code>).   </p><p>The resulting descriptor systems <code>sysx</code> and <code>sysy</code> have observable realizations of the form <code>sysx = (Ao-λEo,Bo1,Co,D1)</code> and <code>sysy = (Ao-λEo,Bo2,Co,0)</code>,  where the pencil <code>[Ao-λEo; Co]</code> is in a (observability) staircase form,   with <code>νl[i] x νl[i+1]</code> full row rank diagonal blocks, for <code>i = 1, ..., nl</code>,  with <code>νl[nl+1] := p1</code>. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(stdim, tcond, fnorm)</code>,  where <code>ìnfo.stdim = νl</code> is a vector which contains the column dimensions of the blocks of the staircase form <code>[Ao-λEo; Co]</code>, <code>ìnfo.tcond</code> is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and <code>ìnfo.fnorm</code> is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order.  Large values of  <code>ìnfo.tcond</code> or <code>ìnfo.fnorm</code> indicate possible loss of  numerical stability of computations. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>,  the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,   and the relative tolerance for the nonzero elements of  <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>, <code>E1</code> and <code>E2</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sys1</code> and <code>sys2</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Note:</em> <code>glmcover1</code> also works for arbitrary descriptor system <code>sys1</code>,  if <code>sys2</code> is proper. For an improper system <code>sys1</code>, the order  reduction is performed only for the proper part of <code>sys1</code>, while the  polynomial part of <code>sys1</code> is included without modification in the   resulting realization of <code>sysx</code>. In this case, <code>ìnfo.stdim = νl</code> contains the information corresponding to the proper part of <code>sysx</code>. </p><p><em>Method:</em> The dual of method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of <code>sysx</code> is the least achievable one provided the realization of <code>sys2</code> is maximally controllable  (i.e., the pair <code>(A2+F*C2-λE2,B2+F*D2)</code> is controllable for any <code>F</code>). </p><p><em>References:</em></p><p>[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC&#39;03, Maui, Hawaii, 2003.</p><p>[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/covers.jl#L1-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grmcover2" href="#DescriptorSystems.grmcover2"><code>DescriptorSystems.grmcover2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>Determine for the proper descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> with the transfer function matrices <code>X1(λ)</code> and <code>X2(λ)</code>,  respectively, using a right minimum dynamic cover of Type 2 based  order reduction, the descriptor systems <code>sysx</code> and <code>sysy</code> with the  transfer function matrices <code>X(λ)</code> and <code>Y(λ)</code>, respectively, such that </p><pre><code class="language-none">X(λ) = X1(λ) + X2(λ)*Y(λ) ,</code></pre><p>and <code>sysx</code> has order less than the order of <code>sys1</code>.  </p><p>The call with</p><pre><code class="language-none">grmcover2(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>uses the compound descriptor system <code>sys = (A-λE,[B1 B2],C,[D1 D2])</code>,  where <code>B1</code> and <code>D1</code> haves <code>m1</code> columns, to define   the proper descriptor systems <code>sys1 = (A-λE,B1,C,D1)</code> and <code>sys2 = (A-λE,B2,C,D2)</code> (i.e., <code>A1-λE1 = A2-λE2 =: A-λE</code> and <code>C1 = C2 =: C</code>).   </p><p>The resulting descriptor systems <code>sysx</code> and <code>sysy</code> have controllable realizations of the form <code>sysx = (Ar-λEr,Br,Cr1,Dr1)</code> and <code>sysy = (Ar-λEr,Br,Cr2,Dr2)</code>,  where the pencil <code>[Br Ar-λEr]</code> is in a (controllability) staircase form,   with <code>νr[i] x νr[i-1]</code> full row rank diagonal blocks, for <code>i = 1, ..., nr</code>,  with <code>νr[0] := m1</code>. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(stdim, tcond, fnorm, gnorm)</code>,  where <code>ìnfo.stdim = νr</code> is a vector which contains the row dimensions of the blocks of the staircase form <code>[Br Ar-λEr]</code>, <code>ìnfo.tcond</code> is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, <code>ìnfo.fnorm</code> is  the Frobenius-norm of the (internally) employed state-feedback gain to reduce the order, <code>ìnfo.gnorm</code> is  the Frobenius-norm of the (internally) employed feedforward gain to reduce the order.  Large values of  <code>ìnfo.tcond</code>, <code>ìnfo.fnorm</code>  or  <code>ìnfo.gnorm</code> indicate possible loss of  numerical stability of computations. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>,  the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,   and the relative tolerance for the nonzero elements of     <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>, <code>E1</code> and <code>E2</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sys1</code> and <code>sys2</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Note:</em> <code>grmcover2</code> also works for arbitrary descriptor system <code>sys1</code>,  if <code>sys2</code> is proper. For an improper system <code>sys1</code>, the order  reduction is performed only for the proper part of <code>sys1</code>, while the  polynomial part of <code>sys1</code> is included without modification in the   resulting realization of <code>sysx</code>. In this case, <code>ìnfo.stdim = νr</code> contains the information corresponding to the proper part of <code>sysx</code>. </p><p><em>Method:</em> The method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting McMillan degree of <code>sysx</code> is the least achievable one provided the realization of <code>sys2</code> is maximally observable  (i.e., the pair <code>(A2+B2*F-λE2,C2+D2*F)</code> is observable for any <code>F</code>). </p><p>References:</p><p>[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC&#39;03, Maui, Hawaii, 2003.</p><p>[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/covers.jl#L396-L469">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glmcover2" href="#DescriptorSystems.glmcover2"><code>DescriptorSystems.glmcover2</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>Determine for the proper descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> with the transfer function matrices <code>X1(λ)</code> and <code>X2(λ)</code>,  respectively, using a left minimum dynamic cover of Type 2 based  order reduction, the descriptor systems <code>sysx</code> and <code>sysy</code> with the  transfer function matrices <code>X(λ)</code> and <code>Y(λ)</code>, respectively, such that </p><pre><code class="language-none">X(λ) = X1(λ) + Y(λ)*X2(λ) ,</code></pre><p>and <code>sysx</code> has order less than the order of <code>sys1</code>.  </p><p>The call with</p><pre><code class="language-none">glmcover2(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -&gt; (sysx, sysy, info)</code></pre><p>uses the compound descriptor system <code>sys = (A-λE,B, [C1; C2],[D1; D2])</code>,  where <code>C1</code> and <code>D1</code> have <code>p1</code> rows and <code>E</code> is invertible, to define   the proper descriptor systems <code>sys1 = (A-λE,B,C1,D1)</code> and <code>sys2 = (A-λE,B,C2,D2)</code> (i.e., <code>A1-λE1 = A2-λE2 = A-λE</code> and <code>B1 = B2 = B</code>).   </p><p>The resulting descriptor systems <code>sysx</code> and <code>sysy</code> have observable realizations of the form <code>sysx = (Ao-λEo,Bo1,Co,Do1)</code> and <code>sysy = (Ao-λEo,Bo2,Co,Do2)</code>,  where the pencil <code>[Ao-λEo; Co]</code> is in a (observability) staircase form,   with <code>νl[i] x νl[i+1]</code> full row rank diagonal blocks, for <code>i = 1, ..., nl</code>,  with <code>νl[nl+1] := p1</code>. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(stdim, tcond, fnorm, gnorm)</code>,  where <code>ìnfo.stdim = νl</code> is a vector which contains the column dimensions of the blocks of the staircase form <code>[Ao-λEo; Co]</code>, <code>ìnfo.tcond</code> is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, <code>ìnfo.fnorm</code> is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order, and  <code>ìnfo.gnorm</code> is the Frobenius-norm of the (internally) employed output-feedforward gain.  Large values of  <code>ìnfo.tcond</code>,<code>ìnfo.fnorm</code> or <code>ìnfo.gnorm</code> indicate possible loss of  numerical stability of computations. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>,  the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,   and the relative tolerance for the nonzero elements of  <code>A1</code>, <code>B1</code>, <code>C1</code>, <code>D1</code>, <code>A2</code>, <code>B2</code>, <code>C2</code>, <code>D2</code>, <code>E1</code> and <code>E2</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximal order of the systems <code>sys1</code> and <code>sys2</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Note:</em> <code>glmcover2</code> also works for arbitrary descriptor system <code>sys1</code>,  if <code>sys2</code> is proper. For an improper system <code>sys1</code>, the order  reduction is performed only for the proper part of <code>sys1</code>, while the  polynomial part of <code>sys1</code> is included without modification in the   resulting realization of <code>sysx</code>. In this case, <code>ìnfo.stdim = νl</code> contains the information corresponding to the proper part of <code>sysx</code>. </p><p><em>Method:</em> The dual of method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of <code>sysx</code> is the least achievable one provided the realization of <code>sys2</code> is maximally controllable  (i.e., the pair <code>(A2+F*C2-λE2,B2+F*D2)</code> is controllable for any <code>F</code>). </p><p>References:</p><p>[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC&#39;03, Maui, Hawaii, 2003.</p><p>[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/87439b0238e5b1e8dc44d9301ee106e9019e6c77/src/covers.jl#L85-L156">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="factorizations.html">« Factorization of descriptor system transfer function matrices</a><a class="docs-footer-nextpage" href="dstools.html">System utilities »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 28 March 2021 15:05">Sunday 28 March 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
