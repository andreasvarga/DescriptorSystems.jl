<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Factorization of descriptor system transfer function matrices · DescriptorSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DescriptorSystems.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="operations.html">Basic operations on descriptor system models</a></li><li><a class="tocitem" href="connections.html">Interconnecting descriptor system models</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li class="is-active"><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="dstools.html">Descriptor system utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/master/docs/src/factorizations.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Factorization-of-descriptor-system-transfer-function-matrices-1"><a class="docs-heading-anchor" href="#Factorization-of-descriptor-system-transfer-function-matrices-1">Factorization of descriptor system transfer function matrices</a><a class="docs-heading-anchor-permalink" href="#Factorization-of-descriptor-system-transfer-function-matrices-1" title="Permalink"></a></h1><ul><li><strong><a href="factorizations.html#DescriptorSystems.grcf"><code>grcf</code></a></strong>  Right coprime factorization with proper and stable factors.</li><li><strong><a href="factorizations.html#DescriptorSystems.glcf"><code>glcf</code></a></strong>   Left coprime factorization with proper and stable factors.</li><li><strong><a href="factorizations.html#DescriptorSystems.grcfid"><code>grcfid</code></a></strong>   Right coprime factorization with inner denominator.</li><li><strong><a href="factorizations.html#DescriptorSystems.glcfid"><code>glcfid</code></a></strong>   Left coprime factorization with inner denominator.</li><li><strong><a href="factorizations.html#DescriptorSystems.giofac"><code>giofac</code></a></strong>   Inner-outer/QR-like factorization.</li><li><strong><a href="factorizations.html#DescriptorSystems.goifac"><code>goifac</code></a></strong>   Co-outer-co-inner/RQ-like factorization.</li></ul><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grcf" href="#DescriptorSystems.grcf"><code>DescriptorSystems.grcf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, 
     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -&gt; (sysn, sysm)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code>, the factors  <code>sysn = (An-λEn,Bn,Cn,Dn)</code> and <code>sysm = (Am-λEm,Bm,Cm,Dm)</code> of its stable and proper right coprime factorization. If <code>sys</code>, <code>sysn</code> and <code>sysm</code>   have the transfer function matrices <code>G(λ)</code>, <code>N(λ)</code> and <code>M(λ)</code>, respectively, then <code>G(λ) = N(λ)*inv(M(λ))</code>, with <code>N(λ)</code> and <code>M(λ)</code> proper and stable transfer  function matrices.  The resulting matrix pairs <code>(An,En)</code> and <code>(Am,Em)</code> are in (generalized) Schur form.  The stability domain <code>Cs</code> of poles is defined by  the keyword argument <code>smarg</code> for the stability margin, as follows:  for a continuous-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers  with real parts at most <code>smarg &lt; 0</code>,  while for a discrete-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers with  moduli at most <code>smarg &lt; 1</code> (i.e., the interior of a disc of radius <code>smarg</code> centered in the origin).  If <code>smarg</code> is missing, then the employed default values are <code>smarg = -sqrt(eps)</code>  for a continuous-time system and <code>smarg = 1-sqrt(eps)</code> for a discrete-time system. </p><p>The keyword argument <code>sdeg</code> specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both <code>sdeg</code> and <code>smarg</code> are missing,  then the employed  default values are <code>sdeg = -0.05</code> for a continuous-time system and  <code>sdeg = 0.95</code> for a discrete-time system, while if <code>smarg</code> is specified,  then <code>sdeg = smarg</code> is used. </p><p>The keyword argument <code>evals</code> is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, <code>evals</code> must be a self-conjugated complex set  to ensure that the resulting factors are also real. </p><p>If <code>mindeg = false</code>, both factors <code>sysn</code> and <code>sysm</code> have descriptor realizations with the same order and with <code>An = Am</code>, <code>En = Em</code> and <code>Bn = Bm</code>. If <code>mindeg = true</code>,  the realization of <code>sysm</code> is minimal. The number of (finite) poles of <code>sysm</code> is  equal to the number of unstable finite poles of <code>sys</code>. </p><p>If <code>mininf = false</code>, then <code>An-λEn</code> and <code>Am-λEm</code> may have simple infinite eigenvalues. If <code>mininf = true</code>,  then <code>An-λEn</code> and <code>Am-λEm</code> have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>B</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>B</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code>  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>.</p><p>The preliminary separation of finite and infinite eigenvalues of <code>A-λE</code> is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  The Procedure GRCF from [2] is implemented, which represents an extension of the recursive factorization approach of [1] to cope with   infinite eigenvalues. All infinite poles are assigned to finite real values.  If <code>evals</code> is missing or does not contain a sufficient   number of real values, then a part or all of infinite eigenvalues of <code>A-λE</code> are   assigned to the value specified by <code>sdeg</code>. The pairs <code>(An,En)</code> and <code>(Am,Em)</code>  result in <em>generalized Schur form</em> with both <code>An</code> and <code>Am</code> quasi-upper triangular   and <code>En</code> and <code>Em</code> either both upper triangular or both UniformScalings. </p><p><em>References:</em></p><p>[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.</p><p>[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L305-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glcf" href="#DescriptorSystems.glcf"><code>DescriptorSystems.glcf</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, 
     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -&gt; (sysn, sysm)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code>, the factors  <code>sysn = (An-λEn,Bn,Cn,Dn)</code> and <code>sysm = (Am-λEm,Bm,Cm,Dm)</code> of its stable and proper left coprime factorization. If <code>sys</code>, <code>sysn</code> and <code>sysm</code>   have the transfer function matrices <code>G(λ)</code>, <code>N(λ)</code> and <code>M(λ)</code>, respectively, then <code>G(λ) = inv(M(λ))*N(λ)</code>, with <code>N(λ)</code> and <code>M(λ)</code> proper and stable transfer  function matrices.  The resulting matrix pairs <code>(An,En)</code> and <code>(Am,Em)</code> are in (generalized) Schur form.  The stability domain <code>Cs</code> of poles is defined by  the keyword argument <code>smarg</code> for the stability margin, as follows:  for a continuous-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers  with real parts at most <code>smarg</code>,  while for a discrete-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers with  moduli at most <code>smarg &lt; 1</code> (i.e., the interior of a disc of radius <code>smarg</code> centered in the origin).  If <code>smarg</code> is missing, then the employed default values are <code>smarg = -sqrt(eps)</code>  for a continuous-time system and <code>smarg = 1-sqrt(eps)</code> for a discrete-time system. </p><p>The keyword argument <code>sdeg</code> specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both <code>sdeg</code> and <code>smarg</code> are missing,  then the employed  default values are <code>sdeg = -0.05</code> for a continuous-time system and  <code>sdeg = 0.95</code> for a discrete-time system, while if <code>smarg</code> is specified,  then <code>sdeg = smarg</code> is used. </p><p>The keyword argument <code>evals</code> is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, <code>evals</code> must be a self-conjugated complex set  to ensure that the resulting factors are also real. </p><p>If <code>mindeg = false</code>, both factors <code>sysn</code> and <code>sysm</code> have descriptor realizations with the same order and with <code>An = Am</code>, <code>En = Em</code> and <code>Cn = Cm</code>. If <code>mindeg = true</code>,  the realization of <code>sysm</code> is minimal. The number of (finite) poles of <code>sysm</code> is  equal to the number of unstable finite poles of <code>sys</code>. </p><p>If <code>mininf = false</code>, then <code>An-λEn</code> and <code>Am-λEm</code> may have simple infinite eigenvalues. If <code>mininf = true</code>,  then <code>An-λEn</code> and <code>Am-λEm</code> have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>C</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>C</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the machine epsilon of the element type of <code>A</code> and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>.</p><p>The preliminary separation of finite and infinite eigenvalues of <code>A-λE</code> is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  The dual of Procedure GRCF from [2] is used, which represents an extension of the recursive factorization approach of [1] to cope with   infinite poles. All infinite eigenvalues are assigned to finite real values.  If <code>evals</code> is missing or does not contain a sufficient  number of real values, then a part or all of infinite eigenvalues of <code>A-λE</code> are  assigned to the value specified by <code>sdeg</code>.   The pairs <code>(An,En)</code> and <code>(Am,Em)</code>  result in <em>generalized Schur form</em> with  both <code>An</code> and <code>Am</code> quasi-upper triangular  and <code>En</code> and <code>Em</code> either both upper triangular or both UniformScalings.</p><p><em>References:</em></p><p>[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.</p><p>[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L229-L300">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grcfid" href="#DescriptorSystems.grcfid"><code>DescriptorSystems.grcfid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -&gt; (sysni, sysmi)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code>, the factors  <code>sysni = (Ani-λEni,Bni,Cni,Dni)</code> and <code>sysmi = (Ami-λEmi,Bmi,Cmi,Dmi)</code> of its  right coprime factorization with inner denominator. If <code>sys</code>, <code>sysni</code> and <code>sysmi</code>   have the transfer function matrices <code>G(λ)</code>, <code>N(λ)</code> and <code>M(λ)</code>, respectively, then <code>G(λ) = N(λ)*inv(M(λ))</code>, with <code>N(λ)</code> and <code>M(λ)</code> proper and stable transfer  function matrices and the denominator factor <code>M(λ)</code> inner.  The resulting matrix pairs <code>(Ani,Eni)</code> and <code>(Ami,Emi)</code> are in (generalized) Schur form.  The system <code>sys</code> must not have poles on the boundary of the stability domain <code>Cs</code>. In terms of eigenvalues, this requires for a continuous-time system, that  <code>A-λE</code> must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   <code>A-λE</code> must not have controllable eigenvalues on the unit circle centered  in the origin. </p><p>To assess the presence of poles on the boundary of <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, then the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>mindeg = false</code>, both factors <code>sysni</code> and <code>sysmi</code> have descriptor realizations with the same order and with <code>Ani = Ami</code>, <code>Eni = Emi</code> and <code>Bni = Bmi</code>. If <code>mindeg = true</code>,  the realization of <code>sysmi</code> is minimal. The number of (finite) poles of <code>sysmi</code> is  equal to the number of unstable finite poles of <code>sys</code>. </p><p>If <code>mininf = false</code>, then <code>Ani-λEni</code> and <code>Ami-λEmi</code> may have simple infinite eigenvalues. If <code>mininf = true</code>,  then <code>Ani-λEni</code> and <code>Ami-λEmi</code> have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>B</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>B</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>.</p><p>The preliminary separation of finite and infinite eigenvalues of <code>A-λE</code>is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em> An extension of the recursive factorization approach of [1]  is used (see [2] for details). The pairs <code>(Ani,Eni)</code> and <code>(Ami,Emi)</code> result in <em>generalized Schur form</em> with both <code>Ani</code> and <code>Ami</code> quasi-upper triangular  and <code>Eni</code> and <code>Emi</code> either both upper triangular or both UniformScalings. </p><p><em>References:</em></p><p>[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.</p><p>[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L806-L866">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glcfid" href="#DescriptorSystems.glcfid"><code>DescriptorSystems.glcfid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -&gt; (sysni, sysmi)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code>, the factors  <code>sysni = (Ani-λEni,Bni,Cni,Dni)</code> and <code>sysmi = (Ami-λEmi,Bmi,Cmi,Dmi)</code> of its  left coprime factorization with inner denominator. If <code>sys</code>, <code>sysni</code> and <code>sysmi</code>   have the transfer function matrices <code>G(λ)</code>, <code>N(λ)</code> and <code>M(λ)</code>, respectively, then <code>G(λ) = inv(M(λ))*N(λ)</code>, with <code>N(λ)</code> and <code>M(λ)</code> proper and stable transfer  function matrices and the denominator factor <code>M(λ)</code> inner.  The resulting matrix pairs <code>(Ani,Eni)</code> and <code>(Ami,Emi)</code> are in Schur forms.  The system <code>sys</code> must not have poles on the boundary of the stability domain <code>Cs</code>. In terms of eigenvalues, this requires for a continuous-time system, that  <code>A-λE</code> must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   <code>A-λE</code> must not have controllable eigenvalues on the unit circle centered  in the origin. </p><p>To assess the presence of poles on the boundary of <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, then the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>mindeg = false</code>, both factors <code>sysni</code> and <code>sysmi</code> have descriptor realizations with the same order and with <code>Ani = Ami</code>, <code>Eni = Emi</code> and <code>Cni = Cmi</code>. If <code>mindeg = true</code>,  the realization of <code>sysmi</code> is minimal. The number of (finite) poles of <code>sysmi</code> is  equal to the number of unstable finite poles of <code>sys</code>. </p><p>If <code>mininf = false</code>, then <code>Ani-λEni</code> and <code>Ami-λEmi</code> may have simple infinite eigenvalues. If <code>mininf = true</code>,  then <code>Ani-λEni</code> and <code>Ami-λEmi</code> have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>C</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code> and <code>C</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>.</p><p>The preliminary separation of finite and infinite eigenvalues of <code>A-λE</code>is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em> An extension of the recursive factorization approach of [1] is used  to the dual system (see [2] for details). The pairs <code>(Ani,Eni)</code> and <code>(Ami,Emi)</code> result in <em>generalized Schur form</em> with both <code>Ani</code> and <code>Ami</code> quasi-upper triangular  and <code>Eni</code> and <code>Emi</code> either both upper triangular or both UniformScalings. </p><p><em>References:</em></p><p>[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.</p><p>[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L741-L801">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.giofac" href="#DescriptorSystems.giofac"><code>DescriptorSystems.giofac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">giofac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, 
       fast = true, minphase = true, offset = sqrt(ϵ)) -&gt; (sysi, syso, info)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>,  the square inner factor <code>sysi = (Ai-λEi,Bi,Ci,Di)</code> with the transfer function matrix <code>Gi(λ)</code>  and the minimum-phase quasi-outer factor or the full row rank factor <code>syso = (Ao-λEo,Bo,Co,Do)</code>  with the transfer function matrix <code>Go(λ)</code> such that</p><pre><code class="language-none"> G(λ) = Gi[:,1:r](λ)*Go(λ)    (*),</code></pre><p>where <code>r</code> is the normal rank of <code>G(λ)</code>. The resulting proper and stable inner factor satisfies  <code>Gi&#39;(λ)*Gi(λ) = I</code>. If <code>sys</code> is stable (proper), then the resulting <code>syso</code> is stable (proper).  The resulting factor <code>Go(λ)</code> has full row rank <code>r</code>. Depending on the selected factorization option, if <code>minphase = true</code>, then <code>Go(λ)</code> is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain <code>Cs</code>, or if <code>minphase = false</code>, then <code>Go(λ)</code>  contains all zeros of <code>G(λ)</code>, in which case (*) is the extended QR-like factorization of <code>G(λ)</code>. For a continuous-time system <code>sys</code>, the stability domain <code>Cs</code> is defined as the set of  complex numbers with real parts at most <code>-β</code>,  while for a discrete-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers with  moduli at most <code>1-β</code> (i.e., the interior of a disc of radius <code>1-β</code> centered in the origin).  The boundary offset  <code>β</code> to be used to assess the stability of zeros and their number  on the boundary of <code>Cs</code> can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(nrank, nfuz, niuz)</code>, where <code>ìnfo.nrank = r</code>,  the normal rank of <code>G(λ)</code>, <code>ìnfo.nfuz</code> is the number of finite zeros of <code>syso</code> on  the boundary of <code>Cs</code>, and <code>ìnfo.niuz</code> is the number of infinite zeros of <code>syso</code>.  <code>ìnfo.nfuz</code> is set to <code>missing</code> if <code>minphase = false</code>. </p><p><em>Note:</em> <code>syso</code> may generally contain a <em>free inner factor</em>, which can be eliminated by  removing the finite unobservable eigenvalues. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code> and <code>B</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>C</code> and <code>D</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>. </p><p>For the assessment of zeros, the system pencil <code>[A-λE B; C D]</code> is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  For a continuous-time system, the factorization algorithm of [1] is used, while  for a discrete-time system, the factorization algorithm of [1] is used.</p><p><em>References:</em></p><p>[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307-2325, 2000.</p><p>[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L69-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.goifac" href="#DescriptorSystems.goifac"><code>DescriptorSystems.goifac</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">goifac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, 
       fast = true, minphase = true, offset = sqrt(ϵ)) -&gt; (sysi, syso, info)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>,  the square inner factor <code>sysi = (Ai-λEi,Bi,Ci,Di)</code> with the transfer function matrix <code>Gi(λ)</code>  and the minimum-phase quasi-outer factor or the full column rank factor <code>syso = (Ao-λEo,Bo,Co,Do)</code>  with the transfer function matrix <code>Go(λ)</code> such that</p><pre><code class="language-none"> G(λ) = Go(λ)*Gi[1:r,:](λ)    (*),</code></pre><p>where <code>r</code> is the normal rank of <code>G(λ)</code>. The resulting proper and stable inner factor satisfies  <code>Gi&#39;(λ)*Gi(λ) = I</code>. If <code>sys</code> is stable (proper), then the resulting <code>syso</code> is stable (proper).  The resulting factor <code>Go(λ)</code> has full column rank <code>r</code>. Depending on the selected factorization option, if <code>minphase = true</code>, then <code>Go(λ)</code> is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain <code>Cs</code>, or if <code>minphase = false</code>, then <code>Go(λ)</code>  contains all zeros of <code>G(λ)</code>, in which case (*) is the extended RQ-like factorization of <code>G(λ)</code>. For a continuous-time system <code>sys</code>, the stability domain <code>Cs</code> is defined as the set of  complex numbers with real parts at most <code>-β</code>,  while for a discrete-time system <code>sys</code>, <code>Cs</code> is the set of complex numbers with  moduli at most <code>1-β</code> (i.e., the interior of a disc of radius <code>1-β</code> centered in the origin).  The boundary offset  <code>β</code> to be used to assess the stability of zeros and their number  on the boundary of <code>Cs</code> can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The resulting named triple <code>ìnfo</code> contains <code>(nrank, nfuz, niuz)</code>, where <code>ìnfo.nrank = r</code>,  the normal rank of <code>G(λ)</code>, <code>ìnfo.nfuz</code> is the number of finite zeros of <code>syso</code> on  the boundary of <code>Cs</code>, and <code>ìnfo.niuz</code> is the number of infinite zeros of <code>syso</code>.  <code>ìnfo.nfuz</code> is set to <code>missing</code> if <code>minphase = false</code>. </p><p><em>Note:</em> <code>syso</code> may generally contain a <em>free inner factor</em>, which can be eliminated by  removing the finite unobservable eigenvalues. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, <code>atol3</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code> and <code>C</code>,  the absolute tolerance for the nonzero elements of <code>E</code>,  the absolute tolerance for the nonzero elements of <code>B</code> and <code>D</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>, <code>atol3 = atol</code>. </p><p>For the assessment of zeros, the dual system pencil <code>transpose([A-λE B; C D])</code> is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  For a continuous-time system, the dual system is formed and the factorization algorithm  of [1] is used, while for a discrete-time system, the factorization algorithm of [1] is used.</p><p><em>References:</em></p><p>[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307–2325, 2000.</p><p>[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/b2b69e50e6a964a393f0028571550118a1562539/src/factorizations.jl#L1-L64">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="analysis.html">« Descriptor system analysis</a><a class="docs-footer-nextpage" href="dstools.html">Descriptor system utilities »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 1 February 2021 18:27">Monday 1 February 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
