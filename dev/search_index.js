var documenterSearchIndex = {"docs":
[{"location":"advanced_operations.html#Advanced-operations-on-transfer-function-matrices","page":"Advanced operations on transfer function matrices","title":"Advanced operations on transfer function matrices","text":"gsdec  Additive spectral decompositions.\ngrnull   Right nullspace basis of a transfer function matrix.\nglnull   Left nullspace basis of a transfer function matrix.\ngrange   Range space basis of a transfer function matrix. \ngcrange  Coimage space basis of a transfer function matrix. \ngrsol   Solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglsol   Solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).\ngrmcover1  Right minimum dynamic cover of Type 1 based order reduction.\nglmcover1   Left minimum dynamic cover of Type 1 based order reduction.\ngrmcover2  Right minimum dynamic cover of Type 2 based order reduction.\nglmcover2  Left minimum dynamic cover of Type 2 based order reduction.\nginv  Generalized inverses.","category":"section"},{"location":"advanced_operations.html#DescriptorSystems.gsdec","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.gsdec","text":"gsdec(sys; job = \"finite\", prescale, smarg, fast = true,  \n      atol = 0,  atol1 = atol, atol2 = atol, rtol = nϵ) -> (sys1, sys2)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the additive spectral decomposition G(λ) = G1(λ) + G2(λ) such that G1(λ),  the transfer function matrix of the descriptor system sys1 = (A1-λE1,B1,C1,D1),  has only poles in a certain domain of interest Cg of the complex plane and G2(λ),  the transfer function matrix of the descriptor system sys2 = (A2-λE2,B2,C2,0), has only poles outside of Cg. \n\nIf prescale = true, a preliminary balancing of the descriptor system pair (A,E) is performed. The default setting is prescale = MatrixPencils.balqual(sys.A,sys.E) > 10000,  where the function pbalqual from the MatrixPencils  package evaluates the scaling quality of the linear pencil A-λE. \n\nThe keyword argument smarg, if provided, specifies the stability margin for the stable eigenvalues of A-λE, such that, in the continuous-time case,  the stable eigenvalues have real parts less than or equal to smarg, and in the discrete-time case, the stable eigenvalues have moduli less than or equal to smarg. If smarg = missing, the used default values  are: smarg = -sqrt(ϵ), for a continuous-time system, and smarg = 1-sqrt(ϵ),  for a discrete-time system), where ϵ is the machine precision of the working accuracy. \n\nThe keyword argument job, in conjunction with smarg, defines the domain of  interest Cg, as follows:\n\nfor job = \"finite\", Cg is the whole complex plane without the point at infinity, and     sys1 has only finite poles and sys2 has only infinite poles (default);     the resulting A2 is nonsingular and upper triangular, while the    resulting E2 is nilpotent and upper triangular;   \n\nfor job = \"infinite\", Cg is the point at infinity, and     sys1 has only infinite poles and sys2 has only finite poles and     is the strictly proper part of sys;     the resulting A1 is nonsingular and upper triangular, while the    resulting E1 is nilpotent and upper triangular;   \n\nfor job = \"stable\", Cg is the stability domain of eigenvalues defined by smarg, and       sys1 has only stable poles and sys2 has only unstable and infinite poles;         the resulting pairs (A1,E1) and (A2,E2) are in generalized Schur form with     E1 upper triangular and nonsingular and E2 upper triangular;   \n\nfor job = \"unstable\", Cg is the complement of the stability domain of the      eigenvalues defined by smarg, and       sys1 has only unstable and infinite poles and sys2 has only stable poles;         the resulting pairs (A1,E1) and (A2,E2) are in generalized Schur form with     E1 upper triangular and E2 upper triangular  and nonsingular.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grnull","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grnull","text":"grnull(sys; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (sysrnull, info)\n\nDetermine for the descriptor systems sys = (A-λE,B,C,D) with the p x m transfer function matrix G(λ),  the descriptor system sysrnull = (Ar-λEr,Br,Cr,Dr) with the transfer function matrix Nr(λ)  such that Nr(λ) is a minimal rational right nullspace basis of G(λ) and satisfies G(λ)*Nr(λ) = 0.     \n\nFor the call with\n\ngrnull(sys, p2; polynomial = false, simple = false, inner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (sysrnull, info)\n\nsys contains the compound system sys = [sys1; sys2], with G(λ), the transfer function matrix of sys1, and  G2(λ), the transfer function matrix of sys2, and has the descriptor realization sys = (A-λE,B,[C;C2],[D;D2]),  where sys2 has p2 outputs. The resulting sysrnull contains the compound system  [sysrnull1; sys2*sysrnull1] = (Ar-λEr,Br,[Cr;Cr2],[Dr;Dr2]), where sysrnull1 = (Ar-λEr,Br,Cr,Dr) has the transfer function matrix Nr(λ), which is a rational right nullspace basis of G(λ) satisfying G(λ)*Nr(λ) = 0 and sys2*sysrnull1 = (Ar-λEr,Br,Cr2,Dr2) has the transfer function matrix G2(λ)*Nr(λ). \n\nThe returned named tuple info has the components info.nrank, info.stdim, info.degs, info.fnorm and info.tcond.\n\nIf polynomial = false, the resulting sysrnull has a proper transfer function matrix,  while for polynomial = true the resulting sysrnull has a polynomial transfer function matrix.  The resulting basis Nr(λ) contains m-r basis vectors, where r = rank G(λ). The rank r is returned in info.nrank. If simple = true, the resulting basis is simple and satisfies the condition that the sum of the  number of poles of the m-r basis vectors is equal to the number of poles of Nr(λ) (i.e., its McMillan degree) . \n\nFor a non-simple proper basis, the realization (Ar-λEr,Br,Cr,Dr) is controllable and the pencil [Br Ar-λEr] is in a controllable staircase form. The column dimensions of the full row rank diagonal blocks are returned in info.stdim and the corresponding right Kronecker indices are returned in info.degs.   For a simple basis, the regular pencil Ar-λEr is block diagonal, with the i-th block of size info.deg[i]  (the i-th right Kronecker index) for a proper basis and  info.deg[i]+1 for a polynomial basis.  The dimensions of the diagonal blocks are returned in this case in info.stdim, while the increasing numbers of poles of  the basis vectors are returned in info.degs. For the i-th basis vector vi(λ) (i.e., the i-th column of Nr(λ))  a minimal realization can be explicitly constructed as (Ari-λEri,Bri,Cr,Dr[:,i]), where Ari, Eri and Bri are the i-th diagonal blocks of Ar, Er, and Br, respectively, and Dr[:,i] is the i-th column of Dr.  The corresponding realization of G2(λ)*vi(λ) can be constructed as (Ari-λEri,Bri,Cr2,Dr2[:,i]), where Dr2[:,i] is the i-th column of Dr2.\n\nFor a proper basis, the poles of Nr(λ) can be freely assigned, by assigning the  eigenvalues of the pencil Ar-λEr. The vector poles, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree sdeg of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If inner = true, the resulting basis Nr(λ) is inner, i.e., Nr(λ)'*Nr(λ) = I, where Nr(s)' = transpose(Nr(-s)) for a  continuous-time system with λ = s and Nr(z)' = transpose(Nr(1/z)) for a discrete-time system with λ = z.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If sys2 has poles on the boundary of the appropriate stability domain Cs, which are not poles of sys1 too,  then there exists no inner Nr(λ) such that G2(λ)*Nr(λ) is stable. An offset can be specified via the keyword parameter offset = β to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations.  \n\nNote: The resulting realization of sysrnull is minimal provided the realization of sys is minimal.  However, sysrnull1 is a minimal basis only if the realization (A-lambda E,B,C,D) of sys1 is  minimal. In this case, info.degs are the degrees of the vectors of a minimal polynomial basis or,  if simple = true, of the resulting minimal simple proper basis. \n\nMethod: The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of Nr(λ) is explicitly  constructed using formulas given in [4]. \n\nReferences:\n\n[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.\n\n[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glnull","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glnull","text":"glnull(sys; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (syslnull, info)\n\nDetermine for the descriptor systems sys = (A-λE,B,C,D) with the p x m transfer function matrix G(λ),  the descriptor system syslnull = (Al-λEl,Bl,Cl,Dl) with the transfer function matrix Nl(λ)  such that Nl(λ) is a minimal rational left nullspace basis of G(λ) and satisfies Nl(λ)*G(λ) = 0.     \n\nFor the call with\n\nglnull(sys, m2; polynomial = false, simple = false, coinner = false, fast = true, poles = missing, sdeg = missing,  \n       atol = 0, atol1 = atol, atol2 = atol, rtol, offset = sqrt(ϵ) ) -> (syslnull, info)\n\nsys contains the compound system sys = [sys1 sys2], with G(λ), the transfer function matrix of sys1, and  G2(λ), the transfer function matrix of sys2, and has the descriptor realization sys = (A-λE,[B B2],C,[D D2]),  where sys2 has m2 inputs. The resulting syslnull contains the compound system  [syslnull1 syslnull1*sys2] = (Al-λEl,[Bl Bl2],Cr,[Dl Dl2]), where syslnull1 = (Al-λEl,Bl,Cl,Dl) has the transfer function matrix Nl(λ), which is a rational left nullspace basis of G(λ) satisfying Nl(λ)*G(λ) = 0 and syslnull1*sys2 = (Al-λEl,Bl2,Cl,Dl2) has the transfer function matrix Nl(λ)*G2(λ). \n\nThe returned named tuple info has the components info.nrank, info.stdim, info.degs, info.fnorm and info.tcond.\n\nIf polynomial = false, the resulting syslnull has a proper transfer function matrix,  while for polynomial = true the resulting syslnull has a polynomial transfer function matrix.  The resulting basis Nl(λ) contains p-r basis vectors, where r = rank G(λ). The rank r is returned in info.nrank. If simple = true, the resulting basis is simple and satisfies the condition that the sum of the  number of poles of the p-r basis vectors is equal to the number of poles of Nl(λ) (i.e., its McMillan degree) . \n\nFor a non-simple proper basis, the realization (Al-λEl,Bl,Cl,Dl) is observable and the pencil [Al-λEl; Cl] is in an observable staircase form. The row dimensions of the full column rank diagonal blocks are returned in info.stdim and the corresponding left Kronecker indices are returned in info.degs.   For a simple basis, the regular pencil Al-λEl is block diagonal, with the i-th block of size info.stdim[i].  The increasing numbers of poles of the basis vectors are returned in info.degs.  For the i-th basis vector vi(λ) (i.e., the i-th row of Nl(λ))  a minimal realization can be explicitly constructed as (Ali-λEli,Bl,Cli,Dl[i,:]), where Ali, Eli and Cli are the i-th diagonal blocks of Al, El, and Cl, respectively, and Dl[i,:] is the i-th row of Dl.  The corresponding realization of vi(λ)*G2(λ) can be constructed as (Ali-λEli,Bl2,Cl2,Dl2[i,:]), where Dl2[i,:] is the i-th row of Dl2.\n\nFor a proper basis, the poles of Nl(λ) can be freely assigned, by assigning the eigenvalues of the pencil Al-λEl. The vector poles, specified as a keyword argument, can be used to specify the desired eigenvalues, alternatively to or jointly with enforcing a desired stability degree sdeg of the real parts of the eigenvalues,  for a continuous-time system, or the moduli of eigenvalues, for a discrete-time system.  If coinner = true, the resulting basis Nl(λ) is coinner, i.e., Nl(λ)*Nl(λ)' = I, where Nl(s)' = transpose(Nl(-s)) for a  continuous-time system with λ = s and Nl(z)' = transpose(Nl(1/z)) for a discrete-time system with λ = z.  If the proper basis is simple, each of the resulting individual basis vector is inner.  If sys2 has poles on the boundary of the appropriate stability domain Cs, which are not poles of sys1 too,  then there exists no inner Nl(λ) such that Nl(λ)*G2(λ) is stable. An offset can be specified via the keyword parameter offset = β to be used to assess the existence of zeros on the stability domain boundary. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. The computation of simple bases involves the solution of several Type 1 minimum dynamic cover problems. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations.  \n\nNote: The resulting realization of syslnull is minimal provided the realization of sys is minimal.  However, syslnull1 is a minimal basis only if the realization (A-lambda E,B,C,D) of sys1 is  minimal. In this case, info.degs are the degrees of the vectors of a minimal polynomial basis or,  if simple = true, of the resulting minimal simple proper basis. \n\nMethod: The computation method for the computation of a right nullspace basis is applied to the dual of descriptor system sys. The computation of a minimal proper right nullspace basis is based on [1]; see also [2]. For the computation of a minimal simple proper  right nullspace basis the method of [3] is emloyed to compute a simple basis from a minimal proper basis. For the computation of an inner proper right nullspace basis, the inner factor of an inner-outer factorization of Nl(λ) is explicitly  constructed using formulas given in [4]. \n\nReferences:\n\n[1] T.G.J. Beelen.     New algorithms for computing the Kronecker structure of a pencil      with applications to systems and control theory.      Ph. D. Thesis, Technical University Eindhoven, 1987.\n\n[2] A. Varga.     On computing least order fault detectors using rational nullspace bases.      IFAC SAFEPROCESS'03 Symposium, Washington DC, USA, 2003.\n\n[3] A. Varga.     On computing nullspace bases – a fault detection perspective.      Proc. IFAC 2008 World Congress, Seoul, Korea, pages 6295–6300, 2008.\n\n[4] K. Zhou, J. C. Doyle, and K. Glover.      Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grange","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grange","text":"grange(sys; zeros = \"none\", atol = 0, atol1 = atol, atol2 = atol, rtol, \n       fast = true, offset = sqrt(ϵ)) -> (sysr, sysx, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the proper descriptor system sysr = (Ar-λEr,Br,Cr,Dr) with a full column rank  transfer function matrix R(λ) such that Range(G(λ)) = Range(R(λ)) and the   descriptor system sysx = (A-λE,B,Cx,Dx) with the full row rank transfer function matrix X(λ), which satisfies\n\n G(λ) = R(λ)*X(λ) ,\n\nrepresenting a full rank factorization of G(λ).   The number of columns of R(λ) is the normal rank r of G(λ).  The columns of R(λ) form a rational basis of the range (or image) space of the rational matrix G(λ).  A selected set of zeros of G(λ) are included as zeros of R(λ). \n\nThe resulting named triple info contains (nrank, nfuz, niuz), where info.nrank = r,  the normal rank of G(λ), info.nfuz is the number of finite zeros of sys on  the boundary of the stability domain Cs, and info.niuz is the number of infinite zeros of sys in  the continuous-time case and is set to 0 in the discrete-time case. \n\nDepending on the value of the keyword parameter zeros, the following options can be selected  for the zeros of G(λ) to be included in R(λ):\n\n \"none\"       - include no zeros (default) \n \"all\"        - include all zeros of `sys`\n \"unstable\"   - include all unstable zeros of `sys`\n \"s-unstable\" - include all strictly unstable zeros of `sys`, both finite and infinite\n \"stable\"     - include all stable zeros of `sys`\n \"finite\"     - include all finite zeros of `sys`\n \"infinite\"   - include all infinite zeros of `sys`\n\nIf inner = true, the resulting basis R(λ) is inner, i.e., R(λ)'*R(λ) = I, where R(s)' = transpose(R(-s)) for a  continuous-time system with λ = s and R(z)' = transpose(R(1/z)) for a discrete-time system with λ = z.  This option can be used only in conjunction with zeros = \"none\" or zeros = \"unstable\". \n\nFor a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,    and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nFor the assessment of zeros, the system pencil [A-λE B; C D] is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The range computation method is described in [1] and is based on  the reduction algorithm of [2], which has been adapted to deal with  several zero selection options. The computation of the involved  Kronecker-like form is based on the algorithm of [3].\n\nReferences:\n\n[1] Varga, A.     A note on computing the range of rational matrices.      arXiv:1707.0048, https://arxiv.org/abs/1707.0048, 2017.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n[3] C. Oara and P. Van Dooren.      An improved algorithm for the computation of structural invariants of a system pencil and related geometric aspects.      Syst. Control Lett., 30:39–48, 1997.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.gcrange","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.gcrange","text":"gcrange(sys; zeros = \"none\", coinner = false, atol = 0, atol1 = atol, atol2 = atol, rtol, \n        fast = true, offset = sqrt(ϵ)) -> (sysr, sysx, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the proper descriptor system sysr = (Ar-λEr,Br,Cr,Dr) with a full row rank  transfer function matrix R(λ) such that Coimage(G(λ)) = Coimage(R(λ)) and the   descriptor system sysx = (A-λE,B,Cx,Dx) with the full column rank transfer function matrix X(λ), which satisfies\n\n G(λ) = X(λ)*R(λ) ,\n\nrepresenting a full rank factorization of G(λ).   The number of rows of R(λ) is the normal rank r of G(λ).  The rows of R(λ) form a rational basis of the coimage space of the rational matrix G(λ).  A selected set of zeros of G(λ) are included as zeros of R(λ). \n\nThe resulting named triple info contains (nrank, nfuz, niuz), where info.nrank = r,  the normal rank of G(λ), info.nfuz is the number of finite zeros of sys on  the boundary of the stability domain Cs, and info.niuz is the number of infinite zeros of sys in  the continuous-time case and is set to 0 in the discrete-time case. \n\nThe following options can be selected via the keyword parameter zeros for which zeros of G(λ)  to be included in R(λ):\n\n \"none\"       - include no zeros (default) \n \"all\"        - include all zeros of `sys`\n \"unstable\"   - include all unstable zeros of `sys`\n \"s-unstable\" - include all strictly unstable zeros of `sys`, both finite and infinite\n \"stable\"     - include all stable zeros of `sys`\n \"finite\"     - include all finite zeros of `sys`\n \"infinite\"   - include all infinite zeros of `sys`\n\nIf coinner = true, the resulting basis R(λ) is coinner, i.e., R(λ)*R(λ)' = I, where R(s)' = transpose(R(-s)) for a  continuous-time system with λ = s and R(z)' = transpose(R(1/z)) for a discrete-time system with λ = z.  This option can be used only in conjunction with zeros = \"none\" or zeros = \"unstable\". \n\nFor a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nFor the assessment of zeros, the dual system pencil transpose([A-λE B; C D]) is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The range computation method described in [1], is applied to the dual descriptor system realization corresponding to the transpose of the  rational matrix G(λ). The underlying pencil reduction algorithm of [2],  has been adapted to deal with several zero selection options. The computation of the involved  Kronecker-like form is based on the algorithm of [3].\n\nReferences:\n\n[1] Varga, A.     A note on computing the range of rational matrices.      arXiv:1707.0048, https://arxiv.org/abs/1707.0048, 2017.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n[3] C. Oara and P. Van Dooren.      An improved algorithm for the computation of structural invariants of a system pencil and related geometric aspects.      Syst. Control Lett., 30:39–48, 1997.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grsol","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grsol","text":"grsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and  sysf = (Af-λEf,Bf,Cf,Df) with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the solution of the linear rational equation\n\nG(λ)X(λ) = F(λ) .      (1)\n\nIf solgen = true, the descriptor system sysgen is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form GEN(λ) = [ X0(λ) XN(λ) ],  such that any X(λ) can be generated as\n\nX(λ) = X0(λ) + XN(λ)*Z(λ) ,\n\nwhere X0(λ) is a particular solution satisfying G(λ)X0(λ) = F(λ),  XN(λ) is a proper rational right nullspace basis of G(λ) satisfying G(λ)XN(λ) = 0, and  Z(λ) is an arbitrary rational matrix with suitable dimensions. If solgen = false, sysgen is set to nothing. \n\nThe call with\n\ngrsol(sysgf, mf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nuses the compound descriptor system sysgf = (A-λE,[Bg Bf],C,[Dg Df]),  where Bf has mf columns, to define   the descriptor systems sysg = (A-λE,Bg,C,Dg) and sysf = (A-λE,Bf,C,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Cg = Cf = C). \n\nThe generator sysgen has a descriptor system realization sysgen = (A0-λE0,[B0 BN],C0,[D0 DN]), which is usually not minimal  (uncontrollable and/or non-dynamic modes present), with  \n\n               ( Ar-λEr    *       *    )  \n   A0-λE0    = (   0     Af-λEf    *    ) , \n               (   0       0     Ai-λEi ) \n\n               ( B1 | Br )\n   [B0 | BN] = ( B2 | 0  ),  Cg  =   ( Cr   *    *  ) ,\n               ( B3 | 0  )\n\nwith Er, Ef and Ai invertible and upper triangular, Ei nillpotent and upper triangular, and DN full row rank. The dimensions of the diagonal blocks of A0-λE0 are  returned in the named tuple info as the components info.nr, info.nf, and info.ninf, respectively. \n\nA minimal order descriptor system realization of the proper basis XN(λ) is (Ar-λEr,Br,Cr,DN),  where Br and DN have mr columns (returned in info.mr), representing the dimension of the  right nullspace basis. The normal rank nrank of  G(λ) is returned in info.nrank. \n\nIf mindeg = false, the solution sysx is determined in the form sysx = (A0+BN*F-λE0,B0,C0+DN*F,D0), where the matrix F = 0, unless a nonzero stabilizing gain is used such that Ar+Br*F-λEr has stable eigenvalues.  The vector poles specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree sdeg of eigenvalues.  The dimension nr of Ar is the number of freely assignable poles of the solution X(λ) and is returned in info.nr.  The eigenvalues of Af-λEf contain the finite zeros of G(λ), while the zeros  of Ai-λEi contain the infinite zeros of G(λ).    The norm of the employed gain F is returned in info.fnorm. If G(λ) has infinite zeros, then the solution X(λ) may have infinite poles. The integer vector info.rdeg contains the relative column degrees of  X(λ) (i.e., the numbers of integrators/delays needed to make each column of X(λ) proper).  \n\nIf mindeg = true, a minimum degree solution is determined as X(λ) = X0(λ) + XN(λ)*Z(λ), where Z(λ) is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback and feedforward gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations. \n\nIf minreal = true, the computed realization sysx is minimal.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of Ag, Bg, Cg, Dg, Af, Bf, Cf, Df,  the absolute tolerance for the nonzero elements of Eg and Ef,   and the relative tolerance for the nonzero elements of     Ag, Bg, Cg, Dg, Af, Bf, Cf, Df, Eg and Ef.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sysg and sysf. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The method of [1] to solve rational systems is used.\n\nReferences:\n\n[1] A. Varga, \"Computation of least order solutions of linear rational equations\",  Proc. MTNS'04, Leuven, Belgium, 2004.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glsol","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glsol","text":"glsol(sysg, sysf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and  sysf = (Af-λEf,Bf,Cf,Df) with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the solution of the linear rational equation\n\nX(λ)G(λ) = F(λ) .      (1)\n\nIf solgen = true, the descriptor system sysgen is determined representing a generator of  all solutions of (1). Its transfer function matrix has the form GEN(λ) = [ X0(λ); XN(λ) ],  such that any X(λ) can be generated as\n\nX(λ) = X0(λ) + Z(λ)*XN(λ) ,\n\nwhere X0(λ) is a particular solution satisfying X0(λ)G(λ) = F(λ),  XN(λ) is a proper rational left nullspace basis of G(λ) satisfying XN(λ)G(λ) = 0, and  Z(λ) is an arbitrary rational matrix with suitable dimensions. If solgen = false, sysgen is set to nothing. \n\nThe call with\n\nglsol(sysgf, pf; poles = missing, sdeg = missing, mindeg = false, solgen = false, minreal = true, fast = true, \n      atol = 0, atol1 = atol, atol2 = atol, rtol, ) -> (sysx, info, sysgen)\n\nuses the compound descriptor system sysgf = (A-λE,B,[Cg; Cf],[Dg; Df]),  where Cf has pf rows, to define   the descriptor systems sysg = (A-λE,B,Cg,Dg) and sysf = (A-λE,B,Cf,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Bg = Bf = B). \n\nThe generator sysgen has a descriptor system realization sysgen = (A0-λE0,B0, [C0; CN],[D0; DN]), which is usually not minimal  (unobservable and/or non-dynamic modes present), with  \n\n             ( Ai-λEi    *       *    )  \n   A0-λE0  = (   0     Af-λEf    *    ) , \n             (   0       0     Al-λEl ) \n\n             ( *  )\n       B0  = ( *  ),   ( C0 )  = ( C1 C2 C3 ) \n             ( Bl )    ( CN )    ( 0  0  Cl )\n\nwith El, Ef and Ai invertible and upper triangular, Ei nillpotent and upper triangular, and DN full column rank. The dimensions of the diagonal blocks of A0-λE0 are  returned in the named tuple info as the components info.nf, info.ninf and info.nl, respectively. \n\nA minimal order descriptor system realization of the proper basis XN(λ) is (Al-λEl,Bl,Cl,DN),  where Cl and DN have pr columns (returned in info.pr), representing the dimension of the  left nullspace basis. The normal rank nrank of  G(λ) is returned in info.nrank. \n\nIf mindeg = false, the solution sysx is determined in the form sysx = (A0+F*CN-λE0,B0+F*DN,C0,D0), where the matrix F = 0, unless a nonzero stabilizing gain is used such that Al+F*Bl-λEl has stable eigenvalues.  The vector poles specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree sdeg of eigenvalues.  The dimension nl of Al is the number of freely assignable poles of the solution X(λ) and is returned in info.nl.  The eigenvalues of Af-λEf contain the finite zeros of G(λ), while the zeros  of Ai-λEi contain the infinite zeros of G(λ).    The norm of the employed gain F is returned in info.fnorm. If G(λ) has infinite zeros, then the solution X(λ) may have infinite poles. The integer vector info.rdeg contains the relative row degrees of  X(λ) (i.e., the numbers of integrators/delays needed to make each row of X(λ) proper).  \n\nIf mindeg = true, a minimum degree solution is determined as X(λ) = X0(λ) + Z(λ)XN(λ), where Z(λ) is determined using order reduction based on a Type 2 minimum dynamic cover. This computation involves using non-orthogonal transformations whose worst condition number is returned in info.tcond, in conjunction with  using feedback and feedforward gains, whose norms are returned in info.fnorm. High values of these quantities indicate a potential loss of numerical stability of computations. \n\nIf minreal = true, the computed realization sysx is minimal.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of Ag, Bg, Cg, Dg, Af, Bf, Cf, Df,  the absolute tolerance for the nonzero elements of Eg and Ef,   and the relative tolerance for the nonzero elements of     Ag, Bg, Cg, Dg, Af, Bf, Cf, Df, Eg and Ef.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sysg and sysf. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The dual of method of [1] to solve rational systems is used.\n\nReferences:\n\n[1] A. Varga, \"Computation of least order solutions of linear rational equations\",  Proc. MTNS'04, Leuven, Belgium, 2004.\n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grmcover1","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grmcover1","text":"grmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a right minimum dynamic cover of Type 1 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + X2(λ)*Y(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\ngrmcover1(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,[B1 B2],C,[D1 D2]),  where B1 and D1 have m1 columns, to define   the proper descriptor systems sys1 = (A-λE,B1,C,D1) and sys2 = (A-λE,B2,C,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and C1 = C2 = C).   \n\nThe resulting descriptor systems sysx and sysy have controllable realizations of the form sysx = (Ar-λEr,Br,Cr1,D1) and sysy = (Ar-λEr,Br,Cr2,0),  where the pencil [Br Ar-λEr] is in a (controllability) staircase form,   with νr[i] x νr[i-1] full row rank diagonal blocks, for i = 1, ..., nr,  with νr[0] := m1. \n\nThe resulting named triple info contains (stdim, tcond, fnorm),  where info.stdim = νr is a vector which contains the row dimensions of the blocks of the staircase form [Br Ar-λEr], info.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and info.fnorm is  the Frobenius-norm of the (internally) employed state-feedback to reduce the order.  Large values of  info.tcond or info.fnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: grmcover1 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, info.stdim = νr contains the information corresponding to the proper part of sysx. \n\nMethod: The method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting order (McMillan degree) of sysx is the least achievable one provided the realization of sys2 is maximally observable  (i.e., the pair (A2+B2*F-λE2,C2+D2*F) is observable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glmcover1","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glmcover1","text":"glmcover1(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a left minimum dynamic cover of Type 1 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + Y(λ)*X2(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\nglmcover1(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,B,[C1; C2],[D1; D2]),  where C1 and D1 have p1 rows, to define   the proper descriptor systems sys1 = (A-λE,B,C1,D1) and sys2 = (A-λE,B,C2,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and B1 = B2 = B).   \n\nThe resulting descriptor systems sysx and sysy have observable realizations of the form sysx = (Ao-λEo,Bo1,Co,D1) and sysy = (Ao-λEo,Bo2,Co,0),  where the pencil [Ao-λEo; Co] is in a (observability) staircase form,   with νl[i] x νl[i+1] full row rank diagonal blocks, for i = 1, ..., nl,  with νl[nl+1] := p1. \n\nThe resulting named triple info contains (stdim, tcond, fnorm),  where info.stdim = νl is a vector which contains the column dimensions of the blocks of the staircase form [Ao-λEo; Co], info.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, and info.fnorm is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order.  Large values of  info.tcond or info.fnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: glmcover1 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, info.stdim = νl contains the information corresponding to the proper part of sysx. \n\nMethod: The dual of method  of [1] is used to compute Type 1 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally controllable  (i.e., the pair (A2+F*C2-λE2,B2+F*D2) is controllable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.grmcover2","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.grmcover2","text":"grmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a right minimum dynamic cover of Type 2 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + X2(λ)*Y(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\ngrmcover2(sys, m1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,[B1 B2],C,[D1 D2]),  where B1 and D1 haves m1 columns, to define   the proper descriptor systems sys1 = (A-λE,B1,C,D1) and sys2 = (A-λE,B2,C,D2) (i.e., A1-λE1 = A2-λE2 =: A-λE and C1 = C2 =: C).   \n\nThe resulting descriptor systems sysx and sysy have controllable realizations of the form sysx = (Ar-λEr,Br,Cr1,Dr1) and sysy = (Ar-λEr,Br,Cr2,Dr2),  where the pencil [Br Ar-λEr] is in a (controllability) staircase form,   with νr[i] x νr[i-1] full row rank diagonal blocks, for i = 1, ..., nr,  with νr[0] := m1. \n\nThe resulting named triple info contains (stdim, tcond, fnorm, gnorm),  where info.stdim = νr is a vector which contains the row dimensions of the blocks of the staircase form [Br Ar-λEr], info.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, info.fnorm is  the Frobenius-norm of the (internally) employed state-feedback gain to reduce the order, info.gnorm is  the Frobenius-norm of the (internally) employed feedforward gain to reduce the order.  Large values of  info.tcond, info.fnorm  or  info.gnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of     A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: grmcover2 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, info.stdim = νr contains the information corresponding to the proper part of sysx. \n\nMethod: The method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally observable  (i.e., the pair (A2+B2*F-λE2,C2+D2*F) is observable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.glmcover2","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.glmcover2","text":"glmcover2(sys1, sys2; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nDetermine for the proper descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices X1(λ) and X2(λ),  respectively, using a left minimum dynamic cover of Type 2 based  order reduction, the descriptor systems sysx and sysy with the  transfer function matrices X(λ) and Y(λ), respectively, such that \n\nX(λ) = X1(λ) + Y(λ)*X2(λ) ,\n\nand sysx has order less than the order of sys1.  \n\nThe call with\n\nglmcover2(sys, p1; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol) -> (sysx, sysy, info)\n\nuses the compound descriptor system sys = (A-λE,B, [C1; C2],[D1; D2]),  where C1 and D1 have p1 rows and E is invertible, to define   the proper descriptor systems sys1 = (A-λE,B,C1,D1) and sys2 = (A-λE,B,C2,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and B1 = B2 = B).   \n\nThe resulting descriptor systems sysx and sysy have observable realizations of the form sysx = (Ao-λEo,Bo1,Co,Do1) and sysy = (Ao-λEo,Bo2,Co,Do2),  where the pencil [Ao-λEo; Co] is in a (observability) staircase form,   with νl[i] x νl[i+1] full row rank diagonal blocks, for i = 1, ..., nl,  with νl[nl+1] := p1. \n\nThe resulting named triple info contains (stdim, tcond, fnorm, gnorm),  where info.stdim = νl is a vector which contains the column dimensions of the blocks of the staircase form [Ao-λEo; Co], info.tcond is the maximum of  the Frobenius-norm condition numbers of the employed non-orthogonal  transformation matrices, info.fnorm is  the Frobenius-norm of the (internally) employed output-injection gain to reduce the order, and  info.gnorm is the Frobenius-norm of the (internally) employed output-feedforward gain.  Large values of  info.tcond,info.fnorm or info.gnorm indicate possible loss of  numerical stability of computations. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,   and the relative tolerance for the nonzero elements of  A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximal order of the systems sys1 and sys2. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol. \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nNote: glmcover2 also works for arbitrary descriptor system sys1,  if sys2 is proper. For an improper system sys1, the order  reduction is performed only for the proper part of sys1, while the  polynomial part of sys1 is included without modification in the   resulting realization of sysx. In this case, info.stdim = νl contains the information corresponding to the proper part of sysx. \n\nMethod: The dual of method  of [1] is used to compute Type 2 minimum dynamic covers  for standard systems and the dual of method of [2] for proper descriptor systems.    The resulting McMillan degree of sysx is the least achievable one provided the realization of sys2 is maximally controllable  (i.e., the pair (A2+F*C2-λE2,B2+F*D2) is controllable for any F). \n\nReferences:\n\n[1] A. Varga, Reliable algorithms for computing minimal dynamic covers,     Proc. CDC'03, Maui, Hawaii, 2003.\n\n[2] A. Varga. Reliable algorithms for computing minimal dynamic covers for      descriptor systems. Proc. MTNS Symposium, Leuven, Belgium, 2004. \n\n\n\n\n\n","category":"function"},{"location":"advanced_operations.html#DescriptorSystems.ginv","page":"Advanced operations on transfer function matrices","title":"DescriptorSystems.ginv","text":"ginv(sys; type = \"1-2\", mindeg = false, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol, \n          offset = sqrt(ϵ)) -> (sysinv, info)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ)  a generalized inverse system sysinv = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  such that two or more of the following Moore-Penrose conditions are satisfied:\n\n     (1) G(λ)*Gi(λ)*G(λ) = G(λ);        \n     (2) Gi(λ)*G(λ)*Gi(λ) = Gi(λ);\n     (3) G(λ)*Gi(λ) = (G(λ)*Gi(λ))';\n     (4) Gi(λ)*G(λ) = (Gi(λ)*G(λ))'.\n\nThe desired type of the computed generalized inverse can be specified using the keyword parameter type as follows: \n\n  \"1-2\"     - for a generalized inverse which satisfies conditions (1) and (2) (default);\n  \"1-2-3\"   - for a generalized inverse which satisfies conditions (1), (2) and (3);\n  \"1-2-4\"   - for a generalized inverse which satisfies conditions (1), (2) and (4);\n  \"1-2-3-4\" - for the Moore-Penrose pseudoinverse, which satisfies all conditions (1)-(4).\n\nThe vector poles specified as a keyword argument, can be used to specify the desired eigenvalues alternatively to or jointly with enforcing a desired stability degree sdeg of the poles of the  computed generalized inverse. \n\nThe keyword argument mindeg can be used to specify the option to determine a minimum order  generalized inverse, if mindeg = true, or a particular generalized inverse which has  possibly non-minimal order, if mindeg = false (default).\n\nTo assess the presence of zeros on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time setting,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time setting, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe returned named tuple info has the components info.nrank, info.nfp, info.fnorm and info.tcond, where: info.nrank is the normal rank of G(λ),  info.nfp is the number of freely assignable poles of the inverse Gi(λ),   info.fnorm is the maximum of norms of employed feedback gains (also for pole assignment) and  info.tcond is the maximum of condition numbers of employed non-orthogonal transformations (see below).  \n\nThe rank determinations in the performed reductions  are based on rank revealing QR-decompositions with column pivoting,  if fast = true, or the more reliable SVD-decompositions, if fast = false. The computation of a minimum order inverse is performed by solving suitable minimum dynamic cover problems. These computations involve using non-orthogonal transformations whose maximal condition number is returned in info.tcond, in conjunction with  using feedback gains (also for pole assignment), whose maximal norms are returned in info.fnorm.  High values of these quantities indicate a potential loss of numerical stability of computations.  \n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximum dimension of state, input and output vectors of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nMethod:  The methods proposed in [1] are employed in conjunction with  full rank factorizations computed using the approach of [2].\n\nReferences:\n\n[1] A. Varga. Computing generalized inverse systems using matrix pencil methods.     Int. J. of Applied Mathematics and Computer Science, vol. 11, pp. 1055-1068, 2001.\n\n[2] Varga, A. A note on computing range space bases of rational matrices.         arXiv:1707.0048, https://arxiv.org/abs/1707.00489, 2017.\n\n\n\n\n\n","category":"function"},{"location":"connections.html#Interconnecting-descriptor-system-models","page":"Interconnecting descriptor system models","title":"Interconnecting descriptor system models","text":"append  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nfeedback   Applying a static output feedback.\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).","category":"section"},{"location":"connections.html#DescriptorSystems.append","page":"Interconnecting descriptor system models","title":"DescriptorSystems.append","text":"sys = append(systems...)\n\nAppend the descriptor systems systems by concatenating the input and output vectors of individual systems. This corresponds to the block diagonal concatenation of  their transfer function matrices.  Appending systems with constant matrices, vectors or scalars or with UniformScalings is also supported. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.parallel","page":"Interconnecting descriptor system models","title":"DescriptorSystems.parallel","text":"sys = parallel(sys1, sys2) \nsys = sys1 + sys2\n\nConnect the descriptor systems sys1 and sys2 in parallel such that sys = sys1 + sys2.  This coupling corresponds to the addition of their transfer function matrices.  Parallel coupling of systems with constant matrices or vectors having the same row and column dimensions  or with UniformScalings is also supported.  Parallel coupling with a constant is equivalent to elementwise parallel coupling of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.series","page":"Interconnecting descriptor system models","title":"DescriptorSystems.series","text":" sys = series(sys1, sys2) \n sys = sys2*sys1\n\nConnect the descriptor systems sys1 and sys2 in series such that sys = sys2*sys1. This coupling corresponds to the multiplication of their transfer function matrices.  Series coupling of systems with constant matrices and vectors having suitable dimensions  or with UniformScalings is also supported.  Series coupling with a constant is equivalent to elementwise multiplication of  the transfer function matrix with the constant. \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.feedback","page":"Interconnecting descriptor system models","title":"DescriptorSystems.feedback","text":" syscl = feedback(sys, K, inp1, out1; negative = true)\n\nBuild for a given descriptor system sys with input vector u and output vector y and  a static output feedback gain K the closed-loop descriptor system syscl is constructed corresponding to the static output feedback u[inp] = -K*y[out] + v, where inp and out are  are indices, vectors of indices, index ranges, : or any combinations of them. Only distinct indices  can be specified. If negative = false, a positive feedback u[inp] = K*y[out] + v is used.\n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.horzcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.horzcat","text":"sys = horzcat(sys1,sys2)\nsys = [sys1 sys2]\nsys = horzcat(systems...)\n\nConcatenate horizontally two systems sys1 and sys2 or several descriptor systems systems...  by concatenating the input vectors of individual systems. This corresponds to the horizontal  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same row dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"connections.html#DescriptorSystems.vertcat","page":"Interconnecting descriptor system models","title":"DescriptorSystems.vertcat","text":"sys = vertcat(sys1,sys2)\nsys = [sys1; sys2]\nsys = vertcat(systems...)\n\nConcatenate vertically two descriptor systems sys1 and sys2 or several descriptor systems systems...  by concatenating the output vectors of individual systems. This corresponds to the vertical  concatenation of their transfer function matrices.  Concatenation of systems with constant matrices, vectors, or scalars having the same column dimensions  or with UniformScalings is also supported.  \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#Some-operations-on-rational-transfer-functions-and-matrices","page":"Some operations on rational transfer functions and matrices","title":"Some operations on rational transfer functions and matrices","text":"simplify  Pole-zero cancellation.\nnormalize   Normalization of a rational transfer function to monic denominator.\nconfmap   Applying a conformal mapping transformation to a rational transfer function or a rational transfer function matrix.\nzpk  Computation of zeros, poles and gain of a rational transfer function.\nrtfbilin  Generation of common bilinear transformations and their inverses.","category":"section"},{"location":"operations_rtf.html#DescriptorSystems.simplify","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.simplify","text":" simplify(r; atol = 0, rtol = atol)\n\nSimplify the rational transfer function r(λ) by cancellation of common divisors of numerator and denominator.  The keyword arguments atol and rtol are the absolute and relative tolerances for the nonzero numerator and denominator coefficients. \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#LinearAlgebra.normalize","page":"Some operations on rational transfer functions and matrices","title":"LinearAlgebra.normalize","text":" normalize(r)\n\nNormalize the rational transfer function r(λ) to have a monic denominator polynomial. \n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.confmap","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.confmap","text":"rt = confmap(r, f)\n\nApply the conformal mapping transformation λ = f(δ) to the rational transfer function r(λ)  and return rt(δ) = r(f(δ)). The resulting rt inherits the sampling time and variable of f.\n\n\n\n\n\nRt = confmap(R, f)\n\nApply elementwise the conformal mapping transformation λ = f(δ) to the rational transfer function matrix R(λ)  and return Rt(δ) = R(f(δ)). The resulting elements of Rt inherit the sampling time and variable of f.\n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.zpk","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.zpk","text":" zpk(r) -> (z, p, k)\n\nCompute the roots (zeros) z, poles p and gain k of the rational transfer function r(λ).\n\n\n\n\n\n","category":"function"},{"location":"operations_rtf.html#DescriptorSystems.rtfbilin","page":"Some operations on rational transfer functions and matrices","title":"DescriptorSystems.rtfbilin","text":" rtfbilin(type = \"c2d\"; Ts = T, Tis = Ti, a = val1, b = val2, c = val3, d = val4) -> (g, ginv)\n\nBuild the rational transfer functions of several commonly used bilinear transformations and their inverses.  The resulting g describes the rational transfer function g(δ) in the bilinear transformation λ = g(δ) and  ginv describes its inverse transformation ginv(λ) in the bilinear transformation δ = ginv(λ). In accordance with the values of type and the keyword argument values Ts, Tis, a, b, c, and d,  the resulting g and ginv contain first order rational transfer functions of the form g(δ) = (a*δ+b)/(c*δ+d)  and ginv(λ) = (d*λ-b)/(-c*λ+a), respectively, which satisfy g(ginv(λ)) = λ and ginv(g(δ)) = δ. \n\nDepending on the value of type, the following types of transformations can be generated  in conjunction with parameters specified in Ts, Tis, a, b, c, and d:\n\n\"Cayley\" - Cayley transformation: `s = g(z) = (z-1)/(z+1)` and `z = ginv(s) = (s+1)/(-s+1)`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n           g(z) and ginv(s) are also known as the continuous-to-discrete and discrete-to-continuous transformations, respectively; \n\n\"c2d\"    - is alias to \"Cayley\"\n\n\"Tustin\" - Tustin transformation (also known as trapezoidal integration): `s = g(z) = (2*z-2)/(T*z+T)` and `z = ginv(s) = (T*s+2)/(-T*s+2)`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n           a nonzero prewarping frequency `freq` can be specified using the keyword parameter `prewarp_freq = freq`;\n\n\"Euler\"  - Euler integration (or forward Euler integration): `s = g(z) = s = (z-1)/T` and `z = ginv(s) = T*s+1`; \n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n\n\"BEuler\" - Backward Euler integration (or backward Euler integration): `s = g(z) = (z-1)/(T*z)` and `z = ginv(s) = 1/(-T*s+1)`;\n           the sampling time `g.Ts` is set to the value `T ≠ 0` (default `T = -1`), while `ginv.Ts = 0`;\n\n\"Moebius\" - general (Moebius ) bilinear transformation: `λ = g(δ) = (a*δ+b)/(c*δ+d)` and `δ = ginv(λ) = (d*λ-b)/(-c*λ+a)`;  \n            the sampling times `g.Ts` and `ginv.Ts` are  set to the values `T` and `Ti`, respectively;\n            the default values of the parameters `a`, `b`, `c`, and `d` are `a = 1`, `b = 0`, `c = 0`, and `d = 1`.\n            Some useful particular Moebius transformations correspond to the following choices of parameters: \n            - _translation_: `a = 1`, `b ≠ 0`, `c = 0`, `d = 1` (`λ = δ+b`)\n            - _scaling_: `a ≠ 0`, `b = 0`, `c = 0`, `d = 1` (`λ = a*δ`)\n            - _rotation_: `|a| = 1`, `b = 0`, `c = 0`, `d = 1` (`λ = a*δ`)\n            - _inversion_: `a = 0`, `b = 1`, `c = 1`, `d = 0`  (`λ = 1/δ`)\n\n\"lft\"     - alias to \"Moebius\" (linear fractional transformation).\n\n\n\n\n\n","category":"function"},{"location":"makeindex.html#Index","page":"Index","title":"Index","text":"Pages = [ \"dss.md\",\n          \"rtf.md\",\n          \"operations.md\",\n          \"operations_rtf.md\",\n          \"connections.md\",\n          \"conversions.md\",\n          \"order_reduction.md\",\n          \"analysis.md\",\n          \"factorizations.md\",\n          \"advanced_operations.md\",\n          \"model_matching.md\",\n          \"dstools.md\" ]\nModules = [DescriptorSystems]\nOrder = [:type, :function]","category":"section"},{"location":"analysis.html#Descriptor-system-analysis","page":"Descriptor system analysis","title":"Descriptor system analysis","text":"isregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.\ngnugap  ν-gap distance between two descriptor systems.\nfreqresp   Frequency response of a descriptor system.\ntimeresp   Time response of a descriptor system.\nstepresp   Step response of a descriptor system.\ngbalqual Evaluation of the scaling quality of the matrices of a descriptor system.","category":"section"},{"location":"analysis.html#MatrixPencils.isregular","page":"Descriptor system analysis","title":"MatrixPencils.isregular","text":"isregular(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has a regular pole pencil A-λE and false otherwise.  \n\nFor a dense model, to test whether the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0),   the underlying computational procedure reduces the pencil A-λE to an appropriate Kronecker-like form,  which provides information on the rank of A-λE. For a sparse model, the rank of A-λE is evaluated for a randomly  generated value of λ. \n\nThe keyword arguements atol1, atol2 and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E, and the relative tolerance  for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of  A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpole","page":"Descriptor system analysis","title":"DescriptorSystems.gpole","text":"val = gpole(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE.  The values in val are the poles of the transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor E nonsingular, val contains the generalized eigenvalues of the pair (A,E).  For E singular, val contains the zeros of P(λ), which are computed  by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe regularity of A-λE is implicitly checked. If check_reg = true, an error message is issued if the pencil    A-λE is singular. If check_reg = false and the pencil A-λE is singular, then n-r poles are set to NaN, where n is the system order and r is the normal rank of A-λE. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gpoleinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gpoleinfo","text":"gpoleinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite zeros of the system pole pencil P(λ) := A-λE and the named tuple info containing information on  the eigenvalue structure of the pole pencil P(λ). The values in val are the poles of the  transfer function matrix of sys, if A-λE is regular and the  descriptor system realization sys = (A-λE,B,C,D) is irreducible.  If the pencil A-λE is singular, val also contains NaN elements, whose number is the rank deficiency of the pencil  A-λE.\n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite eigenvalues, in conjunction with a stability domain boundary offset β to numerically assess the  finite eigenvalues  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite eigenvalues having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite eigenvalues having moduli in the interval [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfev is the number of finite eigenvalues of the pencil A-λE (also the number of finite poles of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil A-λE;\n\ninfo.nisev is the number of simple infinite eigenvalues of the pencil A-λE (also known as non-dynamic modes); \n\ninfo.nip is the number of infinite poles of the system sys;\n\ninfo.nfsev is the number of finite stable eigenvalues, i.e., the finite eigenvalues having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbev is the number of finite eigenvalues on the boundary of the            stability domain, i.e., the finite eigenvalues           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuev is the number of finite unstable eigenvalues, i.e., the finite eigenvalues having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nhev is the number of hidden eigenvalues set to NaN          (can be nonzero only if the pencil A-λE is singular);  \n\ninfo.nrank is the normal rank of the pencil A-λE;\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil A-λE as follows:           the i-th element info.miev[i] is the order of an infinite elementary divisor            (i.e., the multiplicity of an infinite eigenvalue) and            the number of infinite poles is the sum of the components of info.miev;  \n\ninfo.mip is an integer vector, which contains the information on the              multiplicities of the infinite zeros of A-λE as follows:             the i-th element info.mip[i] is equal to k-1, where k is the order of an infinite elementary               divisor with k > 0 and the number of infinite poles is the sum of the components of info.mip; \n\ninfo.rki is an integer vector, which contains the right Kronecker indices             of the pencil A-λE (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices            of the pencil A-λE (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil A-λE is regular and set to   false, if the pencil A-λE is singular;\n\ninfo.proper is set to true, if the pencil A-λE is regular and all its infinite                   eigenvalues are simple (has only non-dynamic modes), or                   is set to false, if the pencil A-λE is singular or has higher order infinite eigenvalues;\n\ninfo.stable is set to true, if the pencil A-λE is regular, has only stable                   finite eigenvalues and all its infinite eigenvalues are                  simple (has only non-dynamic modes), and  is set to false otherwise.\n\nNote: The finite poles and the finite eigenvalues of the pencil P(λ) are the same,  but the multiplicities of infinite eigenvalues of P(λ) are in excess with one to the multiplicities of infinite poles.\n\nFor the reduction of the pencil P(λ) to an appropriate Kronecker-like form   orthonal similarity transformations are performed, which involve rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E, respectively.  The default relative tolerance is n*ϵ, where n is the size of P(λ), and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isproper","page":"Descriptor system analysis","title":"DescriptorSystems.isproper","text":"isproper(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = = n*ϵ, fast = true)\n\nReturn true if the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D) is proper and false otherwise.  \n\nFor a descriptor system realization sys = (A-λE,B,C,D) without uncontrollable and unobservable infinite eigenvalues, it is checked that the pencil A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple. If the original descriptor realization has uncontrollable or unobservable infinite eigenvalues, these are elliminated using orthogonal pencil reduction algorithms. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.isstable","page":"Descriptor system analysis","title":"DescriptorSystems.isstable","text":"isstable(sys[, smarg]; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, offset = sqrt(ϵ))\n\nReturn true if the descriptor system sys = (A-λE,B,C,D) has only stable poles and false otherwise.  \n\nIt is checked that the pole pencil P(λ) := A-λE has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple, and additionally the real parts of all finite eigenvalues  are less than smarg-β for a continuous-time system or  have moduli less than smarg-β for a discrete-time system, where smarg is the stability margin and  β is the stability domain boundary offset.  The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system. The offset  β to be used to numerically assess the stability of eigenvalues  can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor E singular, the computation of the poles is performed by reducing the pencil P(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of A and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzero","page":"Descriptor system analysis","title":"DescriptorSystems.gzero","text":"val = gzero(sys; fast = false, prescale, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing the  finite and infinite Smith zeros of the system matrix pencil  \n\n           | A-λE | B | \n   S(λ) := |------|---| .\n           |  C   | D |\n\nThe values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible.\n\nIf prescale = true, a preliminary balancing of the descriptor system matrices is performed.  The default setting is prescale = gbalqual(sys) > 10000, where gbalqual(sys) is the  scaling quality of the descriptor system model sys (see gbalqual). \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A, and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gzeroinfo","page":"Descriptor system analysis","title":"DescriptorSystems.gzeroinfo","text":"gzeroinfo(sys; smarg, fast = false, prescale, atol = 0, atol1 = atol, atol2 = atol, \n          rtol = n*ϵ, offset = sqrt(ϵ)) -> (val, info)\n\nReturn for the descriptor system sys = (A-λE,B,C,D) the complex vector val containing  the finite and infinite Smith zeros of the system matrix pencil S(λ) \n\n          | A-λE | B | \n   S(λ) = |------|---| \n          |  C   | D |\n\nand the named tuple info containing information on the Kronecker structure of the pencil S(λ).  The values in val are called the invariant zeros of the pencil S(λ) and are the transmission zeros of the  transfer function matrix of sys if A-λE is regular and the descriptor system realization  sys = (A-λE,B,C,D) is irreducible. \n\nIf prescale = true, a preliminary balancing of the descriptor system matrices is performed.  The default setting is prescale = gbalqual(sys) > 10000, where gbalqual(sys) is the  scaling quality of the descriptor system model sys (see gbalqual). \n\nFor stability analysis purposes, a stability margin smarg can be specified for the finite zeros, in conjunction with a stability domain boundary offset β to numerically assess the  finite zeros  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite zeros having real parts in the interval [smarg-β, smarg+β], while in the discrete-time case, these are the finite zeros having moduli in the interva [smarg-β, smarg+β]. The default value of the stability margin smarg is 0 for a continuous-time system and  1 for a discrete-time system.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe named tuple info contains the following information:\n\ninfo.nfz is the number of finite eigenvalues of the pencil S(λ) (also the number of finite zeros of sys);\n\ninfo.niev is the number of infinite eigenvalues of the pencil S(λ);\n\ninfo.nisev is the number of  simple infinite eigenvalues of the pencil S(λ); \n\ninfo.niz is the number of infinite zeros of the system sys;\n\ninfo.nfsz is the number of finite stable zeros, i.e., the finite zeros having real parts or moduli less than smarg-β for a continuous- or discrete-time system, respectively;\n\ninfo.nfsbz is the number of finite zeros on the boundary of the            stability domain, i.e., the finite zeros           having real parts or moduli in the interval [smarg-β, smarg+β] for a continuous- or discrete-time system, respectively;\n\ninfo.nfuz is the number of finite unstable zeros, i.e., the finite zeros having real parts or moduli greater than smarg+β for a continuous- or discrete-time system, respectively;\n\ninfo.nrank is the normal rank of the pencil S(λ);\n\ninfo.miev is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil S(λ)              (also the dimensions of the elementary infinite blocks in the           Kronecker form of S(λ));\n\ninfo.miz is an integer vector, which contains the information on the              multiplicities of the infinite zeros of S(λ) as follows:             S(λ) has info.mip[i] infinite zeros of multiplicity i, and               is empty if S(λ) has no infinite zeros;\n\ninfo.rki is an integer vector, which contains the right Kronecker indices           of the pencil S(λ) (empty for a regular pencil);\n\ninfo.lki is an integer vector, which contains the left Kronecker indices          of the pencil S(λ) (empty for a regular pencil);\n\ninfo.regular is set to true,  if the pencil S(λ) is regular and set to   false, if the pencil S(λ) is singular;\n\ninfo.stable is set to true, if the pencil S(λ) has only stable                   finite zeros and all its infinite zeros are                  simple and  is set to false otherwise.\n\nNote: The finite zeros and the finite eigenvalues of the pencil S(λ) are the same, but the multiplicities of infinite eigenvalues     are in excess with one to the multiplicities of infinite zeros. \n\nThe computation of the zeros is performed by reducing the pencil S(λ) to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if fast = true, or, the more reliable, SVD-decompositions, if fast = false. \n\nThe keyword arguements atol1, atol2  and rtol specify the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, E, B, C and D, respectively.  The default relative tolerance is n*ϵ, where n is the size of A and ϵ is the  working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gnrank","page":"Descriptor system analysis","title":"DescriptorSystems.gnrank","text":"r = gnrank(sys, fastrank = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCompute the normal rank r of the transfer function matrix G(λ) of the descriptor system sys = (A-λE,B,C,D). \n\nThe normal rank of G(λ) is evaluated as r = k - n, where k is the normal rank of the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nand n is the order of the system sys (i.e., the size of A). \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting the singular values of S(γ) greater than max(max(atol1,atol2), rtol*σ₁),  where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures. Note: This option is not available for sparse descriptor system models.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghanorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghanorm","text":"ghanorm(sys::DescriptorStateSpace, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hanorm, hs)\n\nCompute for a proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the Hankel norm hanorm = small G(lambda)_H and  the vector of Hankel singular values hs of the minimal realization of the system.\n\nFor a dense non-minimal system, the uncontrollable and unobservable finite and infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.  For a sparse system, the Hankel norm and Hankel singular values of a low order approximation of  the minimal order system are computed.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nghanorm(sys::SparseDescriptorStateSpace, abstol = 1e-12, reltol = 0, \n       maxiter = 100, shifts = missing, nshifts = 6, cyclic = false) -> (hanorm, hs)\n\nCompute for a proper and stable sparse descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), the Hankel norm hanorm = small G(lambda)_H and  the vector of Hankel singular values hs of a low order approximation of  the minimal order system.\n\nThe function ghanorm can be also used if sys has the type DescriptorStateSpaceExt.\n\nThe Hankel singular values hs are computed as the singular values of  the product R'*E*S, where S*S' and R*R' are the controlability and observability gramians, respectively,  with S and R low rank matrices.  For the computation of factors S and R, the low-rank ADI (LR-ADI) method with enhancements proposed in [1]  is employed.     \n\nFor the convergence tests used in the LR-ADI method, the keyword argument abstol (default: abstol = 1e-12)  can be used to specify the tolerance on the normalized residuals, while the keyword argument reltol (default: reltol = 0) can be used to specify the tolerance for the relative changes of the solution.  The keyword argument maxiter can be used to set the maximum number of iterations (default: maxiter = 100). The keyword argument nshifts specifies the desired number of shifts to be used in an iteration cycle (default: nshifts = 6).  The keyword argument shifts can be used to provide a pre-calculated set of complex conjugated shifts to be used to start the iterations (default: shifts = missing).     If cyclic = true, the cyclic low-rank method of [2] is used, with the pre-calculated shifts provided in the keyword argument shifts. \n\nNote: There is no check of the stability of the eigenvalues of the pencil A-λE implemented.  For an unstable model the LR-ADI methods does not converge and either an error message is issued or the maximum number of allowed iterations are reached. \n\nReferences:\n\n[1] P. Kürschner. Efficient Low-Rank Solution of Large-Scale Matrix Equations.      Dissertation, Otto-von-Guericke-Universität, Magdeburg, Germany, 2016. Shaker Verlag,\n\n[2] T. Penzl, A cyclic low-rank Smith method for large sparse Lyapunov equations,      SIAM J. Sci. Comput. 21 (4) (1999) 1401–1418.    \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gl2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gl2norm","text":"gl2norm(sys, h2norm = false, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the L2 norm of its transfer function  matrix G(λ). The L2 norm is infinite if G(λ) has poles on the stability domain boundary, i.e.,  on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  The L2 norm is also infinite for a continuous-time system having a gain at infinity greater than atolinf.  If the pencil A-λE has uncontrollable and/or unobservable eigenvalues on the boundary of the stability domain, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. \n\nTo check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli in the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf h2norm = true, the H2 norm is computed.  The H2 norm is infinite if the pole pencil A-λE has unstable zeros (i.e., unstable poles), or for a continuous-time system having a gain at infinity greater than atolinf.   To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system. \n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil A-λE.  For a discrete-time system or for a system with invertible E, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil A-λE. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atol3 specifies the absolute tolerance for the nonzero elements of B and is only used if h2norm = false for controllability tests of unstable eigenvalues.  The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at  λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gh2norm","page":"Descriptor system analysis","title":"DescriptorSystems.gh2norm","text":"gh2norm(sys::DescriptorStateSpace, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the H2 norm of its transfer function  matrix G(λ). The H2 norm is infinite, if G(λ) has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. If the pencil A-λE has uncontrollable and/or unobservable unstable eigenvalues on the boundary of the stability domain, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. \n\nTo check the stability, the eigenvalues of the pole pencil A-λE must have real parts less  than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nFor a dense continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil A-λE.  For a dense discrete-time system or for a system with invertible E, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil A-λE. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.    For a sparse system, the H2 norm of a low order approximation of  the minimal order system is computed.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The keyword argument atolinf is the absolute tolerance for the gain of G(λ) at λ = ∞.  The used default value is atolinf = 0.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol.  \n\n\n\n\n\ngh2norm((sys::SparseDescriptorStateSpace, abstol = 1e-12, reltol = 0, \n        maxiter = 100, shifts = missing, nshifts = 6, cyclic = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) the H2 norm of its transfer function  matrix G(λ). The H2 norm is infinite, if, for a continuous-time, the system has nonzero feedthrough matrix.\n\nThe function gh2norm can be also used if sys has the type DescriptorStateSpaceExt.\n\nThe H2-norm is computed as the Frobenius-norm of R'*B for a continuous-time system and of [R'*B;D] for a discrete-time system, where R*R' is the observability gramian, with R of low rank.  For the computation of R, the low-rank ADI (LR-ADI) method with enhancements proposed in [1] is employed.     \n\nFor the convergence tests used in the LR-ADI method, the keyword argument abstol (default: abstol = 1e-12)  can be used to specify the tolerance on the normalized residuals, while the keyword argument reltol (default: reltol = 0) can be used to specify the tolerance for the relative changes of the solution.  The keyword argument maxiter can be used to set the maximum number of iterations (default: maxiter = 100). The keyword argument nshifts specifies the desired number of shifts to be used in an iteration cycle (default: nshifts = 6).  The keyword argument shifts can be used to provide a pre-calculated set of complex conjugated shifts to be used to start the iterations (default: shifts = missing).     If cyclic = true, the cyclic low-rank method of [2] is used, with the pre-calculated shifts provided in the keyword argument shifts. \n\nNote: There is no check of the stability of the eigenvalues of the pencil A-λE implemented.  For an unstable model the LR-ADI methods does not converge and either an error message is issued or the maximum number of allowed iterations are reached. \n\nReferences:\n\n[1] P. Kürschner. Efficient Low-Rank Solution of Large-Scale Matrix Equations.      Dissertation, Otto-von-Guericke-Universität, Magdeburg, Germany, 2016. Shaker Verlag,\n\n[2] T. Penzl, A cyclic low-rank Smith method for large sparse Lyapunov equations,      SIAM J. Sci. Comput. 21 (4) (1999) 1401–1418.    \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.glinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.glinfnorm","text":"glinfnorm(sys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (linfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the L∞ norm linfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The L∞ norm is infinite if G(λ) has poles on the stability domain boundary,  i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  If the pencil A-λE has uncontrollable and/or unobservable eigenvalues on the boundary of the stability domain, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. \n\nTo check the lack of poles on the stability domain boundary, the eigenvalues of the pencil A-λE  must not have real parts in the interval [-β,β] for a continuous-time system or  must not have moduli within the interval [1-β,1+β] for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nIf hinfnorm = true, the H∞ norm is computed.  In this case, the stability of the zeros of A-λE is additionally checked and  the H∞ norm is infinite for an unstable system. To check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil A-λE.  For a discrete-time system or for a system with invertible E, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil A-λE. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nglinfnorm(sys::SparseDescriptorStateSpace, fmin::Real = 0.00001, fmax::Real = 10., fvals::Int = 100) -> (linfnorm, fpeak)\n\nCompute for a sparse descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the L∞ norm linfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The L∞ norm is evaluated as the largest singular value of the frequency response over a uniform grid of  fvals frequency values on the interval  [fmin, fmax]. \n\nNote: For a stable system the L∞ norm is equal to the H∞ norm. However, no stability check is implemented for sparse models. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.ghinfnorm","page":"Descriptor system analysis","title":"DescriptorSystems.ghinfnorm","text":"ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (hinfnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function  matrix G(λ)  the H∞ norm hinfnorm (i.e.,  the peak gain of G(λ)) and  the corresponding peak frequency fpeak, where the peak gain is achieved.  The H∞ norm is infinite if G(λ) has unstable poles.  If the pencil A-λE has uncontrollable and/or unobservable unstable eigenvalues, then a reduced order realization is determined first (see below) to eliminate these eigenvalues. \n\nTo check the stability, the eigenvalues of the pencil A-λE must have real parts less than -β for a continuous-time system or  have moduli less than 1-β for a discrete-time system, where β is the stability domain boundary offset. The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword argument rtolinf specifies the relative accuracy for the computed infinity norm.  The  default value used for rtolinf is 0.001.\n\nFor a continuous-time system sys with E singular, a reduced order realization is determined first, without  uncontrollable and unobservable finite and infinite eigenvalues of the pencil A-λE.  For a discrete-time system or for a system with invertible E, a reduced order realization is determined first, without  uncontrollable and unobservable finite eigenvalues of the pencil A-λE. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.   \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon   and n is the order of the system sys.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gnugap","page":"Descriptor system analysis","title":"DescriptorSystems.gnugap","text":"gnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (nugapdist, fpeak)\n\nCompute the ν-gap distance nugapdist between two descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) and the corresponding frequency fpeak (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. \n\nIf freq = missing, the resulting nugapdist satisfies 0 <= nugapdist <= 1.  The value nugapdist = 1 results, if the winding number is different of zero in which case fpeak = []. \n\nIf freq = ω, where ω is a given vector of real frequency values, the resulting nugapdist is a vector  of pointwise ν-gap distances of the dimension of ω, whose components satisfies 0 <= maximum(nugapdist) <= 1.  In this case, fpeak is the frequency for which the pointwise distance achieves its peak value.  All components of nugapdist are set to 1 if the winding number is different of zero in which case fpeak = [].\n\nThe stability boundary offset, β, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval [-β,β], while for a discrete-time system,  these are the finite zeros having moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nPencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A1, A2, B1, B2, C1, C2, D1 and D2, the absolute tolerance for the nonzero elements of E1 and E2,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the maximum of the orders of the systems sys1 and sys2.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol. \n\nThe keyword argument rtolinf specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for rtolinf is 0.00001.\n\nMethod: The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.\n\nReferences:\n\n[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.freqresp","page":"Descriptor system analysis","title":"DescriptorSystems.freqresp","text":" H = freqresp(sys, ω)\n\nCompute the frequency response H of the descriptor system sys = (A-λE,B,C,D) at the real frequencies ω. \n\nFor a system with p outputs and m inputs, and for N frequency values in ω, H is a p × m × N array, where H[:,:,i] contains the i-th value of the frequency response computed as C*((w[i]*E - A)^-1)*B + D, where w[i] = im*ω[i] for a continuous-time system and w[i] = exp(im*ω[i]*|Ts|)  for a discrete-time system with sampling time Ts. \n\nMethod: For an efficient evaluation of C*((w[i]*E - A)^-1)*B + D for many values of w[i], a preliminary  orthogonal coordinate transformation is performed such that for the input-output equivalent transformed  system sys = (At-λEt,Bt,Ct,Dt), the matrix w[i]*Et - At is upper Hessenberg.  This allows an efficient computation of the frequency response using the Hessenberg-form based  approach proposed in [1].\n\nReference:\n\n[1] Laub, A.J., \"Efficient Multivariable Frequency Response Computations\",     IEEE Transactions on Automatic Control, AC-26 (1981), pp. 407-408.\n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.timeresp","page":"Descriptor system analysis","title":"DescriptorSystems.timeresp","text":"timeresp(sys, u, t, x0 = 0; interpolation = \"zoh\", state_history = false, \n         fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (y, tout, x)\n\nCompute the time response of a proper descriptor system sys = (A-λE,B,C,D) to the input signals  described by u and t. The time vector t consists of regularly spaced time samples. The  matrix u has as many columns as the inputs of sys and its i-th row specifies  the input values at time t[i]. For discrete-time models, u should be sampled at the same rate as sys if sys.Ts > 0 and t must have all time steps equal to sys.Ts or can be set to an empty vector.  The vector x0 specifies the initial state vector at time t[1] and is set to zero when omitted. \n\nThe matrix y contains the resulting time history of the outputs of sys and  the vector tout contains the corresponding values of the time samples. The i-th row of y contains the output values at time tout[i].   If the keyword parameter value state_history = false is used, then the matrix x contains  the resulting time history of the state vector and its i-th row contains  the state values at time tout[i]. By default, the state history is not computed and x = nothing.\n\nFor continuous-time models, the input values are interpolated between samples. By default,  zero-order hold based interpolation is used. The linear interpolation method can be selected using  the keyword parameter interpolation = \"foh\".\n\nBy default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair (A,E)  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default), or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.stepresp","page":"Descriptor system analysis","title":"DescriptorSystems.stepresp","text":"stepresp(sys[, tfinal]; x0 = zeros(sys.nx), ustep = ones(sys.nu), timesteps = 100, \n         state_history = false, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (y, tout, x)\n\nCompute the step response of a proper descriptor system sys = (A-λE,B,C,D) to step input signals.  The final time tfinal, if not specified, is set to 10 for a continuous-time system or to abs(sys.Ts)*timesteps for a discrete-time system, where the keyword argument timesteps specifies the number of desired simulation time steps (default: timesteps = 100).  The keyword argument ustep is a vector with as many components  as the inputs of sys and specifies the desired amplitudes of step inputs (default: all components are set to 1).    The keyword argument x0 is a vector which specifies the initial state vector at time 0  and is set to zero when omitted. \n\nIf ns is the total number of simulation values, n the number of state components,  p the number of system outputs and m the number of system inputs, then the resulting ns×p×m array y contains the resulting time histories of the outputs of sys, such  that y[:,:,j] is the time response for the j-th input set to ustep[j] and the rest of inputs set to zero.   The vector tout contains the corresponding values of the time samples. The i-th row y[i,:,j] contains the output values at time tout[i] of the j-th step response.   If the keyword parameter value state_history = true is used, then the resulting ns×n×m arrayx contains  the resulting time histories of the state vector and  the i-th row x[i,:,j] contains the state values at time tout[i] of the j-th step response.   By default, the state history is not computed and x = nothing.\n\nBy default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair (A,E)  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default), or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"analysis.html#DescriptorSystems.gbalqual","page":"Descriptor system analysis","title":"DescriptorSystems.gbalqual","text":"qs = gbalqual(sys; SysMat = false)\n\nCompute the 1-norm based scaling quality of the matrices of the descriptor system sys = (A-λE,B,C).\n\nIf SysMat = false, the resulting qs is computed as \n\n    qs = max(qS(A),qS(E),qS(B),qS(C)) ,\n\nwhere qS(⋅) is the scaling quality measure defined in Definition 5.5 of [1] for  nonnegative matrices, extended to also cover matrices with zero rows or columns.  \n\nIf SysMat = true, the resulting qs is computed as \n\n    qs = qS(S) ,\n\nwhere S is the system matrix defined as        \n\n         S =  ( abs(A)+abs(E)  abs(B) )\n              (    abs(C)        0    )\n\nA large value of qs indicates a possibly poorly scaled state-space model.  For a standard system with E = I, the above formulas are used assuming E = 0.  \n\n[1] F.M.Dopico, M.C.Quintana and P. van Dooren,      \"Diagonal scalings for the eigenstructure of arbitrary pencils\", SIMAX, 43:1213-1237, 2022. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#System-utilities","page":"System utilities","title":"System utilities","text":"order   Order of a system.\nsize    Number of outputs and inputs of a descriptor system .\niszero   Checking whether the transfer function matrix of a descriptor system is zero.\nevalfr   Gain of the transfer function matrix at a single frequency value.\ndcgain   DC gain of a system.\nopnorm   L2- and L∞-norms of a descriptor system.\nrss   Generation of randomized standard state-space systems.\nrdss   Generation of randomized descriptor state-space systems.\ndsxvarsel   Building a descriptor systems by selecting a set of state variables.\ndssubset   Assigning a subsystem to a given descriptor system.\ndszeros   Setting a subsystem to zero.\ndssubsel   Selecting a subsystem according to a given zero-nonzero pattern.\ndsdiag   Building a k-times diagonal concatenation of a descriptor system. \ndss2full   Conversion of a descriptor state-space model to one with full matrices. \ndss2sparse  Conversion of a descriptor state-space model to one with sparse matrices. ","category":"section"},{"location":"dstools.html#DescriptorSystems.order","page":"System utilities","title":"DescriptorSystems.order","text":"n = order(r)\n\nDetermine the order n of a rational transfer function r as the maximum of degrees of its numerator and denominator polynomials (n is also known as the McMillan degree of r).  \n\n\n\n\n\nnx = order(sys)\n\nReturn the order nx of the descriptor system sys as the dimension of the state variable vector.  For improper or non-minimal systems, nx is less than the McMillan degree of the system.   \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.size","page":"System utilities","title":"Base.size","text":"size(sys) -> (p,m)\nsize(sys,1) -> p\nsize(sys,2) -> m\n\nReturn the number of outputs p and the number of inputs m of a descriptor system sys.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#Base.iszero","page":"System utilities","title":"Base.iszero","text":" iszero(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, fastrank = true)\n\nReturn true if the transfer function matrix of the descriptor system sys is zero.  For a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) it is checked  that the normal rank of G(λ) is zero, or equivalently (see [1]), that the normal rank of  the system matrix pencil \n\n          | A-λE | B | \n  S(λ) := |------|---|\n          |  C   | D |\n\nis equal to n, the order of the system sys. \n\nIf fastrank = true, the normal rank of S(λ) is evaluated by counting how many singular values of S(γ) have magnitudes  greater than max(max(atol1,atol2), rtol*σ₁), where σ₁ is the largest singular value of S(γ) and γ is a randomly generated value.  If fastrank = false, the rank is evaluated as nr + ni + nf + nl, where nr and nl are the sums of right and left Kronecker indices,  respectively, while ni and nf are the number of infinite and finite eigenvalues, respectively. The sums nr+ni and   nf+nl, are determined from an appropriate Kronecker-like form of the pencil S(λ), exhibiting the spliting of the right and left structures.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga,  On checking null rank conditions of rational matrices, 2018.  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.evalfr","page":"System utilities","title":"DescriptorSystems.evalfr","text":"Rval = evalfr(R,val)\n\nEvaluate the rational transfer function matrix R(λ) for λ = val. \n\n\n\n\n\nRval = evalfr(R; fval = 0)\n\nEvaluate the rational transfer function matrix R(λ) for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*abs(Ts)) for a discrete-time system,  with Ts the system sampling time.  \n\n\n\n\n\nrval = evalfr(r,val)\n\nEvaluate the rational transfer function  r(λ) for λ = val. \n\n\n\n\n\nrval = evalfr(r; fval = 0)\n\nEvaluate the rational transfer function  r(λ) for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*Ts) for a discrete-time system,  with Ts the system sampling time.   \n\n\n\n\n\nGval = evalfr(sys, val; atol1 = 0, atol2 = 0, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\nGval = evalfr(sys; fval = 0, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the value of the rational matrix G(λ) = C*inv(λE-A)*B+D for λ = val, where val = im*fval  for a continuous-time system or val = exp(im*fval*sys.Ts) for a discrete-time system.  The computed Gval has infinite entries if val is a pole (finite or infinite) of G(λ). If val is finite and val*E-A is singular or if val = Inf and E is singular,  then the entries of Gval are evaluated separately for minimal realizations of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dcgain","page":"System utilities","title":"DescriptorSystems.dcgain","text":"Gval = dcgain(sys; atol1, atol2, rtol, fast = true)\n\nEvaluate for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), Gval, the DC (or steady-state) gain. Gval is the value of the  rational matrix G(λ) for λ = val, where for a continuous-time system val = 0 and  for a discrete-time system val = 1. The computed Gval has infinite entries if val is a pole of G(λ). In this case (i.e., val*E-A is singular), the entries of Gval are evaluated separately for minimal realizations  of each input-output channel.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. \n\nThe computation of minimal realizations of individual input-output channels relies on pencil manipulation  algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\n\n\n\n\n","category":"function"},{"location":"dstools.html#LinearAlgebra.opnorm","page":"System utilities","title":"LinearAlgebra.opnorm","text":" opnorm(sys[, p = Inf]; kwargs...) \n opnorm(sys, 2; kwargs...) -> sysnorm\n opnorm(sys, Inf; kwargs...) -> (sysnorm, fpeak)\n opnorm(sys; kwargs...) -> (sysnorm, fpeak)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the L2 or L∞ system norm sysnorm induced by the vector p-norm, where valid values of p are 2 or Inf.  For the L∞ norm, the frequency fpeak is also returned, where G(λ) achieves its peak gain.  See gh2norm and ghinfnorm for a description of the allowed keyword arguments.  \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rss","page":"System utilities","title":"DescriptorSystems.rss","text":"sys = rss(n, p, m; disc = false, Ts, T = Float64, stable = false, nuc = 0, nuo = 0, randt = true)\n\nGenerate a randomized n+nuc+nuo-th order standard state-space system sys = (A,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T. The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true. For a discrete-time system a sample time Δ can be specified using the keyword argument Ts = Δ (default: Δ = -1, i.e., not specified).\n\nIf stable = true, the resulting system is stable, with A having all eigenvalues with negative real parts for a continuous-time system,  or with moduli less than one for a discrete-time system.  If nuc+nuo > 0, the system sys is non-minimal, with A having nuc uncontrollable and nuo unobservable eigenvalues.  If  randt = true, a randomly generated orthogonal or unitary similarity transformation is additionally applied.     If randt = false, the system matrices A, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable eigenvalues of A:\n\nA = diag(A1, A2, A3),  B = [B1; 0; B3], C = [C1 C2 0]\n\nwith the diagonal blocks A1, A2, A3 of orders n, nuc, and nuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.rdss","page":"System utilities","title":"DescriptorSystems.rdss","text":"sys = rdss(n, p, m; id = [ ], disc = false, Ts, T = Float64, stable = false, nfuc = 0, iduc = [ ], \n           nfuo = 0, iduo = [ ], randlt = true, randrt = true)\n\nGenerate a randomized descriptor state-space system sys = (A-λE,B,C,D) with p outputs and m inputs, with all matrices  randomly generated of type T.  The resulting sys is a continuous-time system if disc = false and a discrete-time system if disc = true.  For a discrete-time system a sample time Δ can be specified using the keyword argument Ts = Δ (default: Δ = -1, i.e., not specified).\n\nIf the vector id is nonempty, then id[i] specifies the order of the i-th infinite elementary divisor of the resulting pencil A-λE, which thus has n finite eigenvalues and ni = sum(id) infinite eigenvalues which are controllable and observable.  If nfuc+nfuo > 0, the system sys is non-minimal, with A having nfuc uncontrollable and nfuo unobservable finite eigenvalues.  If the vector iduc is a nonempty, then iduc[i] specifies the order of the i-th infinite elementary divisor  with uncontrollable infinite eigenvalues of the resulting pencil A-λE, which thus has niuc = sum(iduc) uncontrollable infinite eigenvalues.  If the vector iduo is a nonempty, then iduo[i] specifies the order of the i-th infinite elementary divisor with  unobservable infinite eigenvalues of the resulting pencil A-λE, which thus has niuo = sum(iduo) unobservable infinite eigenvalues.  If niuc+niuo > 0, the system sys is non-minimal, with A having niuc uncontrollable and niuo unobservable infinite eigenvalues. \n\nIt follows, that the resulting pencil A-λE has  n+nfuc+nfuo finite eigenvalues and ni+niuc+niuo infinite eigenvalues.  If stable = true, the proper part of the system sys is stable, with A having all finite eigenvalues with negative real parts  for a continuous-time system, or with moduli less than one for a discrete-time system. \n\nIf  randlt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E, and B from the left.     If  randrt = true, a randomly generated orthogonal or unitary transformation is additionally applied to A, E,  and C from the right.     If randlt = false and randrt = false, the system matrices A, E, B, and C result in block stuctured forms exhibitting the  uncontrollable and unobservable finite and infinite eigenvalues of A-λE:\n\nA-λE = diag(A1-λE1, A2-λE2, A3-λE3, A4-λE4, A5-λE5, A6-λE6),  \nB = [B1; B2; 0; 0; B5; B6 ], \nC = [C1 C2 C3 C4 0 0]\n\nwith the diagonal blocks A1, A2, A3, A4, A5, A6 of orders n, ni, nfuc, niuc, nfuo and niuo, respectively. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dsxvarsel","page":"System utilities","title":"DescriptorSystems.dsxvarsel","text":"sysr = dsxvarsel(sys,ind)\n\nConstruct for the descriptor system sys = (A-λE,B,C,D) of order n the descriptor system   sysr = (A[ind,ind]-λE[ind,ind],B[ind,:],C[:,ind],D) of order nr = length(ind),  by selecting the state variables of sys with indices specified by ind.  If ind is a permutation vector of length n, then sysr has the same transfer function matrix as sys  and permuted state variables. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dssubset","page":"System utilities","title":"DescriptorSystems.dssubset","text":" res = dssubset(sys, subsys, rows, cols; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nAssign for a given descriptor system sys = (A-λE,B,C,D) its subsystem sys[row,cols] to subsys and  return the modified system in res. rows and cols are indices, vectors of indices, index ranges, : or  any combinations of them. \n\nIf minimal = true (default), an irreducible realization of the resulting system res is computed, otherwise a possibly non-minimal realization is returned if minimal = false. \n\nThe underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dszeros","page":"System utilities","title":"DescriptorSystems.dszeros","text":" res = dszeros(sys, rows, cols; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nSet for a given descriptor system sys = (A-λE,B,C,D) its subsystem sys[row,cols] to zero and  return the modified system in res. rows and cols are indices, vectors of indices, index ranges, : or  any combinations of them. \n\nIf minimal = true (default), an irreducible realization of the resulting system res is computed, otherwise a possibly non-minimal realization is returned if minimal = false. \n\nThe underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dssubsel","page":"System utilities","title":"DescriptorSystems.dssubsel","text":" res = dssubsel(sys, S; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nSelect for a given descriptor system sys = (A-λE,B,C,D) its subsystem res corresponding to the zero-one pattern specified by  the binary structure matrix S. If G(λ) is the transfer function matrix of sys, then the transfer function matrix of res is the element-wise product S .* G(λ). \n\nIf minimal = true (default), an irreducible realization of the resulting system res is computed, otherwise a possibly non-minimal realization is returned if minimal = false. \n\nThe underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dsdiag","page":"System utilities","title":"DescriptorSystems.dsdiag","text":" sysdiag = dsdiag(sys, k)\n\nBuild for a given descriptor system sys and non-negative integer k a descriptor system sysdiag obtained as sysdiag = diag( sys, ..., sys ) (i.e., k-times repeated application of append).   \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dss2full","page":"System utilities","title":"DescriptorSystems.dss2full","text":"sysf = dss2full(sys)\n\nConvert the descriptor system representation sys = (A-λE,B,C,D) to an equivalent one sysf with full matrices.   \n\n\n\n\n\n","category":"function"},{"location":"dstools.html#DescriptorSystems.dss2sparse","page":"System utilities","title":"DescriptorSystems.dss2sparse","text":"syss = dss2sparse(sys)\n\nConvert the descriptor system representation sys = (A-λE,B,C,D) to an equivalent one syss with sparse matrices.   \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#Simplification-of-descriptor-system-models","page":"Simplification of descriptor system models","title":"Simplification of descriptor system models","text":"gminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngir_lrtran   Irreducible realization of descriptor systems with determination of left and right projections.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.\ngss2ss   Conversion to SVD-like forms without non-dynamic modes.\ndss2ss   Conversion of descriptor systems to standard form.","category":"section"},{"location":"order_reduction.html#DescriptorSystems.gminreal","page":"Simplification of descriptor system models","title":"DescriptorSystems.gminreal","text":"sysr = gminreal(sys; contr = true, obs = true, noseig = true, prescale, fast = true, \n                atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nIf prescale = true, a preliminary balancing of the descriptor system matrices is performed.  The default setting is prescale = gbalqual(sys) > 10000, where gbalqual(sys) is the  scaling quality of the descriptor system model sys (see gbalqual). \n\nThe least possible order nr is achieved if contr = true, obs = true and nseig = true.  Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced.\n\nIf nseig = false, then condition (5) on the lack of simple infinite eigenvalues is not enforced. \n\nTo enforce conditions (1)-(4), orthogonal similarity transformations are performed on  the matrices of the original realization (A-λE,B,C,D) to obtain an irreducible realization using structured pencil reduction algorithms, as the fast versions of the reduction techniques of the  full row rank pencil [B A-λE] and full column rank pencil [A-λE;C] proposed in [1].  To enforce condition (5), residualization formulas (see, e.g., [2, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E. The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gir","page":"Simplification of descriptor system models","title":"DescriptorSystems.gir","text":"sysr = gir(sys; finite = true, infinite = true, contr = true, obs = true, noseig = false,\n           fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) of order n a reduced order descriptor system   sysr = (Ar-λEr,Br,Cr,Dr) of order nr ≤ n such that sys and sysr have the same transfer function matrix, i.e., \n\n         -1                    -1\n C*(λE-A)  *B + D = Cr*(λEr-Ar)  *Br + Dr .\n\nThe least possible order nr is achieved if finite = true, infinite = true, contr = true,  obs = true and nseig = true. Such a realization is called minimal and satisfies:\n\n (1) rank[Br Ar-λEr] = nr for all finite λ (finite controllability)\n\n (2) rank[Br Er] = nr (infinite controllability)\n\n (3) rank[Ar-λEr; Cr] = nr for all finite λ (finite observability)\n\n (4) rank[Er; Cr] = nr (infinite observability)\n\n (5) Ar-λEr has no simple infinite eigenvalues\n\nA realization satisfying only conditions (1)-(4) is called irreducible and is computed by default. \n\nSome reduction steps can be skipped by appropriately selecting the keyword arguments contr, obs, finite, infinite and nseig. \n\nIf contr = false, then the controllability conditions (1) and (2) are not enforced.  If contr = true and finite = true, then the finite controllability condition (1) is enforced.  If contr = true and finite = false, then the finite controllability condition (1) is not enforced.  If contr = true and infinite = true, then the infinite controllability condition (2) is enforced.  If contr = true and infinite = false, then the infinite controllability condition (2) is not enforced. \n\nIf obs = false, then observability condition (3) and (4) are not enforced. If obs = true and finite = true, then the finite observability condition (3) is enforced. If obs = true and finite = false, then the finite observability condition (3) is not enforced. If obs = true and infinite = true, then the infinite observability condition (4) is enforced. If obs = true and infinite = false, then the infinite observability condition (4) is not enforced.\n\nIf nseig = true, then condition (5) on the lack of simple infinite eigenvalues is also enforced. \n\nTo enforce conditions (1)-(4), the Procedure GIR in [1, page 328] is employed, which performs  orthogonal similarity transformations on the matrices of the original realization (A-λE,B,C,D)  to obtain an irreducible realization using structured pencil reduction algorithms.  To enforce condition (5), residualization formulas (see, e.g., [1, page 329]) are employed which involves matrix inversions. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of matrices A, B, C, D, the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.  The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys.   The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n[1] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gir_lrtran","page":"Simplification of descriptor system models","title":"DescriptorSystems.gir_lrtran","text":"gir_lrtran(sys; ltran = false, rtran = false, finite = true, infinite = true, contr = true, obs = true, \n         noseig = false, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ) -> (sysr, Q, Z)\n\nThis is a special version of the function gir to additionally determine the left and right  transformation matrices Q = [Q1 Q2] and Z = [Z1 Z2], respectively, such that the matrices Ar, Er, Br and Cr of the resulting descriptor system sysr = (Ar-λEr,Br,Cr,Dr) are given by Ar = Q1'*A*Z1, Er = Q1'*E*Z1, Br = Q1'*B, Cr = C*Z1,  where the number of columns of Q1 and Z1 is equal to the order of matrix Ar. Q and Z result orthogonal if noseig = false.  Q = nothing if ltran = false and Z = nothing if rtran = false.  See gir for details on the rest of keyword parameters.\n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gbalmr","page":"Simplification of descriptor system models","title":"DescriptorSystems.gbalmr","text":"gbalmr(sys::DescriptorStateSpace, pext = 0, balance = false, matchdc = false, ord = missing, offset = √ϵ,\n       atolhsv = 0, rtolhsv = nϵ, atolmin = atolhsv, rtolmin = rtolhsv, \n       atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true) -> (sysr, hs)\n\nCompute for a dense proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nIf the keyword argument pext is nonzero, then the trailing pext system outputs are not included in the determination of the reduced order model. However, all state coordinate transformations are also performed on these outputs. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nTo check the stability of the eigenvalues of the pencil A-λE, the real parts of eigenvalues must be less than -β for a continuous-time system or  the moduli of eigenvalues must be less than 1-β for a discrete-time system, where β is the stability domain boundary offset.   The offset  β to be used can be specified via the keyword parameter offset = β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D,   the absolute tolerance for the nonzero elements of E,   and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is nϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nIf E is singular, the uncontrollable infinite eigenvalues of the pair (A,E) and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false. \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n\n\n\n\ngbalmr(sys::SparseDescriptorStateSpace, pext = 0, balance = false, matchdc = false, ord = missing, \n       atolhsv = 0, rtolhsv = nϵ, atolmin = atolhsv, rtolmin = rtolhsv, abstol = 1e-12, reltol = 0, \n       Trsave = false, Tlsave = false, maxiter = 100, shifts = missing, cyclic = false) -> (sysr, hs, info)\n\nCompute for a sparse proper and stable descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a reduced order realization sysr = (Ar-λEr,Br,Cr,Dr) and the vector hs of decreasingly  ordered relevant Hankel singular values of the system sys. If balance = true, a balancing-based approach is used to determine a reduced order minimal realization  of the form sysr = (Ar-λI,Br,Cr,Dr). For a continuous-time system sys, the resulting realization sysr is balanced, i.e., the controllability and observability grammians are equal and diagonal.  If additonally matchdc = true, the resulting sysr is computed using state rezidualization formulas  (also known as singular perturbation approximation) which additionally preserves the DC-gain of sys.  In this case, the resulting realization sysr is balanced (for both continuous- and discrete-time systems). If balance = false, an enhanced accuracy balancing-free approach is used to determine the  reduced order system sysr. \n\nThe function gbalmr can be also used if sys has the type DescriptorStateSpaceExt.\n\nIf the keyword argument pext is nonzero, then the trailing pext system outputs are not included in the determination of the reduced order model. However, all state coordinate transformations are also performed on these outputs. \n\nIf ord = nr, the resulting order of sysr is min(nr,nrmin), where nrmin is the order of a minimal   realization of sys determined as the number of Hankel singular values exceeding max(atolmin,rtolmin*HN), with HN, the Hankel norm of G(λ). If ord = missing, the resulting order is chosen as the number of Hankel  singular values exceeding max(atolhsv,rtolhsv*HN). \n\nMethod:  For the order reduction of a standard system, the balancing-free method of [1] or  the balancing-based method of [2] are used. For a descriptor system the balancing related order reduction  methods of [3] are used. To preserve the DC-gain of the original system, the singular perturbation  approximation method of [4] is used in conjunction with the balancing-based or balancing-free approach of [5]. \n\nThe controlability and observability gramians are determined in factored forms S*S' and R*R', respectively, where S and R are low rank matrices. The Hankel singular values hs are computed as the singular values of the product R'*E*S. For the computation of factors S and R, the low-rank ADI (LR-ADI) method with enhancements proposed in [6]  are employed.   The projection matrices Tl and Tr used to generate the matrices  of the reduced order models as Er = Tl'*E*Tr, Ar = Tl'*A*Tr, Br = Tl'*B, Cr = C*Tr,  are computed from the singular value decomposition of the product R'*E*S.  If the keyword arguments Tlsave = true and Trsave = true, then the named touple info contains in info.Tl and info.Tr  the respective projection matrices.     \n\nFor the convergence tests used in the LR-ADI method, the keyword argument abstol (default: abstol = 1e-12)  can be used to specify the tolerance on the normalized residuals, while the keyword argument reltol (default: reltol = 0) can be used to specify the tolerance for the relative changes of the solution.  The keyword argument maxiter can be used to set the maximum number of iterations (default: maxiter = 100). The keyword argument nshifts specifies the desired number of shifts to be used in an iteration cycle (default: nshifts = 6).  The keyword argument shifts can be used to provide a pre-calculated set of complex conjugated shifts to be used to start the iterations (default: shifts = missing).     If cyclic = true, the cyclic low-rank method of [7] is used, with the pre-calculated shifts provided in the keyword argument shifts. \n\nNote: There is no check of the stability of the eigenvalues of the pencil A-λE implemented.  For an unstable model the LR-ADI methods does not converge and either an error message is issued or the maximum number of allowed iterations are reached. \n\nReferences\n\n[1] A. Varga.      Efficient minimal realization procedure based on balancing.     In A. El Moudni, P. Borne, and S.G. Tzafestas (Eds.),      Prepr. of the IMACS Symp. on Modelling and Control of Technological      Systems, Lille, France, vol. 2, pp.42-47, 1991.\n\n[2] M. S. Tombs and I. Postlethwaite.      Truncated balanced realization of a stable non-minimal state-space      system. Int. J. Control, vol. 46, pp. 1319–1330, 1987.\n\n[3] T. Stykel.      Gramian based model reduction for descriptor systems.      Mathematics of Control, Signals, and Systems, 16:297–319, 2004.\n\n[4] Y. Liu Y. and B.D.O. Anderson      Singular Perturbation Approximation of Balanced Systems,     Int. J. Control, Vol. 50, pp. 1379-1405, 1989.\n\n[5] Varga A.     Balancing-free square-root algorithm for computing singular perturbation approximations.     Proc. 30-th IEEE CDC,  Brighton, Dec. 11-13, 1991, Vol. 2, pp. 1062-1065.\n\n[6] P. Kürschner. Efficient Low-Rank Solution of Large-Scale Matrix Equations.      Dissertation, Otto-von-Guericke-Universität, Magdeburg, Germany, 2016. Shaker Verlag,\n\n[7] T. Penzl, A cyclic low-rank Smith method for large sparse Lyapunov equations,      SIAM J. Sci. Comput. 21 (4) (1999) 1401–1418.    \n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.gss2ss","page":"Simplification of descriptor system models","title":"DescriptorSystems.gss2ss","text":"gss2ss(sys; Eshape = \"ident\", atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ) -> (sysr, r)\n\nConvert the descriptor system sys = (A-λE,B,C,D) to an input-output equivalent descriptor system realization  sysr = (Ar-λEr,Br,Cr,Dr) without non-dynamic modes and having the same transfer function matrix. The resulting Er is in the SVD-like form Er = blockdiag(E1,0), with E1 an r × r nonsingular matrix,  where r is the rank of E.\n\nThe keyword argument Eshape specifies the shape of E1 as follows:\n\nif Eshape = \"ident\" (the default option), E1 is an identity matrix of order r and if E is nonsingular,  then the resulting system sysr is a standard state-space system;\n\nif Eshape = \"diag\", E1 is a diagonal matrix of order r, where the diagonal elements are the  decreasingly ordered nonzero singular values of E;\n\nif Eshape = \"triu\", E1 is an upper triangular nonsingular matrix of order r. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\nIf Eshape = \"triu\", the reductions of E and A are performed using rank decisions based on rank revealing  QR-decompositions with column pivoting.  If Eshape = \"ident\" or Eshape = \"diag\" the reductions are performed using the more reliable SVD-decompositions.\n\n\n\n\n\n","category":"function"},{"location":"order_reduction.html#DescriptorSystems.dss2ss","page":"Simplification of descriptor system models","title":"DescriptorSystems.dss2ss","text":" dss2ss(sys[, x0 = 0]; state-mapping = false, simple_infeigs = true, fast = true, atol1, atol2, rtol) \n           -> (sysr, xr0, Mx, Mu)\n\nReturn for a proper descriptor system sys = (A-λE,B,C,D) and initial state x0,  the equivalent reduced order standard system sysr = (Ar-λI,Br,Cr,Dr) and  the corresponding reduced consistent initial state xr0.\n\nIf state_mapping = true, the state mapping matrices Mx and Mu are also determined such that  the values x(t) and xr(t) of the state vectors of the systems sys and sysr, respectively, and the input vector u(t) are related as x(t) = Mx*xr(t)+Mu*u(t). In this case, higher order uncontrollable infinite eigenvalues can be eliminated if simple_infeigs = false.\n\nBy default, state_mapping = false and Mx = nothing and Mu = nothing.  In this case, higher order uncontrollable or unobservable infinite eigenvalues  can be eliminated if simple_infeigs = false. \n\nBy default, simple_infeigs = true, and simple infinite eigenvalues for the pair (A,E) are assumed and eliminated. \n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default), or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#Factorization-of-descriptor-system-transfer-function-matrices","page":"Factorization of descriptor system transfer function matrices","title":"Factorization of descriptor system transfer function matrices","text":"grcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngnrcf  Normalized right coprime factorization.\ngnlcf   Normalized left coprime factorization.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.\ngrsfg   Right spectral factorization of γ^2*I-G'*G. \nglsfg   Left spectral factorization of γ^2*I-G*G'. ","category":"section"},{"location":"factorizations.html#DescriptorSystems.grcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcf","text":"grcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper right coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg < 0,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Bn = Bm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The Procedure GRCF from [2] is implemented, which represents an extension of the recursive factorization approach of [1] to cope with   infinite eigenvalues. All infinite poles are assigned to finite real values.  If evals is missing or does not contain a sufficient   number of real values, then a part or all of infinite eigenvalues of A-λE are   assigned to the value specified by sdeg. The pairs (An,En) and (Am,Em)  result in generalized Schur form with both An and Am quasi-upper triangular   and En and Em either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcf","text":"glcf(sys; smarg, sdeg, evals, mindeg = false, mininf = false, fast = true, \n     atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (Am-λEm,Bm,Cm,Dm) of its stable and proper left coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices.  The resulting matrix pairs (An,En) and (Am,Em) are in (generalized) Schur form.  The stability domain Cs of poles is defined by  the keyword argument smarg for the stability margin, as follows:  for a continuous-time system sys, Cs is the set of complex numbers  with real parts at most smarg,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most smarg < 1 (i.e., the interior of a disc of radius smarg centered in the origin).  If smarg is missing, then the employed default values are smarg = -sqrt(eps)  for a continuous-time system and smarg = 1-sqrt(eps) for a discrete-time system. \n\nThe keyword argument sdeg specifies the prescribed stability degree for the  assigned eigenvalues of the factors. If both sdeg and smarg are missing,  then the employed  default values are sdeg = -0.05 for a continuous-time system and  sdeg = 0.95 for a discrete-time system, while if smarg is specified,  then sdeg = smarg is used. \n\nThe keyword argument evals is a real or complex vector, which contains a set  of finite desired eigenvalues for the factors.  For a system with real data, evals must be a self-conjugated complex set  to ensure that the resulting factors are also real. \n\nIf mindeg = false, both factors sysn and sysm have descriptor realizations with the same order and with An = Am, En = Em and Cn = Cm. If mindeg = true,  the realization of sysm is minimal. The number of (finite) poles of sysm is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then An-λEn and Am-λEm may have simple infinite eigenvalues. If mininf = true,  then An-λEn and Am-λEm have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A and n is the order of the system sys.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λE is performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  The dual of Procedure GRCF from [2] is used, which represents an extension of the recursive factorization approach of [1] to cope with   infinite poles. All infinite eigenvalues are assigned to finite real values.  If evals is missing or does not contain a sufficient  number of real values, then a part or all of infinite eigenvalues of A-λE are  assigned to the value specified by sdeg.   The pairs (An,En) and (Am,Em)  result in generalized Schur form with  both An and Am quasi-upper triangular  and En and Em either both upper triangular or both UniformScalings.\n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.grcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grcfid","text":"grcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  right coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in (generalized) Schur form.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Bni = Bmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B,   and the relative tolerance for the nonzero elements of A, E and B.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1]  is used (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glcfid","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glcfid","text":"glcfid(sys; mindeg = false, mininf = false, fast = true, offset = sqrt(ϵ), \n       atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = n*ϵ) -> (sysni, sysmi)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysni = (Ani-λEni,Bni,Cni,Dni) and sysmi = (Ami-λEmi,Bmi,Cmi,Dmi) of its  left coprime factorization with inner denominator. If sys, sysni and sysmi   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices and the denominator factor M(λ) inner.  The resulting matrix pairs (Ani,Eni) and (Ami,Emi) are in Schur forms.  The system sys must not have poles on the boundary of the stability domain Cs. In terms of eigenvalues, this requires for a continuous-time system, that  A-λE must not have controllable eigenvalues on the imaginary axis  (excepting simple infinite eigenvalues), while for a discrete-time system,   A-λE must not have controllable eigenvalues on the unit circle centered  in the origin. \n\nTo assess the presence of poles on the boundary of Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf mindeg = false, both factors sysni and sysmi have descriptor realizations with the same order and with Ani = Ami, Eni = Emi and Cni = Cmi. If mindeg = true,  the realization of sysmi is minimal. The number of (finite) poles of sysmi is  equal to the number of unstable finite poles of sys. \n\nIf mininf = false, then Ani-λEni and Ami-λEmi may have simple infinite eigenvalues. If mininf = true,  then Ani-λEni and Ami-λEmi have no simple infinite eigenvalues. Note that the removing of simple infinite eigenvalues involves matrix inversions. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nThe preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: An extension of the recursive factorization approach of [1] is used  to the dual system (see [2] for details). The pairs (Ani,Eni) and (Ami,Emi) result in generalized Schur form with both Ani and Ami quasi-upper triangular  and Eni and Emi either both upper triangular or both UniformScalings. \n\nReferences:\n\n[1] A. Varga. Computation of coprime factorizations of rational matrices.     Linear Algebra and Its Applications, vol. 271, pp.88-115, 1998.\n\n[2] A. Varga. On recursive computation of coprime factorizations of rational matrices.      arXiv:1703.07307, https://arxiv.org/abs/1703.07307, 2020. (to appear in Linear Algebra and Its Applications)\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.gnrcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.gnrcf","text":"gnrcf(sys; fast = true, ss = false, \n     atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (An-λEn,Bn,Cm,Dm) of its normalized right coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = N(λ)*inv(M(λ)), with N(λ) and M(λ) proper and stable transfer  function matrices and [N(λ);M(λ)] inner. The resulting En = I if ss = true. \n\nPencil reduction algorithms are employed which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,    and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A  and n is the order of the system sys. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol.\n\nMethod: Pencil reduction algorithms are employed to determine the inner range space R(λ) of the  transfer function matrix [G(λ); I] using the method described in [1], which is based on  the reduction algorithm of [2]. Then the factors N(λ) and M(λ) result from the partitioning of R(λ) as R(λ) = [N(λ);M(λ)]. \n\nReferences:\n\n[1] Varga, A.     A note on computing the range of rational matrices.      arXiv:1707.0048, https://arxiv.org/abs/1707.0048, 2017.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.gnlcf","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.gnlcf","text":"gnlcf(sys; fast = true, ss = false, \n     atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysn, sysm)\n\nCompute for the descriptor system sys = (A-λE,B,C,D), the factors  sysn = (An-λEn,Bn,Cn,Dn) and sysm = (An-λEn,Bm,Cn,Dm) of its normalized right coprime factorization. If sys, sysn and sysm   have the transfer function matrices G(λ), N(λ) and M(λ), respectively, then G(λ) = inv(M(λ))*N(λ), with N(λ) and M(λ) proper and stable transfer  function matrices and [N(λ) M(λ)] coinner. The resulting En = I if ss = true. \n\nPencil reduction algorithms are employed which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2 and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C and D, the absolute tolerance for the nonzero elements of E,    and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the machine epsilon of the element type of A  and n is the order of the system sys. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol.\n\nMethod: Pencil reduction algorithms are employed to determine the coinner coimage space R(λ) of the  transfer function matrix [G(λ) I] using the dual of method described in [1], which is based on  the reduction algorithm of [2]. Then the factors N(λ) and M(λ) result from the partitioning of R(λ) as R(λ) = [N(λ) M(λ)]. \n\nReferences:\n\n[1] Varga, A.     A note on computing the range of rational matrices.      arXiv:1707.0048, https://arxiv.org/abs/1707.0048, 2017.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.giofac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.giofac","text":"giofac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full row rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Gi[:,1:r](λ)*Go(λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full row rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended QR-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple info contains (nrank, nfuz, niuz), where info.nrank = r,  the normal rank of G(λ), info.nfuz is the number of finite zeros of syso on  the boundary of Cs, and info.niuz is the number of infinite zeros of syso.  info.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and B,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the system pencil [A-λE B; C D] is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the factorization algorithm of [1] is used, while  for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307-2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.goifac","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.goifac","text":"goifac(sys; atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol, \n       fast = true, minphase = true, offset = sqrt(ϵ)) -> (sysi, syso, info)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the square inner factor sysi = (Ai-λEi,Bi,Ci,Di) with the transfer function matrix Gi(λ)  and the minimum-phase quasi-outer factor or the full column rank factor syso = (Ao-λEo,Bo,Co,Do)  with the transfer function matrix Go(λ) such that\n\n G(λ) = Go(λ)*Gi[1:r,:](λ)    (*),\n\nwhere r is the normal rank of G(λ). The resulting proper and stable inner factor satisfies  Gi'(λ)*Gi(λ) = I. If sys is stable (proper), then the resulting syso is stable (proper).  The resulting factor Go(λ) has full column rank r. Depending on the selected factorization option, if minphase = true, then Go(λ) is minimum phase,  excepting possibly zeros on the  boundary of the appropriate stability domain Cs, or if minphase = false, then Go(λ)  contains all zeros of G(λ), in which case (*) is the extended RQ-like factorization of G(λ). For a continuous-time system sys, the stability domain Cs is defined as the set of  complex numbers with real parts at most -β,  while for a discrete-time system sys, Cs is the set of complex numbers with  moduli at most 1-β (i.e., the interior of a disc of radius 1-β centered in the origin).  The boundary offset  β to be used to assess the stability of zeros and their number  on the boundary of Cs can be specified via the keyword parameter offset = β. Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe resulting named triple info contains (nrank, nfuz, niuz), where info.nrank = r,  the normal rank of G(λ), info.nfuz is the number of finite zeros of syso on  the boundary of Cs, and info.niuz is the number of infinite zeros of syso.  info.nfuz is set to missing if minphase = false. \n\nNote: syso may generally contain a free inner factor, which can be eliminated by  removing the finite unobservable eigenvalues. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A and C,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of B and D,   and the relative tolerance for the nonzero elements of A, E, B, C and D.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol. \n\nFor the assessment of zeros, the dual system pencil transpose([A-λE B; C D]) is reduced to a  special Kronecker-like form (see [2]). In this reduction, the  performed rank decisions are based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  For a continuous-time system, the dual system is formed and the factorization algorithm  of [1] is used, while for a discrete-time system, the factorization algorithm of [1] is used.\n\nReferences:\n\n[1] C. Oara and A. Varga.     Computation of the general inner-outer and spectral factorizations.     IEEE Trans. Autom. Control, vol. 45, pp. 2307–2325, 2000.\n\n[2] C. Oara.     Constructive solutions to spectral and inner–outer factorizations      respect to the disk. Automatica,  41, pp. 1855–1866, 2005. \n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.grsfg","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.grsfg","text":" sysf = grsfg(sys, γ; fast = true, stabilize = true, offset = β, \n              atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) and small γ  G(λ)_, the minimum-phase right spectral factor sysf = (Af-λEf,Bf,Cf,Df) with the transfer-function matrix F(λ), such that F(λ)'*F(λ) = γ^2*I-G(λ)'*G(λ). If stabilize = true (the default), a preliminary stabilization of sys is performed.  In this case, sys must not have poles on the imaginary-axis in the continuous-time case or  on the unit circle in the discrete-time case. If stabilize = false, then no preliminary stabilization is performed. In this case, sys must be stable.\n\nTo assess the presence of poles on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf stabilize = true, a preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nMethod: Extensions of the factorization approaches of [1] are used.\n\nReferences:\n\n[1] K. Zhou, J. C. Doyle, and K. Glover. Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"factorizations.html#DescriptorSystems.glsfg","page":"Factorization of descriptor system transfer function matrices","title":"DescriptorSystems.glsfg","text":" sysf = glsfg(sys, γ; fast = true, stabilize = true, offset = β, \n              atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) and small γ  G(λ)_, the minimum-phase right spectral factor sysf = (Af-λEf,Bf,Cf,Df) with the transfer-function matrix F(λ), such that F(λ)*F(λ)' = γ^2*I-G(λ)*G(λ)'. If stabilize = true (the default), a preliminary stabilization of sys is performed.  In this case, sys must not have poles on the imaginary-axis in the continuous-time case or  on the unit circle in the discrete-time case. If stabilize = false, then no preliminary stabilization is performed. In this case, sys must be stable.\n\nTo assess the presence of poles on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time system, then the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nIf stabilize = true, a preliminary separation of finite and infinite eigenvalues of A-λEis performed  using rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively,  the absolute tolerance for the nonzero elements of A,  the absolute tolerance for the nonzero elements of E,  the absolute tolerance for the nonzero elements of C,   and the relative tolerance for the nonzero elements of A, E and C.   The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon.  The keyword argument atol can be used  to simultaneously set atol1 = atol, atol2 = atol, atol3 = atol.\n\nMethod: Extensions of the factorization approaches of [1] are used.\n\nReferences:\n\n[1] K. Zhou, J. C. Doyle, and K. Glover. Robust and Optimal Control. Prentice Hall, 1996.\n\n\n\n\n\n","category":"function"},{"location":"rtf.html#Building-rational-transfer-functions","page":"Building rational transfer functions","title":"Building rational transfer functions","text":"RationalTransferFunction  Construction of rational transfer function object.\nrtf  Building rational transfer functions.","category":"section"},{"location":"rtf.html#DescriptorSystems.RationalTransferFunction","page":"Building rational transfer functions","title":"DescriptorSystems.RationalTransferFunction","text":"r = RationalTransferFunction(num::AbstractPolynomial, den::AbstractPolynomial, Ts:Real)\n\nConstruct a rational transfer function model r from its numerator and denominator polynomials  num and den, respectively, and sampling time Ts. \n\nIf r::RationalTransferFunction{T,λ,P <: Polynomial(T,λ),Ts} is a rational transfer function system model  object defined as r(λ) = num(λ)/den(λ), where  num(λ) and den(λ) are polynomials  with coefficients in T and with the indeterminate λ, and Ts is the sampling time, then:\n\nr.num is the numerator polynomial num(λ); \n\nr.den is the denominator polynomial den(λ). \n\nThe sampling time Ts can have the following values:\n\nTs = 0 for a continuous-time system and           λ = s is the complex variable in the Laplace transform; \nTs > 0 or Ts = -1 for a discrete-time system and           λ = z is the complex variable in the Z-transform;           Ts = -1 indicates a discrete-time system with an unspecified sampling time.\n\nThe sampling time can be obtained as r.Ts. The symbol (or variable) used for the indeterminate λ is the common symbol used for the  indeterminates of the polynomials num(λ) and den(λ) and can be obtained as r.var.  The roots of the numerator polynomial num(λ) (also called zeros of r(λ)) can be obtained as r.zeros, while the roots of the denominator polynomial den(λ)  (also called poles of r(λ)) can be obtained as r.poles.  The ratio of the leading polynomial coefficients of num(λ) and den(λ)  (also called gain of r(λ)) can be obtained as r.gain.\n\n\n\n\n\n","category":"type"},{"location":"rtf.html#DescriptorSystems.rtf","page":"Building rational transfer functions","title":"DescriptorSystems.rtf","text":"r = rtf(num, den; Ts = rts, var = rvar )\n\nCreate the rational transfer function r(λ) = num(λ)/den(λ) with the polynomials num(λ) and den(λ),  sampling time rts and variable name rvar, representing  the transfer function of a single-input single-output system of the form\n\nY(λ) = r(λ) U(λ),\n\nwhere U(λ) and Y(λ) are the Laplace or Z transformed input u(t) and output y(t), respectively,  and λ = s, the complex variable in the Laplace transform, if rts = 0, or  λ = z,   the complex variable in the Z transform, if rts ≠ 0.  Both num and den can be real or complex numbers, or vectors of  polynomial coefficients in decreasing order of degrees as well. \n\nThe resulting r is such that r.Ts = rts (default rts = 0) and r.var = rvar. The default value of rvar is rvar = Polynomials.indeterminate(num) if num is a polynomial,  rvar = Polynomials.indeterminate(den) if num is a number and den is a polynomial, and rvar = :s if both num and den are numbers.\n\n\n\n\n\nr = rtf(f; Ts = rts, var = rvar)\n\nCreate the rational transfer function r(λ) = f(λ) with sampling time rts and variable name rvar such that: \n\n(1) if f(λ) is a rational transfer function, then r.Ts = rts (default rts = f.Ts) and r.var = rvar (default rvar = f.var);\n\n(2) if f(λ) is a rational function, then r.Ts = rts (default rts = 0) and r.var = rvar (default rvar = Polynomials.indeterminate(f.num));\n\n(3) if f(λ) is a polynomial, then r.Ts = rts (default rts = 0) and r.var = rvar (default rvar = Polynomials.indeterminate(f));\n\n(4) if f(λ) is a ral or complex number, then r.Ts = rts (default rts = 0) and r.var = rvar (default rvar = :s);\n\n\n\n\n\nr = rtf(var; Ts = rts)\nr = rtf('s') or r = rtf('z'; Ts = rts) \nr = rtf(\"s\") or r = rtf(\"z\"; Ts = rts) \nr = rtf(:s) or r = rtf(:z; Ts = rts)\n\nCreate the rational transfer function r(λ) = λ, such that r.var and r.Ts are set as follows:\n\n(1) `r.var = :s` and `r.Ts = 0` if `var = 's'`, or `var = \"s\"` or `var = :s` ;\n\n(2) `r.var = :z` and `r.Ts = rts` if `var = 'z'`, or `var = \"z\"` or `var = :z`;\n\n(3) `r.var = var` and `r.Ts = rts` (default `rts = 0.`) otherwise.\n\n\n\n\n\nr = rtf(z, p, k; Ts = rts, var = rvar)\n\nCreate from the roots (zeros) z, poles p, gain k, sampling time rts and variable name rvar the rational transfer function r(λ) = k*num(λ)/den(λ), where num(λ) and den(λ) are monic polynomials with roots equal z and p, respectively, and such that r.Ts = rts (default rts = 0)  and r.var = rvar (default rvar = :s if Ts = 0 or rvar = :z if Ts ≠ 0). \n\n\n\n\n\n","category":"function"},{"location":"conversions.html#Basic-conversions-of-descriptor-system-models","page":"Basic conversions of descriptor system models","title":"Basic conversions of descriptor system models","text":"gprescale  Balancing of a descriptor system.\nc2d  Discretization of a system.\ndss2rm  Rational transfer function matrix of a descriptor system.\ndss2pm  Polynomial transfer function matrix of a descriptor system.\ngbilin  Generalized bilinear transformation of a descriptor system.","category":"section"},{"location":"conversions.html#DescriptorSystems.gprescale","page":"Basic conversions of descriptor system models","title":"DescriptorSystems.gprescale","text":"  gprescale(sys; withB = true, withC = true) -> (sysbal, D1, D2)\n\nBalance a descriptor system sys = (A-λE,B,C,D) by reducing the 1-norm of the matrix \n\n         S =  ( abs(A)+abs(E)  abs(B) )\n              (    abs(C)        0    )\n\nby row and column balancing using diagonal matrices D1 and D2 to make the rows and columns of \n\n              diag(D1,I)  * S * diag(D2,I)\n\nas close in norm as possible.\n\nThe balancing can be performed optionally on the following  particular matrices:   \n\n    S = abs(A)+abs(E),             if withB = false and withC = false ,\n    S = ( abs(A)+abs(E)  abs(B) ), if withC = false,    \n    S = ( abs(A)+abs(E) ),         if withB = false .\n        (   abs(C)     )\n\nThe diagonal elements of the resulting D1 and D2 are the nearest integer powers of 2 resulting from the optimal diagonal scaling determined from a modified version of the algorithm of [1].  For a standard system with E = I, D1 = inv(D2) and D2 is computed using an extension of the scaling approach implemented in the LAPACK family *GEBAL.f. \n\nThis function is merely an interface to the functions lsbalance! of the  MatrixPencils package. \n\n[1] F.M.Dopico, M.C.Quintana and P. van Dooren,      \"Diagonal scalings for the eigenstructure of arbitrary pencils\", SIMAX, 43:1213-1237, 2022. \n\n\n\n\n\n","category":"function"},{"location":"conversions.html#DescriptorSystems.c2d","page":"Basic conversions of descriptor system models","title":"DescriptorSystems.c2d","text":"c2d(sysc::DescriptorStateSpace, Ts, meth = \"zoh\"; x0, u0, standard = true, fast = true, prewarp_freq = freq, \n           state_mapping = false, simple_infeigs = true, \n           atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysd, xd0, Mx, Mu)\n\nCompute for the continuous-time descriptor system sysc = (A-sE,B,C,D) with the proper  transfer function matrix Gc(λ) and for a sampling time Ts, the corresponding discretized descriptor system sysd = (Ad-zEd,Bd,Cd,Dd) with the transfer function matrix Gd(z)  according to the selected discretization method specified by meth.  The keyword argument standard specifies the option to compute a standard state-space realization  of sysd (i.e., with Ed = I), if standard = true (default),  or a descriptor system realization if standard = false.  The keyword argument simple_infeigs = true indicates that only simple infinite eigenvalues  of the pair (A,E) are to be expected (default). The setting simple_infeigs = false indicates that possible uncontrollable or unobservable  higher order infinite generalized eigenvalues of the pair (A,E) are present and have to be removed.  xd0 is the mapped initial condition of the state of the discrete-time system sysd determined from the  initial conditions of the state x0 and input u0 of the continuous-time system sysc.  The keyword argument state_mapping = true specifies the option to compute the state mapping matrices Mx and Mu such that  the values xc(t) and xd(t) of the system state vectors of the continuous-time system sysc and of the discrete-time system sysd, respectively, and of the input vector u(t) are related as xc(t) = Mx*xd(t)+Mu*u(t).    If state_mapping = false (the default option), then Mx = nothing and Mu = nothing.\n\nThe following discretization methods can be performed by appropriately selecting meth:\n\n\"zoh\"     - zero-order hold on the inputs (default); \n\n\"foh\"     - linear interpolation of inputs (also known as first-order hold);\n\n\"impulse\" - impulse-invariant discretization; \n\n\"Tustin\"  - Tustin transformation (also known as trapezoidal integration): a nonzero prewarping frequency\n            `freq` can be specified using the keyword parameter `prewarp_freq = freq` to ensure \n            `Gd(exp(im*freq*Ts)) = Gc(im*freq)`.\n\nThe underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true (default), or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\nc2d(sysc::SparseDescriptorStateSpace, Ts; x0, u0, prewarp_freq = freq, \n           state_mapping = false) -> (sysd, xd0, Mx, Mu)\n\nCompute for the sparse continuous-time descriptor system sysc = (A-sE,B,C,D) with the proper  transfer function matrix Gc(λ) and for a sampling time Ts, the corresponding discretized descriptor system sysd = (Ad-zEd,Bd,Cd,Dd) with the transfer function matrix Gd(z)  corresponding to the Tustin's discretization.  xd0 is the mapped initial condition of the state of the discrete-time system sysd determined from the  initial conditions of the state x0 and input u0 of the continuous-time system sysc.  The keyword argument state_mapping = true specifies the option to compute the state mapping matrices Mx and Mu such that  the values xc(t) and xd(t) of the system state vectors of the continuous-time system sysc and of the discrete-time system sysd, respectively, and of the input vector u(t) are related as xc(t) = Mx*xd(t)+Mu*u(t).    If state_mapping = false (the default option), then Mx = nothing and Mu = nothing.\n\nThe Tustin transformation (also known as trapezoidal integration) is employed. If a nonzero prewarping frequency freq is specified using the keyword parameter prewarp_freq = freq, then the matching condition   Gd(exp(im*freq*Ts)) = Gc(im*freq) is fulfilled.\n\n\n\n\n\nrd = c2d(rc, Ts, meth = \"zoh\"; prewarp_freq = freq, atol = 0, rtol = n*ϵ)\n\nCompute for the continuous-time rational transfer function rc and for a sampling time Ts,  the corresponding discretized rational transfer function rd    according to the selected discretization method specified by meth. \n\nThe following discretization methods can be performed by appropriately selecting meth:\n\n\"zoh\"     - zero-order hold on the inputs (default); \n\n\"foh\"     - linear interpolation of inputs (also known as first-order hold);\n\n\"impulse\" - impulse-invariant discretization; \n\n\"matched\" - matched pole-zero method (see [1]); \n\n\"Tustin\"  - Tustin transformation (also known as trapezoidal integration): a nonzero prewarping frequency\n            `freq` can be specified using the keyword parameter `prewarp_freq = freq` to ensure \n            `rd(exp(im*freq*Ts)) = rc(im*freq)`.\n\nThe keyword arguments atol and rtol specify, respectively,  the absolute and relative tolerances, respectively,  for the nonzero coefficients of the numerator and denominator polynomials of  rc.   The default relative tolerance is n*ϵ, where n is the order of rc  (i.e., the maximum degree of the numerator and denominator polynomials) and  ϵ is the working machine epsilon. \n\nReferences:\n\n[1] G.F. Franklin, D.J. Powell and  M.L. Workman, Digital Control of Dynamic Systems (3rd Edition), Prentice Hall, 1997.\n\n\n\n\n\nRd = c2d(Rc, Ts, meth = \"zoh\"; prewarp_freq = freq, atol = 0, rtol = n*ϵ)\n\nCompute for the continuous-time rational transfer function matrix Rc and for a sampling time Ts,  the corresponding discretized rational transfer function matrix Rd    according to the selected discretization method specified by meth. \n\nThe following discretization methods can be performed by appropriately selecting meth:\n\n  \"zoh\"     - zero-order hold on the inputs (default); \n\n  \"foh\"     - linear interpolation of inputs (also known as first-order hold);\n\n  \"impulse\" - impulse-invariant discretization; \n  \n  \"matched\" - matched pole-zero method (see [1]); \n  \n  \"Tustin\"  - Tustin transformation (also known as trapezoidal integration): a nonzero prewarping frequency\n              `freq` can be specified using the keyword parameter `prewarp_freq = freq` to ensure \n              `Rd(exp(im*freq*Ts)) = Rc(im*freq)`.\n\nThe keyword arguments atol and rtol specify, respectively,  the absolute and relative tolerances, respectively,  for the nonzero coefficients of the numerator and denominator polynomials of the elements of Rc.   The default relative tolerance is 10*ϵ, where ϵ is the working machine epsilon. \n\nReferences:\n\n[1] G.F. Franklin, D.J. Powell and  M.L. Workman, Digital Control of Dynamic Systems (3rd Edition), Prentice Hall, 1997.\n\n\n\n\n\n","category":"function"},{"location":"conversions.html#DescriptorSystems.dss2rm","page":"Basic conversions of descriptor system models","title":"DescriptorSystems.dss2rm","text":"R = dss2rm(sys; fast = true, atol = 0, atol1 = atol, atol2 = atol, gaintol = atol, rtol = min(atol1,atol2) > 0 ? 0 : n*ϵ, val)\n\nBuild for the descriptor system sys = (A-λE,B,C,D) the rational matrix R(λ) = C*inv(λE-A)*B+D representing the  transfer function matrix of the system sys.  \n\nThe keyword arguments atol1 and atol2 specify the absolute tolerances for the elements of A, B, C, D, and,   respectively, of E, and rtol specifies the relative tolerances for the nonzero elements of A, B, C, D and E. The default relative tolerance is n*ϵ, where n is the maximal dimension of state, input and output vectors,  and ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and gaintol = atol. \n\nThe keyword argument gaintol specifies the threshold for the magnitude of the nonzero elements of the gain matrix  C*inv(γE-A)*B+D, where γ = val if val is a number or γ is a randomly chosen complex value of unit magnitude,  if val = missing. Generally, val should not be a zero of any of entries of R.\n\nMethod: Each rational entry of R(λ) is constructed from its numerator and denominator polynomials corresponding to its finite zeros, finite poles and gain using the method of [1]. \n\nReferences:\n\n[1] A. Varga Computation of transfer function matrices of generalized state-space models.      Int. J. Control, 50:2543–2561, 1989.\n\n\n\n\n\n","category":"function"},{"location":"conversions.html#DescriptorSystems.dss2pm","page":"Basic conversions of descriptor system models","title":"DescriptorSystems.dss2pm","text":"P = dss2pm(sys; fast = true, atol = 0, atol1 = atol, atol2 = atol, gaintol = 0, rtol = min(atol1,atol2) > 0 ? 0 : n*ϵ, val)\n\nBuild for the descriptor system sys = (A-λE,B,C,D) the polynomial matrix P(λ) = C*inv(λE-A)*B+D representing the  transfer function matrix of the system sys.  \n\nThe keyword arguments atol1 and atol2 specify the absolute tolerances for the elements of A, B, C, D, and,   respectively, of E, and rtol specifies the relative tolerances for the nonzero elements of A, B, C, D and E. The default relative tolerance is n*ϵ, where n is the maximal dimension of state, input and output vectors,  and ϵ is the working machine epsilon. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and gaintol = atol.  \n\nThe keyword argument gaintol specifies the threshold for the magnitude of the nonzero elements of the gain matrix  C*inv(γE-A)*B+D, where γ = val if val is a number or γ is a randomly chosen complex value of unit magnitude,  if val = missing. Generally, val should not be a zero of any of entries of P.\n\nMethod: Each entry of P(λ) is constructed from the polynomial corresponding  to its finite zeros and gain using the method of [1]. \n\nReferences:\n\n[1] A. Varga Computation of transfer function matrices of generalized state-space models.      Int. J. Control, 50:2543–2561, 1989.\n\n\n\n\n\n","category":"function"},{"location":"conversions.html#DescriptorSystems.gbilin","page":"Basic conversions of descriptor system models","title":"DescriptorSystems.gbilin","text":"gbilin(sys, g; compact = true, minimal = false, standard = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (syst, ginv)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) and  a first degree real rational transfer function g = g(δ),  the descriptor system realization syst = (At-δEt,Bt,Ct,Dt) of G(g(δ)) corresponding to the bilinear transformation  λ = g(δ) = (aδ+b)/(cδ+d). For a continuous-time transfer function g(δ), δ = s, the complex variable in  the Laplace transform, while for a discrete-time transfer function,   δ = z, the complex variable in the Z-transform. syst inherits the sampling-time of sys1.  sysi1 is the transfer function ginv(λ) = (d*λ-b)/(-c*λ+a) representing the inverse of the bilinear transformation g(δ)  (i.e., g(ginv(λ)) = 1).\n\nThe keyword argument compact can be used to specify the option to compute a compact descriptor realization without non-dynamic modes, if compact = true (the default option) or to disable the ellimination of non-dynamic modes if compact = false. \n\nThe keyword argument minimal specifies the option to compute minimal descriptor realization, if  minimal = true, or a nonminimal realization if minimal = false (the default option).\n\nThe keyword argument standard specifies the  option to compute a standard state-space (if possible) realizations of syst, if standard = true (default), or a descriptor system realization if standard = false.  \n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\ngbilin(sys::SparseDescriptorStateSpace, g) -> (syst, ginv)\n\nCompute for the sparse descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) and  a first degree real rational transfer function g = g(δ),  the descriptor system realization syst = (At-δEt,Bt,Ct,Dt) of G(g(δ)) corresponding to the bilinear transformation  λ = g(δ) = (aδ+b)/(cδ+d). For a continuous-time transfer function g(δ), δ = s, the complex variable in  the Laplace transform, while for a discrete-time transfer function,   δ = z, the complex variable in the Z-transform. syst inherits the sampling-time of sys1.  sysi1 is the transfer function ginv(λ) = (d*λ-b)/(-c*λ+a) representing the inverse of the bilinear transformation g(δ)  (i.e., g(ginv(λ)) = 1).\n\n\n\n\n\n","category":"function"},{"location":"model_matching.html#Solution-of-model-matching-problems","page":"Solution of model-matching problems","title":"Solution of model-matching problems","text":"gnehari  Generalized Nehari approximation.\nglinfldp  Solution of the least distance problem.\ngrasol   Approximate solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglasol   Approximate solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).","category":"section"},{"location":"model_matching.html#DescriptorSystems.gnehari","page":"Solution of model-matching problems","title":"DescriptorSystems.gnehari","text":"gnehari(sys[, γ]; fast = true, offset = β, \n                atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, σ1)\n\nCompute for the descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ) the optimal or suboptimal Nehari approximation sysx = (Ax-λEx,Bx,Cx,Dx)  with the transfer function matrix X(λ). The optimal Nehari approximation  X(λ) satisfies\n\n      G(lambda) - X(lambda) _infty =  G^*_u(lambda) _H = sigma_1\n\nwhere small G_u(lambda) is the proper antistable part of G(λ). The resulting σ_1 is the Hankel-norm of small G^*_u(lambda)  (also the L∞-norm of the optimal approximation error).  For a given γ  σ_1, the suboptimal approximation satisfies\n\n      G(lambda) - X(lambda) _infty leq gamma \n\nThe Nehari approximation is stable if  G(λ) has no poles on the boundary of the stability domain  Cs. In the continuous-time, Cs is the set of complex numbers with negative real parts and its boundary  is the extended imaginary axis (containig also the poit at infinity), while, in the discrete-time case, Cs is the set complex number with moduli less than one and its boundary is the unit circle centered in the origin. \n\nTo assess the presence of poles in Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time system, the stable poles in   Cs have real parts less than or equal to β,  while for a discrete-time system, they have moduli less than or equal to 1+β.  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision.  For a negative values of β (e.g., β = -sqrt(ϵ)), an extended stability domain corresponding to the closure of Cs  is used instead of Cs. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: Let G(λ) = Gs(λ) + Gu(λ) be an additive decomposition of G(λ)  such that Gs(λ) has only poles in the closure of Cs (or its closure if β < 0)  and Gu(λ) is the antistable part having only  unstable poles.   The Hankel-norm approximation methods of [1] and [2],  with extensions for descriptor systems, are used to compute a stable Nehari approximation Gn(λ) of the unstable part Gu(λ) and the resulting solution is computed as X(λ) = Gs(λ) + Gn(λ).\n\nReferences:\n\n[1] K. Glover. All optimal Hankel-norm approximations of linear        multivariable systems and their L∞ error bounds,        Int. J. Control, vol. 39, pp. 1115-1193, 1984.\n\n[2] M. G. Safonov, R. Y. Chiang, and D. J. N. Limebeer.         Optimal Hankel model reduction for nonminimal systems.         IEEE Trans. Automat. Control, vol. 35, pp. 496–502, 1990.\n\n\n\n\n\n","category":"function"},{"location":"model_matching.html#DescriptorSystems.glinfldp","page":"Solution of model-matching problems","title":"DescriptorSystems.glinfldp","text":"glinfldp(sys1, sys2, [, γ]; nehari = false, reltol = 0.0001, fast = true, offset = β, \n         atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, mindist)\n\nDetermine for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrices G_1(λ) and G_2(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the solution of the 2-block L∞ least distance problem (LDP)\n\n      textmindist = min G_1(λ)-X(λ) mid   G_2(λ) _infty \n\nmindist is the achieved minimum distance corresponding to the optimal solution.  If sys2 = [], an 1-block LDP is solved.  sys1 and sys2 must not have poles on the boundary of the stability domain Cs. It is assumed that sys2 has no poles on the boundary of the stability domain (see below). The resulting solution is stable, provided sys1 has no poles on the boundary  of the stability domain as well. \n\nIf  small γ  G_2(λ)_infty is a desired sub-optimality degree, then the  γ-suboptimal LDP \n\n     textmindist = G_1(λ)-X(λ) mid G_2(λ) _infty  γ\n\nis solved and mindist is the achieved suboptimal distance.\n\nThe call with\n\nglinfldp(sys[, m2[, γ]]; nehari = false, fast = true, offset = β, \n         atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, mindist)\n\nuses the compound descriptor system sys = (A-λE,[B1 B2],C,[D1 D2]),  where B2 has m2 columns, to define   the descriptor systems sys1 = (A-λE,B1,C,D1) and sys2 = (A-λE,B2,C,D2) (i.e., A1-λE1 = A2-λE2 = A-λE and C1 = C2 = C).  If m2 = 0, an 1-block LDP is solved.  sys2 must not have poles on the boundary of the stability domain Cs.\n\nIf nehari = true, the optimal or suboptimal Nehari approximation is used to solve the LDP. If nehari = false (default), the optimal solution is computed using the γ-iteration [1]. \n\nThe keyword argument reltol specifies the relative tolerance for the desired accuracy of γ-iteration.  The iterations are performed until the current estimations of maximum γ_u and minimum γ_l of   the optimal distance γ_o, γ_l leq γ_o leq γ_u, satisfies \n\n     γ_u-γ_l leq textreltol * textgap \n\nwhere gap is the original gap (internally determined).\n\nTo assess the presence of poles on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time setting,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discete-time setting, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance  for the nonzero elements of A and E. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sys. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod: The approach of [1] is used for the solution of the 2-block least distance problem. Necessary conditions for solvability of the LDP with a stable solution is that sys1 and sys2 have no poles  on the boundary of the stability domain Cs.\n\nReferences: [1] C.-C. Chu, J. C. Doyle, and E. B. Lee     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.\n\n\n\n\n\n","category":"function"},{"location":"model_matching.html#DescriptorSystems.grasol","page":"Solution of model-matching problems","title":"DescriptorSystems.grasol","text":"grasol(sysg, sysf[, γ]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, \n       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, info)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and sysf = (Af-λEf,Bf,Cf,Df)  with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the approximate solution of the linear rational equation G(λ)X(λ) = F(λ), which achieves the minimum error norm small textmindist = min G(λ)X(λ) - F(λ).  The resulting X(λ) has all poles stable or lying on the boundary of the stability domain Cs.  If L2sol = false (default) then the L∞-norm optimal solution is computed, while if L2sol = true the L2-norm optimal solution is computed.  sysg and sysf must not have poles on the boundary of the stability domain Cs.\n\nIf  γ > 0 is a desired sub-optimality degree, then the γ-suboptimal model-matching problem\n\n     textmindist = G(λ)X(λ) - F(λ)   γ\n\nis solved and mindist is the achieved suboptimal distance.\n\nThe call with\n\ngrasol(sysgf[, mf[, γ]]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, \n       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, info)\n\nuses the compound descriptor system sysgf = (A-λE,[Bg Bf],C,[Dg Df]),  where Bf and Df have mf columns, to define   the descriptor systems sysg = (A-λE,Bg,C,Dg) and sysf = (A-λE,Bf,C,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Cg = Cf = C).  sysgf must not have poles on the boundary of the stability domain Cs.\n\nIf nehari = true, the optimal or suboptimal Nehari approximation is used to  compute a L∞-suboptimal solution of the underlying least-distance problem (LDP). If nehari = false (default), the L∞-optimal solution is computed using the γ-iteration  in the underlying LDP [2]. \n\nIf mindeg = true, a minimum order solution is determined (if possible),  while if mindeg = false (default) a particular solution of non-minimal order is determined. \n\nThe resulting named tuple info contains additional information: info.nrank is the normal rank of G(λ),  info.nr is the number of freely assignable poles of the solution X(λ),   info.mindist is the achieved approximation error norm and  info.nonstandard is true for a non-standard problem, with G(λ)  having zeros on the boundary of the stability domain, and false for a standard problem, when G(λ) has no zeros on the boundary  of the stability domain.  \n\nThe keyword argument reltol specifies the relative tolerance for the desired accuracy of  the γ-iteration employed to solve the underlying least-distance problem.   The iterations are performed until the current estimations of maximum γ_u and minimum γ_l of   the optimal distance satisfies  small γ_u-γ_l leq textreltol * textgap, where gap is the initial estimation of the error gap.\n\nTo assess the presence of poles on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time setting,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time setting, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe vector poles specified as a keyword argument, can be used to specify the desired poles of sysx alternatively to or jointly with enforcing a desired stability degree sdeg of poles. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of Ag, Af, A, Bg, Bf, Cg, Cf, Dg, Df,   the absolute tolerance for the nonzero elements of Eg, Ef, and the relative tolerance  for the nonzero elements of all above matrices. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysg. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  An extension of the approach of [1] to descriptor systems is used.\n\nReferences:\n\n[1]  B. A. Francis. A Course in H-infinity Theory,         Vol. 88 of Lecture Notes in Control and Information Sciences,         Springer-Verlag, New York, 1987.\n\n[2] C.-C. Chu, J. C. Doyle, and E. B. Lee.     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.\n\n\n\n\n\n","category":"function"},{"location":"model_matching.html#DescriptorSystems.glasol","page":"Solution of model-matching problems","title":"DescriptorSystems.glasol","text":"glasol(sysg, sysf[, γ]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, \n       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, info)\n\nDetermine for the descriptor systems sysg = (Ag-λEg,Bg,Cg,Dg) and  sysf = (Af-λEf,Bf,Cf,Df) with the transfer function matrices G(λ) and F(λ),  respectively, the descriptor system sysx with the transfer function matrix X(λ)  such that X(λ) is the approximate solution of the linear rational equation X(λ)G(λ) = F(λ), which achieves the minimum error norm small textmindist = min X(λ)G(λ) - F(λ).  The resulting X(λ) has all poles stable or lying on the boundary of the stability domain Cs.  If L2sol = false (default) then the L∞-norm optimal solution is computed, while if L2sol = true the L2-norm optimal solution is computed.  sysg and sysf must not have poles on the boundary of the stability domain Cs.\n\nIf  γ > 0 is a desired sub-optimality degree, then the γ-suboptimal model-matching problem\n\n     textmindist = X(λ)G(λ) - F(λ)   γ\n\nis solved and mindist is the achieved suboptimal distance.\n\nThe call with\n\nglasol(sysgf[, pf[, γ]]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, \n       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -> (sysx, info)\n\nuses the compound descriptor system sysgf = (A-λE,B,[Cg; Cf],[Dg; Df]),  where Cf and Df have pf rows, to define   the descriptor systems sysg = (A-λE,B,Cg,Dg) and sysf = (A-λE,B,Cf,Df) (i.e., Ag-λEg = Af-λEf = A-λE and Bg = Bf = B).  sysgf must not have poles on the boundary of the stability domain Cs.\n\nIf nehari = true, the optimal or suboptimal Nehari approximation is used to solve the  underlying least-distance problem (LDP). If nehari = false (default), the optimal solution is computed using the γ-iteration  in the underlying LDP [2]. \n\nIf mindeg = true, a minimum order solution is determined (if possible),  while if mindeg = false (default) a particular solution of non-minimal order is determined. \n\nThe resulting named tuple info contains additional information: info.nrank is the normal rank of G(λ),  info.nl is the number of freely assignable poles of the solution X(λ),   info.mindist is the achieved approximation error norm and  info.nonstandard is true for a non-standard problem, with G(λ)  having zeros on the boundary of the stability domain, and false for a standard problem, when G(λ) has no zeros on the boundary  of the stability domain.  \n\nThe keyword argument reltol specifies the relative tolerance for the desired accuracy of  the γ-iteration employed to solve the underlying least-distance problem.   The iterations are performed until the current estimations of maximum γ_u and minimum γ_l of   the optimal distance satisfies  small γ_u-γ_l  textreltol* textgap, where gap is the initial estimation of the error gap.\n\nTo assess the presence of poles on the boundary of the stability domain Cs, a boundary offset  β  can be specified via the keyword parameter offset = β.  Accordingly, for a continuous-time setting,  the boundary of Cs contains the complex numbers with real parts within the interval [-β,β],  while for a discrete-time setting, the boundary of Cs contains the complex numbers with moduli within the interval [1-β,1+β].  The default value used for β is sqrt(ϵ), where ϵ is the working machine precision. \n\nThe vector poles specified as a keyword argument, can be used to specify the desired poles of sysx alternatively to or jointly with enforcing a desired stability degree sdeg of poles. \n\nThe keyword arguments atol1, atol2, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of Ag, Af, A, Bg, Bf, Cg, Cf, Dg, Df,   the absolute tolerance for the nonzero elements of Eg, Ef, and the relative tolerance  for the nonzero elements of all above matrices. The default relative tolerance is n*ϵ, where ϵ is the working machine epsilon  and n is the order of the system sysg. The keyword argument atol can be used  to simultaneously set atol1 = atol and atol2 = atol. \n\nThe rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if fast = true or the more reliable SVD-decompositions if fast = false.\n\nMethod:  An extension of the approach of [1] to descriptor systems is used.\n\nReferences:\n\n[1]  B. A. Francis. A Course in H-infinity Theory,         Vol. 88 of Lecture Notes in Control and Information Sciences,         Springer-Verlag, New York, 1987.\n\n[2] C.-C. Chu, J. C. Doyle, and E. B. Lee.     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.\n\n\n\n\n\n","category":"function"},{"location":"operations.html#Basic-operations-on-system-models","page":"Basic operations on system models","title":"Basic operations on system models","text":"inv  Inversion of a system.\nldiv   Left division for two systems (also overloaded with \\).\nrdiv   Right division for two systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a system (also overloaded with adjoint and ').\nadjoint  Building the adjoint of a system.","category":"section"},{"location":"operations.html#Base.inv","page":"Basic operations on system models","title":"Base.inv","text":"sysinv = inv(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, checkinv = true)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ), a descriptor realization of its inverse system sysinv = (Ai-λEi,Bi,Ci,Di), such that the transfer function matrix Ginv(λ) of sysinv is the inverse of G(λ) (i.e., G(λ)*Ginv(λ) = I).  The realization of sysinv is determined using inversion-free formulas and the invertibility condition is checked, unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, B, C, D, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A, B, C, D and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ldiv","page":"Basic operations on system models","title":"DescriptorSystems.ldiv","text":"sysldiv = ldiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, checkinv = true)\nsysldiv = sys1 \\ sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysldiv = (Ai-λEi,Bi,Ci,Di) of sysldiv = inv(sys1)*sys2, whose transfer-function matrix Gli(λ) represents the result of the left division Gli(λ) = inv(G1(λ))*G2(λ).  The realization of sysldiv is determined using inversion-free formulas and the invertibility condition for sys1 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.rdiv","page":"Basic operations on system models","title":"DescriptorSystems.rdiv","text":"sysrdiv = rdiv(sys1, sys2; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, checkinv = true)  \nsysrdiv = sys1 / sys2\n\nCompute for the descriptor systems sys1 = (A1-λE1,B1,C1,D1) with the transfer function matrix G1(λ) and  sys2 = (A2-λE2,B2,C2,D2) with the transfer function matrix G2(λ), a descriptor realization  sysrdiv = (Ai-λEi,Bi,Ci,Di) of sysrdiv = sys1*inv(sys2), whose transfer-function matrix Gri(λ) represents the result of the right division Gri(λ) = G1(λ)*inv(G2(λ)).  The realization of sysrdiv is determined using inversion-free formulas and the invertibility condition for sys2 is checked,  unless checkinv = false.\n\nThe keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2,  the absolute tolerance for the nonzero elements of E1 and E2,  and the relative tolerance for the nonzero elements of A1, B1, C1, D1, A2, B2, C2, D2, E1 and E2.   The default relative tolerance is n*ϵ, where n is the maximum of orders of the square matrices A1 and A2,  and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.gdual","page":"Basic operations on system models","title":"DescriptorSystems.gdual","text":"sysdual = gdual(sys, rev = false) \nsysdual = transpose(sys, rev = false)\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its dual system  sysdual = (Ad-λEd,Bd,Cd,Dd), where Ad = transpose(A), Ed = transpose(E), Bd = transpose(C),  Cd = transpose(B) and Dd = transpose(D),  such that the transfer function matrix Gdual(λ) of sysdual is the transpose of G(λ)  (i.e., Gdual(λ) = transpose(G(λ))). \n\nIf rev = true, the tranposition is combined with the reverse permutation of the state variables, such that sysdual = (P*Ad*P-λP*Ed*P,P*Bd,Cd*P,Dd), where P is the permutation matrix with ones down the second diagonal. \n\n\n\n\n\n","category":"function"},{"location":"operations.html#DescriptorSystems.ctranspose","page":"Basic operations on system models","title":"DescriptorSystems.ctranspose","text":"sysconj = ctranspose(sys) \nsysconj = sys'\n\nCompute the conjugate transpose (or adjoint) of a descriptor system (see adjoint). \n\n\n\n\n\n","category":"function"},{"location":"operations.html#Base.adjoint","page":"Basic operations on system models","title":"Base.adjoint","text":" rt = adjoint(r)\n\nCompute the adjoint rt(λ) of the rational transfer function r(λ) such that for  r(λ) = num(λ)/den(λ) we have:\n\n(1) `rt(λ) = conj(num(-λ))/conj(num(-λ))`, if `r.Ts = 0`; \n\n(2) `rt(λ) = conj(num(1/λ))/conj(num(1/λ))`, if `r.Ts = -1` or `r.Ts > 0`.\n\n\n\n\n\nsysconj = adjoint(sys) \nsysconj = sys'\n\nCompute for a descriptor system sys = (A-λE,B,C,D) with the transfer function matrix G(λ),  the descriptor system realization of its adjoint (also called conjugate transpose) system  sysconj = (Ac-λEc,Bc,Cc,Dc), such that the transfer function matrix Gconj(λ) of sysconj  is the appropriate conjugate transpose of G(λ), as follows:  for a continuous-time system with λ = s, Gconj(s) := transpose(G(-s)), while  for a discrete-time system with λ = z, Gconj(z) := transpose(G(1/z)).\n\n\n\n\n\n","category":"function"},{"location":"dss.html#Building-descriptor-system-state-space-models","page":"Building descriptor system state-space models","title":"Building descriptor system state-space models","text":"DescriptorStateSpace  Descriptor state-space object.\ndss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix data from a descriptor state-space model.\ndssdatafull   Extraction of full matrix data of a descriptor state-space model.","category":"section"},{"location":"dss.html#DescriptorSystems.DescriptorStateSpace","page":"Building descriptor system state-space models","title":"DescriptorSystems.DescriptorStateSpace","text":"DescriptorStateSpace{T}(A::Matrix{T}, E::Union{Matrix{T},UniformScaling}, \n                        B::Matrix{T}, C::Matrix{T}, D::Matrix{T},  \n                        Ts::Real) where T <: Number\n\nConstruct a descriptor state-space model from a quintuple of matrices (A,E,B,C,D) and a sampling time Ts.\n\nIf SYS::DescriptorStateSpace{T} is a descriptor system model object  defined by the 4-tuple SYS = (A-λE,B,C,D), then:\n\nSYS.A is the nx × nx state matrix A with elements of type T. \n\nSYS.E is the nx × nx descriptor matrix E with elements of type T.  For a standard state-space system SYS.E = I, the UniformScaling of type Bool. \n\nSYS.B is the nx × nu system input matrix B with elements of type T. \n\nSYS.C is the ny × nx system output matrix C with elements of type T. \n\nSYS.D is the ny × nu system feedthrough matrix D with elements of type T. \n\nSYS.Ts is the real sampling time Ts, where Ts = 0 for a continuous-time system,     and Ts > 0 or Ts = -1 for a discrete-time system.      Ts = -1 indicates a discrete-time system with an unspecified sampling time. \n\nThe dimensions nx, ny and nu can be obtained as SYS.nx, SYS.ny and SYS.nu, respectively. \n\n\n\n\n\n","category":"type"},{"location":"dss.html#DescriptorSystems.dss","page":"Building descriptor system state-space models","title":"DescriptorSystems.dss","text":"sys = dss(A, E, B, C, D; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )\n\nCreate for Ts = 0 a descriptor system model sys = (A-λE,B,C,D) for a continuous-time state space system of the form\n\nEdx(t)/dt = Ax(t) + Bu(t) ,\ny(t)      = Cx(t) + Du(t) ,\n\nwhere x(t), u(t) and y(t) are the system state vector, system input vector and system output vector, respectively,  for the continuous time variable t. \n\nFor a nonzero positive sampling time Ts = ΔT, the descriptor system model specifies a discrete-time state space system of the form  \n\nEx(t+ΔT) = Ax(t) + Bu(t)\ny(t)     = Cx(t) + Du(t)\n\nfor the discrete values of the time variable t = 0, ΔT, 2ΔT, ....  Use Ts = -1 if the sampling time is not specified. In this case, by convention  ΔT = 1. \n\nFor a system with zero feedthrough matrix D, it is possible to set D = 0 (the scalar zero).  \n\nFor a standard state space system, E is the identity matrix. In this case, it is possible to set E = I (the boolean uniform scaling). Alternatively, use \n\nsys = dss(A, B, C, D; Ts = 0)\n\nto create a standard system.\n\nFor a system corresponding to a static gain D, use\n\nsys = dss(D; Ts = 0)\n\nIt is possible to specify a descriptor system via all or part of its matrices using the form \n\nsys = dss(A = mat1, E = mat2, B = mat3, C = mat4, D = mat5; Ts = 0, check_reg = false, \n          atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)\n\nwhere A, E, B, C, and D are keyword parameters set to appropriate matrix values  mat1, mat2, mat3, mat4, and mat5, respectively. If some of the system matrices are omited, then zero matrices of appropriate sizes are employed instead.  \n\nIt is assumed that the pencil A-λE is regular (i.e., det(A-λE) ̸≡ 0), and therefore, in the interest of efficiency, the regularity of A-λE is by default not tested. If check_reg = true, the regularity of A-λE is  additionally checked. In this case, the keyword arguments atol1, atol2 and rtol specify, respectively,  the absolute tolerance for the nonzero elements of A, the absolute tolerance for the nonzero elements of E,  and the relative tolerance for the nonzero elements of A and E.   The default relative tolerance is n*ϵ, where n is the order of the square matrices A and E, and  ϵ is the working machine epsilon.  The keyword argument atol can be used to simultaneously set atol1 = atol and atol2 = atol. \n\n\n\n\n\n sys = dss(A, E, B, F, C, G, D, H; compacted = false, \n           atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, rtol = min(atol1,atol2,atol3)>0 ? 0 : n*ϵ)\n\nConstruct an input-output equivalent descriptor system representation sys = (Ad-λdE,Bd,Cd,Dd) to a pencil based linearization  (A-λE,B-λF,C-λG,D-λH) satisfying \n\n            -1                        -1\n Cd*(λEd-Ad)  *Bd + Dd = (C-λG)*(λE-A)  *(B-λF) + D-λH .\n\nIf compacted = true, a compacted descriptor system realization is determined by exploiting possible rank defficiencies of the matrices F, G, and H. Any of the matrices F, G, and H can be set to missing. \n\nThe keyword arguments atol1, atol2, atol3, and rtol, specify, respectively, the absolute tolerance for the  nonzero elements of F, the absolute tolerance for the nonzero elements of G,  the absolute tolerance for the nonzero elements of H  and the relative tolerance  for the nonzero elements of F, G and H. The default relative tolerance is n*ϵ, where n is the size of  of A, and ϵ is the machine epsilon of the element type of A. The keyword argument atol can be used to simultaneously set atol1 = atol, atol2 = atol and atol3 = atol. \n\n\n\n\n\nsys = dss(NUM, DEN; contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational matrix R(λ) = NUM(λ) ./ DEN(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ).\n\nNUM(λ) is a polynomial matrix of the form NUM(λ) = N_1 + λ N_2 + ... + λ**k N_(k+1), for which   the coefficient matrices N_i, i = 1, ..., k+1 are stored in the 3-dimensional matrix NUM,  where NUM[:,:,i] contains the i-th coefficient matrix N_i (multiplying λ**(i-1)). \n\nDEN(λ) is a polynomial matrix of the form DEN(λ) = D_1 + λ D_2 + ... + λ**l D_(l+1), for which  the coefficient matrices D_i, i = 1, ..., l+1, are stored in the 3-dimensional matrix DEN,  where DEN[:,:,i] contain the i-th coefficient matrix D_i (multiplying λ**(i-1)). \n\nAlternatively, NUM(λ) and DEN(λ) can be specified as matrices of elements of the Polynomial type  provided by the Polynomials package. \n\nIf n is the order of A-λE, then the computed linearization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe descriptor system based realization is built using the methods described in [1] in conjunction with pencil manipulation algorithms [2] and [3] to compute reduced order realization. These algorithms  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances, respectively, for the  nonzero coefficients of NUM(λ) and DEN(λ).\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n[2] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[3] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(R; Ts=missing, contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the rational transfer function matrix R(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is R(λ). The resulting sys is a continuous-time system if Ts = 0 or  discrete-time system if Ts = -1 or Ts > 0.  If Ts = missing, the sampling time of sys is inherited from the sampling time TRs of the elements of R, unless TRs = nothing,  in which case Ts = 0 is used (by default).  \n\nR(λ) is a matrix with rational transfer function entries (see RationalTransferFunction ) corresponding to a multiple-input multiple-outputs system or a rational transfer function corresponding to a single-input single-output system. The numerators and denominators of the elements of R are of type  Polynomial as provided by the Polynomials package.   \n\nIf n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and R(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of R(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of R(λ).\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(P; Ts = 0, contr = false, obs = false, noseig = false, minimal = false, fast = true, atol = 0, rtol)\n\nConvert the polynomial matrix P(λ) to a descriptor system representation sys = (A-λE,B,C,D) such that  the transfer function matrix of sys is P(λ). The resulting sys is a continuous-time system if Ts = 0 or  discrete-time system if Ts = -1 or Ts > 0. \n\nP(λ) can be specified as a grade k polynomial matrix of the form P(λ) = P_1 + λ P_2 + ... + λ**k P_(k+1),  for which the coefficient matrices P_i, i = 1, ..., k+1, are stored in the 3-dimensional matrix P,  where P[:,:,i] contains the i-th coefficient matrix P_i (multiplying λ**(i-1)). \n\nP(λ) can also be specified as a matrix, vector or scalar of elements of the Polynomial type  provided by the Polynomials package.   \n\nIf d is the degree of P(λ) and n is the order of A-λE, then the computed realization satisfies:\n\n(1) A-λE is regular and P(λ) = C*inv(λE-A)*B+D;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or contr = true;\n\n(4) A-λE has no non-dynamic modes if minimal = true or noseig = true. \n\nIf conditions (1)-(4) are satisfied, the realization is called minimal and the resulting order n is the least achievable order. If conditions (1)-(3) are satisfied, the realization is called irreducible  and the resulting order n is the least achievable order using orthogonal similarity transformations. An irreducible realization preserves the pole-zero and singular structures of P(λ). \n\nThe underlying pencil manipulation algorithms [1] and [2] to compute reduced order realizations  employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if fast = true, or the SVD-decomposition, if fast = false. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.\n\nThe keyword arguments atol and rtol, specify the absolute and relative tolerances for the  nonzero coefficients of P(λ), respectively.\n\n[1] P. Van Dooreen, The generalized eigenstructure problem in linear system theory,  IEEE Transactions on Automatic Control, vol. AC-26, pp. 111-129, 1981.\n\n[2] A. Varga, Solving Fault Diagnosis Problems - Linear Synthesis Techniques, Springer Verlag, 2017. \n\n\n\n\n\nsys = dss(T, U, V, W; fast = true, contr = false, obs = false, minimal = false, atol = 0, rtol)\n\nConstruct an input-output equivalent descriptor system representation sys = (A-λE,B,C,D)  to a polynomial model specified by the polynomial matrices T(λ), U(λ), V(λ), and W(λ) such that \n\n  V(λ)*inv(T(λ))*U(λ)+W(λ) = C*inv(λE-A)*B+D.\n\nIf minimal = true, the resulting realization (A-λE,B,C,D) has the least possible order n of A-λE. \n\nT(λ), U(λ), V(λ), and W(λ) can be specified as polynomial matrices of the form X(λ) = X_1 + λ X_2 + ... + λ**k X_(k+1),  for X = T, U, V, and W, for which the coefficient matrices X_i, i = 1, ..., k+1, are stored in  the 3-dimensional matrices X, where X[:,:,i] contains the i-th coefficient matrix X_i (multiplying λ**(i-1)). \n\nT(λ), U(λ), V(λ), and W(λ) can also be specified as matrices, vectors or scalars of elements of the Polynomial type  provided by the Polynomials package.    In this case, no check is performed that T(λ), U(λ), V(λ)  and W(λ) have the same indeterminates.\n\nThe computed descriptor realization satisfies:\n\n(1) A-λE is regular;\n\n(2) rank[B A-λE] = n (controllability) if minimal = true or contr = true;\n\n(3) rank[A-λE; C] = n (observability)  if minimal = true or obs = true;\n\n(4) A-λE has no simple infinite eigenvalues if minimal = true.\n\nThe keyword arguments atol and rtol, specify, respectively, the absolute and relative tolerance for the  nonzero coefficients of the matrices T(λ), U(λ), V(λ) and W(λ). The default relative tolerance is nt*ϵ,  where nt is the size of the square matrix T(λ) and ϵ is the machine epsilon of the element type of its coefficients. \n\nThe descriptor realization is built using the methods described in [1].\n\n[1] A. Varga, On computing the Kronecker structure of polynomial and rational matrices using Julia, 2020,  arXiv:2006.06825.\n\n\n\n\n\n","category":"function"},{"location":"dss.html#DescriptorSystems.dssdata","page":"Building descriptor system state-space models","title":"DescriptorSystems.dssdata","text":"A, E, B, C, D  = dssdata([T,] sys)\n\nExtract the matrices A, E, B, C, D of a descriptor system model sys = (A-λE,B,C,D).  If the type T is specified, the resulting matrices are converted to this type. \n\n\n\n\n\n","category":"function"},{"location":"dss.html#DescriptorSystems.dssdatafull","page":"Building descriptor system state-space models","title":"DescriptorSystems.dssdatafull","text":"A, E, B, C, D  = dssdatafull([T,] sys)\n\nExtract the full matrices A, E, B, C, D of a descriptor system model sys = (A-λE,B,C,D).  If the type T is specified, the resulting matrices are converted to this type. \n\n\n\n\n\n","category":"function"},{"location":"index.html#DescriptorSystems.jl","page":"Home","title":"DescriptorSystems.jl","text":"(Image: DocBuild) (Image: Code on Github.)\n\nA descriptor system is a generalized state-space representation of the form\n\nEλx(t) = Ax(t) + Bu(t),\ny(t)   = Cx(t) + Du(t),\n\nwhere x(t) is the state vector, u(t) is the input vector, and y(t) is the output vector, and where λ is either the differential operator λx(t) = dx(t)/dt  for a continuous-time system or the advance operator λx(t) = x(t + ΔT) for a discrete-time system with the sampling time ΔT. In all what follows, we assume E is square and possibly singular, and the pencil A − λE is regular (i.e., det(A − λE) ̸≡ 0). If E = I, we call the above representation a  standard state-space system.\n\nThe corresponding input-output representation is\n\nY(λ) = G(λ)U(λ),\n\nwhere, depending on the system type, λ = s, the complex variable in the Laplace transform for a continuous-time system, or λ = z, the complex variable in the Z-transform for a discrete-time system, Y(λ) and U(λ) are the Laplace- or Z-transformed output and input vectors, respectively, and G(λ) is the rational transfer function matrix (TFM) of the system, defined as\n\n                -1\nG(λ) = C(λE − A)  B + D.\n\nIt is well known that the descriptor system representation is the most general description for a linear time-invariant system. Continuous-time descriptor systems arise frequently from modelling interconnected systems containing algebraic loops or constrained mechanical systems which describe contact phenomena. Discrete-time descriptor representations are frequently used to model economic processes. A main apeal of descriptor system models is that the manipulation of rational and polynomial matrices can be easily performed via their descriptor system representations, since each rational or polynomial matrix can be interpreted as the TFM of a descriptor system. For an introductory presentation of the main concepts, see [1].\n\nThe theoretical background for the analysis of descriptor systems closely relies on investigating the properties of certain linear matrix pencils, as the regular pole pencil P(λ) = A-λE, or the generally singular system matrix pencil S(λ) = [A-λE B; C D]. Therefore, the main analysis tools of descriptor systems are pencil manipulation techniques (e.g., reductions to various Kronecker-like forms), as available in the MatrixPencils package [2]. Among the main applications of pencil manipulation algorithms, we mention  the computation of minimal nullspace bases, the computation of poles and zeros, the determination of the normal rank of polynomial and rational matrices, computation of various factorizations of rational matrices, as well as the solution of linear equations with polynomial or rational matrices. Important additional computational ingredients in these applications are tools for solving matrix equations, as various Lyapunov, Sylvester and Riccati equations. These tools are provided by the MatrixEquations package [3].\n\nThe available functions in the DescriptorSystems.jl package cover both standard and descriptor systems with real or complex coefficient matrices. Several functions have been extended to handle large order descriptor systems with sparse and structured matrix data. The current version of the package includes the following functions:\n\nBuilding descriptor system state-space models\n\ndss  Construction of descriptor state-space models.\ndssdata   Extraction of matrix-data from a descriptor state-space model.\n\nBuilding rational transfer functions\n\nRationalTransferFunction  Construction of rational transfer function objects.\nrtf  Building rational transfer functions.\n\nInterconnecting descriptor system models\n\nappend  Building aggregate models by appending the inputs and outputs.\nparallel   Connecting models in parallel (also overloaded with +).\nseries   Connecting models in series (also overloaded with *).\nhorzcat   Horizontal concatenation of descriptor system models (also overloaded with [ * * ]).\nvertcat   Vertical concatenation of descriptor system models (also overloaded with [ *; * ]).\n\nBasic operations on descriptor system models\n\ninv  Inversion of a system.\nldiv   Left division for two systems (also overloaded with \\).\nrdiv   Right division for two systems (also overloaded with /).\ngdual   Building the dual of a descriptor system (also overloaded with transpose)\nctranspose  Building the conjugate transpose of a system (also overloaded with adjoint and ').\nadjoint  Building the adjoint of a system.\n\nBasic conversions on descriptor system models\n\ngprescale  Balancing of a descriptor system.\nc2d  Discretization of continuous-time descriptor systems.\ndss2rm  Rational transfer function matrix of a descriptor system.\ndss2pm  Polynomial transfer function matrix of a descriptor system.\ngbilin  Generalized bilinear transformation of a descriptor system.\n\nSome operations on rational transfer functions and matrices\n\nsimplify  Pole-zero cancellation.\nnormalize   Normalization of a rational transfer function to monic denominator.\nconfmap   Applying a conformal mapping transformation to a rational transfer function or rational transfer function matrix.\nzpk  Computation of zeros, poles and gain of a rational transfer function.\nrtfbilin  Generation of common bilinear transformations and their inverses.\n\nSimplification of descriptor system models\n\ngminreal  Minimal realization of descriptor systems.\ngir   Irreducible realization of descriptor systems.\ngbalmr   Reduced-order approximations of descriptor systems using balancing related methods.\ngss2ss   Conversion to SVD-like forms without non-dynamic modes.\ndss2ss   Conversion of descriptor systems to standard form.\n\nDescriptor system analysis\n\nisregular Test whether a descriptor system has a regular pole pencil.\ngpole    Poles of a descriptor system.\ngpoleinfo   Poles and pole structure information of a descriptor system.\nisproper   Test whether a descriptor system is proper.\nisstable   Test whether a descriptor system is stable.\ngzero  Zeros of a descriptor system.\ngzeroinfo Zeros and zero structure information of a descriptor system.\ngnrank  Normal rank of the transfer function matrix of a descriptor system.\nghanorm  Hankel norm of a proper and stable descriptor system.\ngl2norm  L2 norm of a descriptor system.\ngh2norm  H2 norm of a descriptor system.\nglinfnorm  L∞ norm of a descriptor system.\nghinfnorm  H∞ norm of a descriptor system.\ngnugap  ν-gap distance between two descriptor systems.\nfreqresp   Frequency response of a descriptor system.\ntimeresp   Time response of a descriptor system.\nstepresp   Step response of a descriptor system.\ngbalqual Evaluation of the scaling quality of the matrices of a descriptor system.\n\nFactorization of descriptor systems\n\ngrcf  Right coprime factorization with proper and stable factors.\nglcf   Left coprime factorization with proper and stable factors.\ngrcfid   Right coprime factorization with inner denominator.\nglcfid   Left coprime factorization with inner denominator.\ngnrcf  Normalized right coprime factorization.\ngnlcf   Normalized left coprime factorization.\ngiofac   Inner-outer/QR-like factorization.\ngoifac   Co-outer-co-inner/RQ-like factorization.\ngrsfg   Right spectral factorization of γ^2*I-G'*G. \nglsfg   Left spectral factorization of γ^2*I-G*G'. \n\nAdvanced operations on transfer function matrices\n\ngsdec  Additive spectral decompositions.\ngrnull   Right nullspace basis of a transfer function matrix.\nglnull   Left nullspace basis of a transfer function matrix.\ngrange   Range space basis of a transfer function matrix. \ngcrange  Coimage space basis of a transfer function matrix. \ngrsol   Solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglsol   Solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).\ngrmcover1  Right minimum dynamic cover of Type 1 based order reduction.\nglmcover1   Left minimum dynamic cover of Type 1 based order reduction.\ngrmcover2  Right minimum dynamic cover of Type 2 based order reduction.\nglmcover2  Left minimum dynamic cover of Type 2 based order reduction.\nginv  Generalized inverses.\n\nSolution of model-matching problems\n\ngnehari  Generalized Nehari approximation.\nglinfldp  Solution of the least distance problem.\ngrasol   Approximate solution of the linear rational matrix equation G(λ)*X(λ) = F(λ).\nglasol   Approximate solution of the linear rational matrix equation X(λ)*G(λ) = F(λ).","category":"section"},{"location":"index.html#[Release-Notes](https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/ReleaseNotes.md)","page":"Home","title":"Release Notes","text":"","category":"section"},{"location":"index.html#Main-developer","page":"Home","title":"Main developer","text":"Andreas Varga\n\nLicense: MIT (expat)","category":"section"},{"location":"index.html#References","page":"Home","title":"References","text":"[1]   A. Varga, Solving Fault Diagnosis Problems – Linear Synthesis Techniques, Vol. 84 of Studies in Systems, Decision and Control, Springer International Publishing, 2017.\n\n[2]  A. Varga, MatrixPencils.jl: Matrix pencil manipulation using Julia. Zenodo: https://doi.org/10.5281/zenodo.3894503.\n\n[3]  A. Varga, MatrixEquations.jl: Solution of Lyapunov, Sylvester and Riccati matrix equations using Julia. Zenodo: https://doi.org/10.5281/zenodo.3556867.","category":"section"}]
}
