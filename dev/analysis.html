<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Descriptor system analysis · DescriptorSystems.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DescriptorSystems.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="rtf.html">Building rational transfer functions</a></li><li><a class="tocitem" href="operations.html">Basic operations on system models</a></li><li><a class="tocitem" href="operations_rtf.html">Some operations on rational transfer functions and matrices</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li class="is-active"><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li><li><a class="tocitem" href="advanced_operations.html">Advanced operations on transfer function matrices</a></li><li><a class="tocitem" href="model_matching.html">Solution of model-matching problems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="dstools.html">System utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="analysis.html">Descriptor system analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="analysis.html">Descriptor system analysis</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/master/docs/src/analysis.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Descriptor-system-analysis-1"><a class="docs-heading-anchor" href="#Descriptor-system-analysis-1">Descriptor system analysis</a><a class="docs-heading-anchor-permalink" href="#Descriptor-system-analysis-1" title="Permalink"></a></h1><ul><li><strong><a href="analysis.html#MatrixPencils.isregular"><code>isregular</code></a></strong> Test whether a descriptor system has a regular pole pencil.</li><li><strong><a href="analysis.html#DescriptorSystems.gpole"><code>gpole</code></a></strong>    Poles of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gpoleinfo"><code>gpoleinfo</code></a></strong>   Poles and pole structure information of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.isproper"><code>isproper</code></a></strong>   Test whether a descriptor system is proper.</li><li><strong><a href="analysis.html#DescriptorSystems.isstable"><code>isstable</code></a></strong>   Test whether a descriptor system is stable.</li><li><strong><a href="analysis.html#DescriptorSystems.gzero"><code>gzero</code></a></strong>  Zeros of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gzeroinfo"><code>gzeroinfo</code></a></strong> Zeros and zero structure information of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gnrank"><code>gnrank</code></a></strong>  Normal rank of the transfer function matrix of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.ghanorm"><code>ghanorm</code></a></strong>  Hankel norm of a proper and stable descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gl2norm"><code>gl2norm</code></a></strong>  <code>L2</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gh2norm"><code>gh2norm</code></a></strong>  <code>H2</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.glinfnorm"><code>glinfnorm</code></a></strong>  <code>L∞</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.ghinfnorm"><code>ghinfnorm</code></a></strong>  <code>H∞</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gnugap"><code>gnugap</code></a></strong>  <code>ν-gap</code> distance between two descriptor systems.</li></ul><article class="docstring"><header><a class="docstring-binding" id="MatrixPencils.isregular" href="#MatrixPencils.isregular"><code>MatrixPencils.isregular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isregular(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return <code>true</code> if the descriptor system <code>sys = (A-λE,B,C,D)</code> has a regular pole pencil <code>A-λE</code> and <code>false</code> otherwise.  </p><p>To test whether the pencil <code>A-λE</code> is regular (i.e., <code>det(A-λE) ̸≡ 0</code>),   the underlying computational procedure reduces the pencil <code>A-λE</code> to an appropriate Kronecker-like form,  which provides information on the rank of <code>A-λE</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of  <code>A</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L354-L369">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gpole" href="#DescriptorSystems.gpole"><code>DescriptorSystems.gpole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">val = gpole(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite zeros of the system pole pencil <code>P(λ) := A-λE</code>.  The values in <code>val</code> are the poles of the transfer function matrix of <code>sys</code>, if <code>A-λE</code> is <em>regular</em> and the  descriptor system realization <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.  If the pencil <code>A-λE</code> is singular, <code>val</code> also contains <code>NaN</code> elements, whose number is the rank deficiency of the pencil  <code>A-λE</code>.</p><p>For <code>E</code> nonsingular, <code>val</code> contains the generalized eigenvalues of the pair <code>(A,E)</code>.  For <code>E</code> singular, <code>val</code> contains the zeros of <code>P(λ)</code>, which are computed  by reducing the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The regularity of <code>A-λE</code> is implicitly checked. If <code>check_reg = true</code>, an error message is issued if the pencil    <code>A-λE</code> is singular. If <code>check_reg = false</code> and the pencil <code>A-λE</code> is singular, then <code>n-r</code> poles are set to <code>NaN</code>, where <code>n</code> is the system order and <code>r</code> is the normal rank of <code>A-λE</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L62-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gpoleinfo" href="#DescriptorSystems.gpoleinfo"><code>DescriptorSystems.gpoleinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gpoleinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, 
          rtol = n*ϵ, offset = sqrt(ϵ)) -&gt; (val, info)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite zeros of the system pole pencil <code>P(λ) := A-λE</code> and the named tuple <code>info</code> containing information on  the eigenvalue structure of the pole pencil <code>P(λ)</code>. The values in <code>val</code> are the <em>poles</em> of the  transfer function matrix of <code>sys</code>, if <code>A-λE</code> is <em>regular</em> and the  descriptor system realization <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.  If the pencil <code>A-λE</code> is singular, <code>val</code> also contains <code>NaN</code> elements, whose number is the rank deficiency of the pencil  <code>A-λE</code>.</p><p>For stability analysis purposes, a stability margin <code>smarg</code> can be specified for the finite eigenvalues, in conjunction with a stability domain boundary offset <code>β</code> to numerically assess the  finite eigenvalues  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite eigenvalues having real parts in the interval <code>[smarg-β, smarg+β]</code>, while in the discrete-time case, these are the finite eigenvalues having moduli in the interval <code>[smarg-β, smarg+β]</code>. The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The named tuple <code>info</code> contains the following information:</p><p><code>info.nfev</code> is the number of finite eigenvalues of the pencil <code>A-λE</code> (also the number of finite poles of <code>sys</code>);</p><p><code>info.niev</code> is the number of infinite eigenvalues of the pencil <code>A-λE</code>;</p><p><code>info.nisev</code> is the number of <em>simple</em> infinite eigenvalues of the pencil <code>A-λE</code> (also known as non-dynamic modes); </p><p><code>info.nip</code> is the number of infinite poles of the system <code>sys</code>;</p><p><code>info.nfsev</code> is the number of finite stable eigenvalues, i.e., the finite eigenvalues having real parts or moduli less than <code>smarg-β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfsbev</code> is the number of finite eigenvalues on the boundary of the            stability domain, i.e., the finite eigenvalues           having real parts or moduli in the interval <code>[smarg-β, smarg+β]</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfuev</code> is the number of finite unstable eigenvalues, i.e., the finite eigenvalues having real parts or moduli greater than <code>smarg+β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nhev</code> is the number of <em>hidden</em> eigenvalues set to <code>NaN</code>          (can be nonzero only if the pencil <code>A-λE</code> is singular);  </p><p><code>info.nrank</code> is the normal rank of the pencil <code>A-λE</code>;</p><p><code>info.miev</code> is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil <code>A-λE</code> as follows:           the <code>i</code>-th element <code>info.miev[i]</code> is the order of an infinite elementary divisor            (i.e., the multiplicity of an infinite eigenvalue) and            the number of infinite poles is the sum of the components of <code>info.miev</code>;  </p><p><code>info.mip</code> is an integer vector, which contains the information on the              multiplicities of the infinite zeros of <code>A-λE</code> as follows:             the <code>i</code>-th element <code>info.mip[i]</code> is equal to <code>k-1</code>, where <code>k</code> is the order of an infinite elementary               divisor with <code>k &gt; 0</code> and the number of infinite poles is the sum of the components of <code>info.mip</code>; </p><p><code>info.rki</code> is an integer vector, which contains the <em>right Kronecker indices</em>             of the pencil <code>A-λE</code> (empty for a regular pencil);</p><p><code>info.lki</code> is an integer vector, which contains the <em>left Kronecker indices</em>            of the pencil <code>A-λE</code> (empty for a regular pencil);</p><p><code>info.regular</code> is set to <code>true</code>,  if the pencil <code>A-λE</code> is regular and set to   <code>false</code>, if the pencil <code>A-λE</code> is singular;</p><p><code>info.proper</code> is set to <code>true</code>, if the pencil <code>A-λE</code> is regular and all its infinite                   eigenvalues are simple (has only non-dynamic modes), or                   is set to <code>false</code>, if the pencil <code>A-λE</code> is singular or has higher order infinite eigenvalues;</p><p><code>info.stable</code> is set to <code>true</code>, if the pencil <code>A-λE</code> is regular, has only stable                   finite eigenvalues and all its infinite eigenvalues are                  simple (has only non-dynamic modes), and  is set to <code>false</code> otherwise.</p><p><em>Note:</em> The finite poles and the finite eigenvalues of the pencil <code>P(λ)</code> are the same,  but the multiplicities of infinite eigenvalues of <code>P(λ)</code> are in excess with one to the multiplicities of infinite poles.</p><p>For the reduction of the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   orthonal similarity transformations are performed, which involve rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>P(λ)</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L208-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.isproper" href="#DescriptorSystems.isproper"><code>DescriptorSystems.isproper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isproper(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = = n*ϵ, fast = true)</code></pre><p>Return <code>true</code> if the transfer function matrix <code>G(λ)</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code> is proper and <code>false</code> otherwise.  </p><p>For a descriptor system realization <code>sys = (A-λE,B,C,D)</code> without uncontrollable and unobservable infinite eigenvalues, it is checked that the pencil <code>A-λE</code> has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple. If the original descriptor realization has uncontrollable or unobservable infinite eigenvalues, these are elliminated using orthogonal pencil reduction algorithms. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L378-L395">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.isstable" href="#DescriptorSystems.isstable"><code>DescriptorSystems.isstable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isstable(sys[, smarg]; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, offset = sqrt(ϵ))</code></pre><p>Return <code>true</code> if the descriptor system <code>sys = (A-λE,B,C,D)</code> has only stable poles and <code>false</code> otherwise.  </p><p>It is checked that the pole pencil <code>P(λ) := A-λE</code> has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple, and additionally the real parts of all finite eigenvalues  are less than <code>smarg-β</code> for a continuous-time system or  have moduli less than <code>smarg-β</code> for a discrete-time system, where <code>smarg</code> is the stability margin and  <code>β</code> is the stability domain boundary offset.  The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system. The offset  <code>β</code> to be used to numerically assess the stability of eigenvalues  can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For <code>E</code> singular, the computation of the poles is performed by reducing the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L412-L438">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gzero" href="#DescriptorSystems.gzero"><code>DescriptorSystems.gzero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">val = gzero(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing the  finite and infinite Smith zeros of the system matrix pencil  </p><pre><code class="language-none">           | A-λE | B | 
   S(λ) := |------|---| .
           |  C   | D |</code></pre><p>The values in <code>val</code> are called the <em>invariant zeros</em> of the pencil <code>S(λ)</code> and are the <em>transmission zeros</em> of the  transfer function matrix of <code>sys</code> if <code>A-λE</code> is <em>regular</em> and the descriptor system realization  <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.  </p><p>The computation of the zeros is performed by reducing the pencil <code>S(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>A</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L31-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gzeroinfo" href="#DescriptorSystems.gzeroinfo"><code>DescriptorSystems.gzeroinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gzeroinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, 
          rtol = n*ϵ, offset = sqrt(ϵ)) -&gt; (val, info)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite Smith zeros of the system matrix pencil <code>S(λ)</code> </p><pre><code class="language-none">          | A-λE | B | 
   S(λ) = |------|---| 
          |  C   | D |</code></pre><p>and the named tuple <code>info</code> containing information on the Kronecker structure of the pencil <code>S(λ)</code>.  The values in <code>val</code> are called the <em>invariant zeros</em> of the pencil <code>S(λ)</code> and are the <em>transmission zeros</em> of the  transfer function matrix of <code>sys</code> if <code>A-λE</code> is <em>regular</em> and the descriptor system realization  <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>. </p><p>For stability analysis purposes, a stability margin <code>smarg</code> can be specified for the finite zeros, in conjunction with a stability domain boundary offset <code>β</code> to numerically assess the  finite zeros  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite zeros having real parts in the interval <code>[smarg-β, smarg+β]</code>, while in the discrete-time case, these are the finite zeros having moduli in the interva <code>[smarg-β, smarg+β]</code>. The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The named tuple <code>info</code> contains the following information:</p><p><code>info.nfz</code> is the number of finite eigenvalues of the pencil <code>S(λ)</code> (also the number of finite zeros of <code>sys</code>);</p><p><code>info.niev</code> is the number of infinite eigenvalues of the pencil <code>S(λ)</code>;</p><p><code>info.nisev</code> is the number of  <em>simple</em> infinite eigenvalues of the pencil <code>S(λ)</code>; </p><p><code>info.niz</code> is the number of infinite zeros of the system <code>sys</code>;</p><p><code>info.nfsz</code> is the number of finite stable zeros, i.e., the finite zeros having real parts or moduli less than <code>smarg-β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfsbz</code> is the number of finite zeros on the boundary of the            stability domain, i.e., the finite zeros           having real parts or moduli in the interval <code>[smarg-β, smarg+β]</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfuz</code> is the number of finite unstable zeros, i.e., the finite zeros having real parts or moduli greater than <code>smarg+β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nrank</code> is the normal rank of the pencil <code>S(λ)</code>;</p><p><code>info.miev</code> is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil <code>S(λ)</code>              (also the dimensions of the elementary infinite blocks in the           Kronecker form of <code>S(λ)</code>);</p><p><code>info.miz</code> is an integer vector, which contains the information on the              multiplicities of the infinite zeros of <code>S(λ)</code> as follows:             <code>S(λ)</code> has <code>info.mip[i]</code> infinite zeros of multiplicity <code>i</code>, and               is empty if <code>S(λ)</code> has no infinite zeros;</p><p><code>info.rki</code> is an integer vector, which contains the <em>right Kronecker indices</em>           of the pencil <code>S(λ)</code> (empty for a regular pencil);</p><p><code>info.lki</code> is an integer vector, which contains the <em>left Kronecker indices</em>          of the pencil <code>S(λ)</code> (empty for a regular pencil);</p><p><code>info.regular</code> is set to <code>true</code>,  if the pencil <code>S(λ)</code> is regular and set to   <code>false</code>, if the pencil <code>S(λ)</code> is singular;</p><p><code>info.stable</code> is set to <code>true</code>, if the pencil <code>S(λ)</code> has only stable                   finite zeros and all its infinite zeros are                  simple and  is set to <code>false</code> otherwise.</p><p><em>Note:</em> The finite zeros and the finite eigenvalues of the pencil <code>S(λ)</code> are the same, but the multiplicities of infinite eigenvalues     are in excess with one to the multiplicities of infinite zeros. </p><p>The computation of the zeros is performed by reducing the pencil <code>S(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>A</code> and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L108-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gnrank" href="#DescriptorSystems.gnrank"><code>DescriptorSystems.gnrank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">r = gnrank(sys, fastrank = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )</code></pre><p>Compute the normal rank <code>r</code> of the transfer function matrix <code>G(λ)</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code>. </p><p>The normal rank of <code>G(λ)</code> is evaluated as <code>r = k - n</code>, where <code>k</code> is the normal rank of the system matrix pencil </p><pre><code class="language-none">          | A-λE | B | 
  S(λ) := |------|---|
          |  C   | D |</code></pre><p>and <code>n</code> is the order of the system <code>sys</code> (i.e., the size of <code>A</code>). </p><p>If <code>fastrank = true</code>, the normal rank of <code>S(λ)</code> is evaluated by counting the singular values of <code>S(γ)</code> greater than <code>max(max(atol1,atol2), rtol*σ₁)</code>,  where <code>σ₁</code> is the largest singular value of <code>S(γ)</code> and <code>γ</code> is a randomly generated value.  If <code>fastrank = false</code>, the rank is evaluated as <code>nr + ni + nf + nl</code>, where <code>nr</code> and <code>nl</code> are the sums of right and left Kronecker indices,  respectively, while <code>ni</code> and <code>nf</code> are the number of infinite and finite eigenvalues, respectively. The sums <code>nr+ni</code> and   <code>nf+nl</code> are determined from an appropriate Kronecker-like form of the pencil <code>S(λ)</code>, exhibiting the spliting of the right and left structures.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.ghanorm" href="#DescriptorSystems.ghanorm"><code>DescriptorSystems.ghanorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hanorm, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the Hankel norm <code>hanorm =</code> <span>$\small ||G(\lambda)||_H$</span> and the vector of Hankel singular values <code>hs</code> of the system.</p><p>For a proper system with <code>E</code> singular, the uncontrollable infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L453-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gl2norm" href="#DescriptorSystems.gl2norm"><code>DescriptorSystems.gl2norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gl2norm(sys, h2norm = false, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>L2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>L2</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  The <code>L2</code> norm is also infinite for a continuous-time system having a gain at infinity greater than <code>atolinf</code>. </p><p>To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil <code>A-λE</code>  must not have real parts in the interval <code>[-β,β]</code> for a continuous-time system or  must not have moduli in the interval <code>[1-β,1+β]</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>h2norm = true</code>, the <code>H2</code> norm is computed.  The <code>H2</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has unstable zeros (i.e., unstable poles), or for a continuous-time system having a gain at infinity greater than <code>atolinf</code>.   To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atol3</code> specifies the absolute tolerance for the nonzero elements of <code>B</code> and is only used if <code>h2norm = false</code> for controllability tests of unstable eigenvalues.  The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at  <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code> and <code>atol3 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L553-L591">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gh2norm" href="#DescriptorSystems.gh2norm"><code>DescriptorSystems.gh2norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>H2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>H2</code> norm is infinite, if <code>sys</code> has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the <em>pole pencil</em> <code>A-λE</code> must have real parts less  than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L520-L546">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glinfnorm" href="#DescriptorSystems.glinfnorm"><code>DescriptorSystems.glinfnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">glinfnorm(sys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (linfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>L∞</code> norm <code>linfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>L∞</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.   To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil <code>A-λE</code>  must not have real parts in the interval <code>[-β,β]</code> for a continuous-time system or  must not have moduli within the interval <code>[1-β,1+β]</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>If <code>hinfnorm = true</code>, the <code>H∞</code> norm is computed. In this case, the stability of the zeros of <code>A-λE</code> is additionally checked and  the <code>H∞</code> norm is infinite for an unstable system. To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L687-L722">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.ghinfnorm" href="#DescriptorSystems.ghinfnorm"><code>DescriptorSystems.ghinfnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hinfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>H∞</code> norm <code>hinfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>H∞</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has unstable zeros (i.e., <code>sys</code> has unstable poles).  To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L653-L680">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gnugap" href="#DescriptorSystems.gnugap"><code>DescriptorSystems.gnugap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (nugapdist, fpeak)</code></pre><p>Compute the ν-gap distance <code>nugapdist</code> between two descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> and the corresponding frequency <code>fpeak</code> (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. </p><p>If <code>freq = missing</code>, the resulting <code>nugapdist</code> satisfies <code>0 &lt;= nugapdist &lt;= 1</code>.  The value <code>nugapdist = 1</code> results, if the winding number is different of zero in which case <code>fpeak = []</code>. </p><p>If <code>freq = ω</code>, where <code>ω</code> is a given vector of real frequency values, the resulting <code>nugapdist</code> is a vector  of pointwise ν-gap distances of the dimension of <code>ω</code>, whose components satisfies <code>0 &lt;= maximum(nugapdist) &lt;= 1</code>.  In this case, <code>fpeak</code> is the frequency for which the pointwise distance achieves its peak value.  All components of <code>nugapdist</code> are set to 1 if the winding number is different of zero in which case <code>fpeak = []</code>.</p><p>The stability boundary offset,  <code>β</code>, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval <code>[-β,β]</code>, while for a discrete-time system,  these are the finite zeros having moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>Pencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>A2</code>, <code>B1</code>, <code>B2</code>, <code>C1</code>, <code>C2</code>, <code>D1</code> and <code>D2</code>, the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximum of the orders of the systems <code>sys1</code> and <code>sys2</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for <code>rtolinf</code> is <code>0.00001</code>.</p><p><em>Method:</em> The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.</p><p><em>References:</em></p><p>[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/f21378cf109700c24a1eafff29862c6f5412c0f5/src/analysis.jl#L1041-L1091">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="order_reduction.html">« Simplification of descriptor system models</a><a class="docs-footer-nextpage" href="factorizations.html">Factorization of descriptor system transfer function matrices »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 2 May 2021 12:38">Sunday 2 May 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
