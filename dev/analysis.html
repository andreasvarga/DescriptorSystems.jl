<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Descriptor system analysis · DescriptorSystems.jl</title><meta name="title" content="Descriptor system analysis · DescriptorSystems.jl"/><meta property="og:title" content="Descriptor system analysis · DescriptorSystems.jl"/><meta property="twitter:title" content="Descriptor system analysis · DescriptorSystems.jl"/><meta name="description" content="Documentation for DescriptorSystems.jl."/><meta property="og:description" content="Documentation for DescriptorSystems.jl."/><meta property="twitter:description" content="Documentation for DescriptorSystems.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">DescriptorSystems.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="rtf.html">Building rational transfer functions</a></li><li><a class="tocitem" href="operations.html">Basic operations on system models</a></li><li><a class="tocitem" href="operations_rtf.html">Some operations on rational transfer functions and matrices</a></li><li><a class="tocitem" href="conversions.html">Basic conversions of descriptor system models</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li class="is-active"><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li><li><a class="tocitem" href="advanced_operations.html">Advanced operations on transfer function matrices</a></li><li><a class="tocitem" href="model_matching.html">Solution of model-matching problems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="dstools.html">System utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="analysis.html">Descriptor system analysis</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="analysis.html">Descriptor system analysis</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/andreasvarga/DescriptorSystems.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/docs/src/analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Descriptor-system-analysis"><a class="docs-heading-anchor" href="#Descriptor-system-analysis">Descriptor system analysis</a><a id="Descriptor-system-analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Descriptor-system-analysis" title="Permalink"></a></h1><ul><li><strong><a href="analysis.html#MatrixPencils.isregular"><code>isregular</code></a></strong> Test whether a descriptor system has a regular pole pencil.</li><li><strong><a href="analysis.html#DescriptorSystems.gpole"><code>gpole</code></a></strong>    Poles of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gpoleinfo"><code>gpoleinfo</code></a></strong>   Poles and pole structure information of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.isproper"><code>isproper</code></a></strong>   Test whether a descriptor system is proper.</li><li><strong><a href="analysis.html#DescriptorSystems.isstable"><code>isstable</code></a></strong>   Test whether a descriptor system is stable.</li><li><strong><a href="analysis.html#DescriptorSystems.gzero"><code>gzero</code></a></strong>  Zeros of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gzeroinfo"><code>gzeroinfo</code></a></strong> Zeros and zero structure information of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gnrank"><code>gnrank</code></a></strong>  Normal rank of the transfer function matrix of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.ghanorm"><code>ghanorm</code></a></strong>  Hankel norm of a proper and stable descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gl2norm"><code>gl2norm</code></a></strong>  <code>L2</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gh2norm"><code>gh2norm</code></a></strong>  <code>H2</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.glinfnorm"><code>glinfnorm</code></a></strong>  <code>L∞</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.ghinfnorm"><code>ghinfnorm</code></a></strong>  <code>H∞</code> norm of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gnugap"><code>gnugap</code></a></strong>  <code>ν-gap</code> distance between two descriptor systems.</li><li><strong><a href="analysis.html#DescriptorSystems.freqresp"><code>freqresp</code></a></strong>   Frequency response of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.timeresp"><code>timeresp</code></a></strong>   Time response of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.stepresp"><code>stepresp</code></a></strong>   Step response of a descriptor system.</li><li><strong><a href="analysis.html#DescriptorSystems.gbalqual"><code>gbalqual</code></a></strong> Evaluation of the scaling quality of the matrices of a descriptor system.</li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="MatrixPencils.isregular" href="#MatrixPencils.isregular"><code>MatrixPencils.isregular</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isregular(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return <code>true</code> if the descriptor system <code>sys = (A-λE,B,C,D)</code> has a regular pole pencil <code>A-λE</code> and <code>false</code> otherwise.  </p><p>To test whether the pencil <code>A-λE</code> is regular (i.e., <code>det(A-λE) ̸≡ 0</code>),   the underlying computational procedure reduces the pencil <code>A-λE</code> to an appropriate Kronecker-like form,  which provides information on the rank of <code>A-λE</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>, and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of  <code>A</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L367-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gpole" href="#DescriptorSystems.gpole"><code>DescriptorSystems.gpole</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">val = gpole(sys; fast = false, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite zeros of the system pole pencil <code>P(λ) := A-λE</code>.  The values in <code>val</code> are the poles of the transfer function matrix of <code>sys</code>, if <code>A-λE</code> is <em>regular</em> and the  descriptor system realization <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.  If the pencil <code>A-λE</code> is singular, <code>val</code> also contains <code>NaN</code> elements, whose number is the rank deficiency of the pencil  <code>A-λE</code>.</p><p>For <code>E</code> nonsingular, <code>val</code> contains the generalized eigenvalues of the pair <code>(A,E)</code>.  For <code>E</code> singular, <code>val</code> contains the zeros of <code>P(λ)</code>, which are computed  by reducing the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The regularity of <code>A-λE</code> is implicitly checked. If <code>check_reg = true</code>, an error message is issued if the pencil    <code>A-λE</code> is singular. If <code>check_reg = false</code> and the pencil <code>A-λE</code> is singular, then <code>n-r</code> poles are set to <code>NaN</code>, where <code>n</code> is the system order and <code>r</code> is the normal rank of <code>A-λE</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L69-L94">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gpoleinfo" href="#DescriptorSystems.gpoleinfo"><code>DescriptorSystems.gpoleinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gpoleinfo(sys; smarg, fast = false, atol = 0, atol1 = atol, atol2 = atol, 
          rtol = n*ϵ, offset = sqrt(ϵ)) -&gt; (val, info)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite zeros of the system pole pencil <code>P(λ) := A-λE</code> and the named tuple <code>info</code> containing information on  the eigenvalue structure of the pole pencil <code>P(λ)</code>. The values in <code>val</code> are the <em>poles</em> of the  transfer function matrix of <code>sys</code>, if <code>A-λE</code> is <em>regular</em> and the  descriptor system realization <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.  If the pencil <code>A-λE</code> is singular, <code>val</code> also contains <code>NaN</code> elements, whose number is the rank deficiency of the pencil  <code>A-λE</code>.</p><p>For stability analysis purposes, a stability margin <code>smarg</code> can be specified for the finite eigenvalues, in conjunction with a stability domain boundary offset <code>β</code> to numerically assess the  finite eigenvalues  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite eigenvalues having real parts in the interval <code>[smarg-β, smarg+β]</code>, while in the discrete-time case, these are the finite eigenvalues having moduli in the interval <code>[smarg-β, smarg+β]</code>. The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The named tuple <code>info</code> contains the following information:</p><p><code>info.nfev</code> is the number of finite eigenvalues of the pencil <code>A-λE</code> (also the number of finite poles of <code>sys</code>);</p><p><code>info.niev</code> is the number of infinite eigenvalues of the pencil <code>A-λE</code>;</p><p><code>info.nisev</code> is the number of <em>simple</em> infinite eigenvalues of the pencil <code>A-λE</code> (also known as non-dynamic modes); </p><p><code>info.nip</code> is the number of infinite poles of the system <code>sys</code>;</p><p><code>info.nfsev</code> is the number of finite stable eigenvalues, i.e., the finite eigenvalues having real parts or moduli less than <code>smarg-β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfsbev</code> is the number of finite eigenvalues on the boundary of the            stability domain, i.e., the finite eigenvalues           having real parts or moduli in the interval <code>[smarg-β, smarg+β]</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfuev</code> is the number of finite unstable eigenvalues, i.e., the finite eigenvalues having real parts or moduli greater than <code>smarg+β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nhev</code> is the number of <em>hidden</em> eigenvalues set to <code>NaN</code>          (can be nonzero only if the pencil <code>A-λE</code> is singular);  </p><p><code>info.nrank</code> is the normal rank of the pencil <code>A-λE</code>;</p><p><code>info.miev</code> is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil <code>A-λE</code> as follows:           the <code>i</code>-th element <code>info.miev[i]</code> is the order of an infinite elementary divisor            (i.e., the multiplicity of an infinite eigenvalue) and            the number of infinite poles is the sum of the components of <code>info.miev</code>;  </p><p><code>info.mip</code> is an integer vector, which contains the information on the              multiplicities of the infinite zeros of <code>A-λE</code> as follows:             the <code>i</code>-th element <code>info.mip[i]</code> is equal to <code>k-1</code>, where <code>k</code> is the order of an infinite elementary               divisor with <code>k &gt; 0</code> and the number of infinite poles is the sum of the components of <code>info.mip</code>; </p><p><code>info.rki</code> is an integer vector, which contains the <em>right Kronecker indices</em>             of the pencil <code>A-λE</code> (empty for a regular pencil);</p><p><code>info.lki</code> is an integer vector, which contains the <em>left Kronecker indices</em>            of the pencil <code>A-λE</code> (empty for a regular pencil);</p><p><code>info.regular</code> is set to <code>true</code>,  if the pencil <code>A-λE</code> is regular and set to   <code>false</code>, if the pencil <code>A-λE</code> is singular;</p><p><code>info.proper</code> is set to <code>true</code>, if the pencil <code>A-λE</code> is regular and all its infinite                   eigenvalues are simple (has only non-dynamic modes), or                   is set to <code>false</code>, if the pencil <code>A-λE</code> is singular or has higher order infinite eigenvalues;</p><p><code>info.stable</code> is set to <code>true</code>, if the pencil <code>A-λE</code> is regular, has only stable                   finite eigenvalues and all its infinite eigenvalues are                  simple (has only non-dynamic modes), and  is set to <code>false</code> otherwise.</p><p><em>Note:</em> The finite poles and the finite eigenvalues of the pencil <code>P(λ)</code> are the same,  but the multiplicities of infinite eigenvalues of <code>P(λ)</code> are in excess with one to the multiplicities of infinite poles.</p><p>For the reduction of the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   orthonal similarity transformations are performed, which involve rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code> and <code>E</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>P(λ)</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L220-L307">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.isproper" href="#DescriptorSystems.isproper"><code>DescriptorSystems.isproper</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isproper(sys; atol = 0, atol1 = atol, atol2 = atol, rtol = = n*ϵ, fast = true)</code></pre><p>Return <code>true</code> if the transfer function matrix <code>G(λ)</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code> is proper and <code>false</code> otherwise.  </p><p>For a descriptor system realization <code>sys = (A-λE,B,C,D)</code> without uncontrollable and unobservable infinite eigenvalues, it is checked that the pencil <code>A-λE</code> has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple. If the original descriptor realization has uncontrollable or unobservable infinite eigenvalues, these are elliminated using orthogonal pencil reduction algorithms. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L391-L408">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.isstable" href="#DescriptorSystems.isstable"><code>DescriptorSystems.isstable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isstable(sys[, smarg]; fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ, offset = sqrt(ϵ))</code></pre><p>Return <code>true</code> if the descriptor system <code>sys = (A-λE,B,C,D)</code> has only stable poles and <code>false</code> otherwise.  </p><p>It is checked that the pole pencil <code>P(λ) := A-λE</code> has no infinite eigenvalues or, if infinite eigenvalues exist, all infinite eigenvalues are simple, and additionally the real parts of all finite eigenvalues  are less than <code>smarg-β</code> for a continuous-time system or  have moduli less than <code>smarg-β</code> for a discrete-time system, where <code>smarg</code> is the stability margin and  <code>β</code> is the stability domain boundary offset.  The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system. The offset  <code>β</code> to be used to numerically assess the stability of eigenvalues  can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For <code>E</code> singular, the computation of the poles is performed by reducing the pencil <code>P(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of <code>A</code> and <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L425-L451">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gzero" href="#DescriptorSystems.gzero"><code>DescriptorSystems.gzero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">val = gzero(sys; fast = false, prescale, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing the  finite and infinite Smith zeros of the system matrix pencil  </p><pre><code class="nohighlight hljs">           | A-λE | B | 
   S(λ) := |------|---| .
           |  C   | D |</code></pre><p>The values in <code>val</code> are called the <em>invariant zeros</em> of the pencil <code>S(λ)</code> and are the <em>transmission zeros</em> of the  transfer function matrix of <code>sys</code> if <code>A-λE</code> is <em>regular</em> and the descriptor system realization  <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>.</p><p>If <code>prescale = true</code>, a preliminary balancing of the descriptor system matrices is performed.  The default setting is <code>prescale = gbalqual(sys) &gt; 10000</code>, where <code>gbalqual(sys)</code> is the  scaling quality of the descriptor system model <code>sys</code> (see <a href="analysis.html#DescriptorSystems.gbalqual"><code>gbalqual</code></a>). </p><p>The computation of the zeros is performed by reducing the pencil <code>S(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>A</code>, and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L33-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gzeroinfo" href="#DescriptorSystems.gzeroinfo"><code>DescriptorSystems.gzeroinfo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gzeroinfo(sys; smarg, fast = false, prescale, atol = 0, atol1 = atol, atol2 = atol, 
          rtol = n*ϵ, offset = sqrt(ϵ)) -&gt; (val, info)</code></pre><p>Return for the descriptor system <code>sys = (A-λE,B,C,D)</code> the complex vector <code>val</code> containing  the finite and infinite Smith zeros of the system matrix pencil <code>S(λ)</code> </p><pre><code class="nohighlight hljs">          | A-λE | B | 
   S(λ) = |------|---| 
          |  C   | D |</code></pre><p>and the named tuple <code>info</code> containing information on the Kronecker structure of the pencil <code>S(λ)</code>.  The values in <code>val</code> are called the <em>invariant zeros</em> of the pencil <code>S(λ)</code> and are the <em>transmission zeros</em> of the  transfer function matrix of <code>sys</code> if <code>A-λE</code> is <em>regular</em> and the descriptor system realization  <code>sys = (A-λE,B,C,D)</code> is <em>irreducible</em>. </p><p>If <code>prescale = true</code>, a preliminary balancing of the descriptor system matrices is performed.  The default setting is <code>prescale = gbalqual(sys) &gt; 10000</code>, where <code>gbalqual(sys)</code> is the  scaling quality of the descriptor system model <code>sys</code> (see <a href="analysis.html#DescriptorSystems.gbalqual"><code>gbalqual</code></a>). </p><p>For stability analysis purposes, a stability margin <code>smarg</code> can be specified for the finite zeros, in conjunction with a stability domain boundary offset <code>β</code> to numerically assess the  finite zeros  which belong to the boundary of the stability domain as follows:  in the continuous-time case, these are the finite zeros having real parts in the interval <code>[smarg-β, smarg+β]</code>, while in the discrete-time case, these are the finite zeros having moduli in the interva <code>[smarg-β, smarg+β]</code>. The default value of the stability margin <code>smarg</code> is <code>0</code> for a continuous-time system and  <code>1</code> for a discrete-time system.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The named tuple <code>info</code> contains the following information:</p><p><code>info.nfz</code> is the number of finite eigenvalues of the pencil <code>S(λ)</code> (also the number of finite zeros of <code>sys</code>);</p><p><code>info.niev</code> is the number of infinite eigenvalues of the pencil <code>S(λ)</code>;</p><p><code>info.nisev</code> is the number of  <em>simple</em> infinite eigenvalues of the pencil <code>S(λ)</code>; </p><p><code>info.niz</code> is the number of infinite zeros of the system <code>sys</code>;</p><p><code>info.nfsz</code> is the number of finite stable zeros, i.e., the finite zeros having real parts or moduli less than <code>smarg-β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfsbz</code> is the number of finite zeros on the boundary of the            stability domain, i.e., the finite zeros           having real parts or moduli in the interval <code>[smarg-β, smarg+β]</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nfuz</code> is the number of finite unstable zeros, i.e., the finite zeros having real parts or moduli greater than <code>smarg+β</code> for a continuous- or discrete-time system, respectively;</p><p><code>info.nrank</code> is the normal rank of the pencil <code>S(λ)</code>;</p><p><code>info.miev</code> is an integer vector, which contains the multiplicities            of the infinite eigenvalues of the pencil <code>S(λ)</code>              (also the dimensions of the elementary infinite blocks in the           Kronecker form of <code>S(λ)</code>);</p><p><code>info.miz</code> is an integer vector, which contains the information on the              multiplicities of the infinite zeros of <code>S(λ)</code> as follows:             <code>S(λ)</code> has <code>info.mip[i]</code> infinite zeros of multiplicity <code>i</code>, and               is empty if <code>S(λ)</code> has no infinite zeros;</p><p><code>info.rki</code> is an integer vector, which contains the <em>right Kronecker indices</em>           of the pencil <code>S(λ)</code> (empty for a regular pencil);</p><p><code>info.lki</code> is an integer vector, which contains the <em>left Kronecker indices</em>          of the pencil <code>S(λ)</code> (empty for a regular pencil);</p><p><code>info.regular</code> is set to <code>true</code>,  if the pencil <code>S(λ)</code> is regular and set to   <code>false</code>, if the pencil <code>S(λ)</code> is singular;</p><p><code>info.stable</code> is set to <code>true</code>, if the pencil <code>S(λ)</code> has only stable                   finite zeros and all its infinite zeros are                  simple and  is set to <code>false</code> otherwise.</p><p><em>Note:</em> The finite zeros and the finite eigenvalues of the pencil <code>S(λ)</code> are the same, but the multiplicities of infinite eigenvalues     are in excess with one to the multiplicities of infinite zeros. </p><p>The computation of the zeros is performed by reducing the pencil <code>S(λ)</code> to an appropriate Kronecker-like form   using orthonal similarity transformations and involves rank decisions based on rank revealing QR-decompositions with column pivoting,  if <code>fast = true</code>, or, the more reliable, SVD-decompositions, if <code>fast = false</code>. </p><p>The keyword arguements <code>atol1</code>, <code>atol2</code>  and <code>rtol</code> specify the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code> and <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>E</code>, <code>B</code>, <code>C</code> and <code>D</code>, respectively.  The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the size of <code>A</code> and <code>ϵ</code> is the  working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L115-L203">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gnrank" href="#DescriptorSystems.gnrank"><code>DescriptorSystems.gnrank</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">r = gnrank(sys, fastrank = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ )</code></pre><p>Compute the normal rank <code>r</code> of the transfer function matrix <code>G(λ)</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code>. </p><p>The normal rank of <code>G(λ)</code> is evaluated as <code>r = k - n</code>, where <code>k</code> is the normal rank of the system matrix pencil </p><pre><code class="nohighlight hljs">          | A-λE | B | 
  S(λ) := |------|---|
          |  C   | D |</code></pre><p>and <code>n</code> is the order of the system <code>sys</code> (i.e., the size of <code>A</code>). </p><p>If <code>fastrank = true</code>, the normal rank of <code>S(λ)</code> is evaluated by counting the singular values of <code>S(γ)</code> greater than <code>max(max(atol1,atol2), rtol*σ₁)</code>,  where <code>σ₁</code> is the largest singular value of <code>S(γ)</code> and <code>γ</code> is a randomly generated value.  If <code>fastrank = false</code>, the rank is evaluated as <code>nr + ni + nf + nl</code>, where <code>nr</code> and <code>nl</code> are the sums of right and left Kronecker indices,  respectively, while <code>ni</code> and <code>nf</code> are the number of infinite and finite eigenvalues, respectively. The sums <code>nr+ni</code> and   <code>nf+nl</code> are determined from an appropriate Kronecker-like form of the pencil <code>S(λ)</code>, exhibiting the spliting of the right and left structures.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.ghanorm" href="#DescriptorSystems.ghanorm"><code>DescriptorSystems.ghanorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghanorm(sys, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hanorm, hs)</code></pre><p>Compute for a proper and stable descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, the Hankel norm <code>hanorm =</code> <span>$\small ||G(\lambda)||_H$</span> and the vector of Hankel singular values <code>hs</code> of the system.</p><p>For a proper system with <code>E</code> singular, the uncontrollable infinite eigenvalues of the pair <code>(A,E)</code> and the non-dynamic modes are elliminated using minimal realization techniques. The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L466-L485">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gl2norm" href="#DescriptorSystems.gl2norm"><code>DescriptorSystems.gl2norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gl2norm(sys, h2norm = false, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atol3 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>L2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>L2</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.  The <code>L2</code> norm is also infinite for a continuous-time system having a gain at infinity greater than <code>atolinf</code>. </p><p>To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil <code>A-λE</code>  must not have real parts in the interval <code>[-β,β]</code> for a continuous-time system or  must not have moduli in the interval <code>[1-β,1+β]</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>If <code>h2norm = true</code>, the <code>H2</code> norm is computed.  The <code>H2</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has unstable zeros (i.e., unstable poles), or for a continuous-time system having a gain at infinity greater than <code>atolinf</code>.   To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atol3</code> specifies the absolute tolerance for the nonzero elements of <code>B</code> and is only used if <code>h2norm = false</code> for controllability tests of unstable eigenvalues.  The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at  <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code> and <code>atol3 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L566-L604">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gh2norm" href="#DescriptorSystems.gh2norm"><code>DescriptorSystems.gh2norm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gh2norm(sys, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, atolinf = atol, rtol = n*ϵ)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> the <code>H2</code> norm of its transfer function  matrix <code>G(λ)</code>. The <code>H2</code> norm is infinite, if <code>sys</code> has unstable poles, or, for a continuous-time, the system has nonzero gain at infinity. To check the stability, the eigenvalues of the <em>pole pencil</em> <code>A-λE</code> must have real parts less  than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The keyword argument <code>atolinf</code> is the absolute tolerance for the gain of <code>G(λ)</code> at <code>λ = ∞</code>.  The used default value is <code>atolinf = 0</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L533-L559">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.glinfnorm" href="#DescriptorSystems.glinfnorm"><code>DescriptorSystems.glinfnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">glinfnorm(sys, hinfnorm = false, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (linfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>L∞</code> norm <code>linfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>L∞</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has zeros (i.e., poles) on the stability domain boundary, i.e., on the extended imaginary axis, in the continuous-time case,  or on the unit circle, in the discrete-time case.   To check the lack of poles on the stability domain boundary, the eigenvalues of the pencil <code>A-λE</code>  must not have real parts in the interval <code>[-β,β]</code> for a continuous-time system or  must not have moduli within the interval <code>[1-β,1+β]</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset.   The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>If <code>hinfnorm = true</code>, the <code>H∞</code> norm is computed. In this case, the stability of the zeros of <code>A-λE</code> is additionally checked and  the <code>H∞</code> norm is infinite for an unstable system. To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L700-L735">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.ghinfnorm" href="#DescriptorSystems.ghinfnorm"><code>DescriptorSystems.ghinfnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">ghinfnorm(sys, rtolinf = 0.001, fast = true, offset = sqrt(ϵ), atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (hinfnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function  matrix <code>G(λ)</code>  the <code>H∞</code> norm <code>hinfnorm</code> (i.e.,  the peak gain of <code>G(λ)</code>) and  the corresponding peak frequency <code>fpeak</code>, where the peak gain is achieved.  The <code>H∞</code> norm is infinite if the <em>pole pencil</em> <code>A-λE</code> has unstable zeros (i.e., <code>sys</code> has unstable poles).  To check the stability, the eigenvalues of the pencil <code>A-λE</code> must have real parts less than <code>-β</code> for a continuous-time system or  have moduli less than <code>1-β</code> for a discrete-time system, where <code>β</code> is the stability domain boundary offset. The offset  <code>β</code> to be used can be specified via the keyword parameter <code>offset = β</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy for the computed infinity norm.  The  default value used for <code>rtolinf</code> is <code>0.001</code>.</p><p>For a continuous-time system <code>sys</code> with <code>E</code> singular, a reduced order realization is determined first, without  uncontrollable and unobservable nonzero finite and infinite eigenvalues of the corresponding pole pencil.  The rank determinations in the performed reductions are based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.   </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon   and <code>n</code> is the order of the system <code>sys</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L666-L693">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gnugap" href="#DescriptorSystems.gnugap"><code>DescriptorSystems.gnugap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gnugap(sys1, sys2; freq = ω, rtolinf = 0.00001, fast = true, offset = sqrt(ϵ), 
       atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (nugapdist, fpeak)</code></pre><p>Compute the ν-gap distance <code>nugapdist</code> between two descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> and the corresponding frequency <code>fpeak</code> (in rad/TimeUnit), where the ν-gap  distance achieves its peak value. </p><p>If <code>freq = missing</code>, the resulting <code>nugapdist</code> satisfies <code>0 &lt;= nugapdist &lt;= 1</code>.  The value <code>nugapdist = 1</code> results, if the winding number is different of zero in which case <code>fpeak = []</code>. </p><p>If <code>freq = ω</code>, where <code>ω</code> is a given vector of real frequency values, the resulting <code>nugapdist</code> is a vector  of pointwise ν-gap distances of the dimension of <code>ω</code>, whose components satisfies <code>0 &lt;= maximum(nugapdist) &lt;= 1</code>.  In this case, <code>fpeak</code> is the frequency for which the pointwise distance achieves its peak value.  All components of <code>nugapdist</code> are set to 1 if the winding number is different of zero in which case <code>fpeak = []</code>.</p><p>The stability boundary offset, <code>β</code>, to be used to assess the finite zeros which belong to the boundary of the stability domain can be specified via the keyword parameter <code>offset = β</code>. Accordingly, for a continuous-time system, these are the finite zeros having  real parts within the interval <code>[-β,β]</code>, while for a discrete-time system,  these are the finite zeros having moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>Pencil reduction algorithms are employed to compute range and coimage spaces  which perform rank decisions based on rank  revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A1</code>, <code>A2</code>, <code>B1</code>, <code>B2</code>, <code>C1</code>, <code>C2</code>, <code>D1</code> and <code>D2</code>, the absolute tolerance for the nonzero elements of <code>E1</code> and <code>E2</code>,    and the relative tolerance for the nonzero elements of all above matrices.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the maximum of the orders of the systems <code>sys1</code> and <code>sys2</code>.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code>, <code>atol2 = atol</code>. </p><p>The keyword argument <code>rtolinf</code> specifies the relative accuracy to be used  to compute the ν-gap as the infinity norm of the relevant system according to [1].  The default value used for <code>rtolinf</code> is <code>0.00001</code>.</p><p><em>Method:</em> The evaluation of ν-gap uses the definition proposed in [1], extended to generalized LTI (descriptor) systems. The computation of winding number is based on enhancements covering zeros on the boundary of the  stability domain and infinite zeros.</p><p><em>References:</em></p><p>[1] G. Vinnicombe. Uncertainty and feedback: H∞ loop-shaping and the ν-gap metric.      Imperial College Press, London, 2001. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/analysis.jl#L1004-L1054">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.freqresp" href="#DescriptorSystems.freqresp"><code>DescriptorSystems.freqresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> H = freqresp(sys, ω)</code></pre><p>Compute the frequency response <code>H</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code> at the real frequencies <code>ω</code>. </p><p>For a system with <code>p</code> outputs and <code>m</code> inputs, and for <code>N</code> frequency values in <code>ω</code>, <code>H</code> is a <code>p × m × N</code> array, where <code>H[:,:,i]</code> contains the <code>i</code>-th value of the frequency response computed as <code>C*((w[i]*E - A)^-1)*B + D</code>, where <code>w[i] = im*ω[i]</code> for a continuous-time system and <code>w[i] = exp(im*ω[i]*|Ts|)</code>  for a discrete-time system with sampling time <code>Ts</code>. </p><p><em>Method:</em> For an efficient evaluation of <code>C*((w[i]*E - A)^-1)*B + D</code> for many values of <code>w[i]</code>, a preliminary  orthogonal coordinate transformation is performed such that for the input-output equivalent transformed  system <code>sys = (At-λEt,Bt,Ct,Dt)</code>, the matrix <code>w[i]*Et - At</code> is upper Hessenberg.  This allows an efficient computation of the frequency response using the Hessenberg-form based  approach proposed in [1].</p><p><em>Reference:</em></p><p>[1] Laub, A.J., &quot;Efficient Multivariable Frequency Response Computations&quot;,     IEEE Transactions on Automatic Control, AC-26 (1981), pp. 407-408.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/dstools.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.timeresp" href="#DescriptorSystems.timeresp"><code>DescriptorSystems.timeresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeresp(sys, u, t, x0 = 0; interpolation = &quot;zoh&quot;, state_history = false, 
         fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (y, tout, x)</code></pre><p>Compute the time response of a proper descriptor system <code>sys = (A-λE,B,C,D)</code> to the input signals  described by <code>u</code> and <code>t</code>. The time vector <code>t</code> consists of regularly spaced time samples. The  matrix <code>u</code> has as many columns as the inputs of <code>sys</code> and its <code>i</code>-th row specifies  the input values at time <code>t[i]</code>. For discrete-time models, <code>u</code> should be sampled at the same rate as <code>sys</code> if <code>sys.Ts &gt; 0</code> and <code>t</code> must have all time steps equal to <code>sys.Ts</code> or can be set to an empty vector.  The vector <code>x0</code> specifies the initial state vector at time <code>t[1]</code> and is set to zero when omitted. </p><p>The matrix <code>y</code> contains the resulting time history of the outputs of <code>sys</code> and  the vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row of <code>y</code> contains the output values at time <code>tout[i]</code>.   If the keyword parameter value <code>state_history = false</code> is used, then the matrix <code>x</code> contains  the resulting time history of the state vector and its <code>i</code>-th row contains  the state values at time <code>tout[i]</code>. By default, the state history is not computed and <code>x = nothing</code>.</p><p>For continuous-time models, the input values are interpolated between samples. By default,  zero-order hold based interpolation is used. The linear interpolation method can be selected using  the keyword parameter <code>interpolation = &quot;foh&quot;</code>.</p><p>By default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair <code>(A,E)</code>  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code> (default), or the SVD-decomposition, if <code>fast = false</code>. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of the square matrices <code>A</code> and <code>E</code>, and  <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/timeresp.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.stepresp" href="#DescriptorSystems.stepresp"><code>DescriptorSystems.stepresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stepresp(sys[, tfinal]; x0 = zeros(sys.nx), ustep = ones(sys.nu), timesteps = 100, 
         state_history = false, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (y, tout, x)</code></pre><p>Compute the step response of a proper descriptor system <code>sys = (A-λE,B,C,D)</code> to step input signals.  The final time <code>tfinal</code>, if not specified, is set to 10 for a continuous-time system or to <code>abs(sys.Ts)*timesteps</code> for a discrete-time system, where the keyword argument <code>timesteps</code> specifies the number of desired simulation time steps (default: <code>timesteps = 100</code>).  The keyword argument <code>ustep</code> is a vector with as many components  as the inputs of <code>sys</code> and specifies the desired amplitudes of step inputs (default: all components are set to 1).    The keyword argument <code>x0</code> is a vector which specifies the initial state vector at time <code>0</code>  and is set to zero when omitted. </p><p>If <code>ns</code> is the total number of simulation values, <code>n</code> the number of state components,  <code>p</code> the number of system outputs and <code>m</code> the number of system inputs, then the resulting <code>ns×p×m</code> array <code>y</code> contains the resulting time histories of the outputs of <code>sys</code>, such  that <code>y[:,:,j]</code> is the time response for the <code>j</code>-th input set to <code>ustep[j]</code> and the rest of inputs set to zero.   The vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row <code>y[i,:,j]</code> contains the output values at time <code>tout[i]</code> of the <code>j</code>-th step response.   If the keyword parameter value <code>state_history = true</code> is used, then the resulting <code>ns×n×m</code> array<code>x</code> contains  the resulting time histories of the state vector and  the <code>i</code>-th row <code>x[i,:,j]</code> contains the state values at time <code>tout[i]</code> of the <code>j</code>-th step response.   By default, the state history is not computed and <code>x = nothing</code>.</p><p>By default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair <code>(A,E)</code>  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code> (default), or the SVD-decomposition, if <code>fast = false</code>. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of the square matrices <code>A</code> and <code>E</code>, and  <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/timeresp.jl#L102-L138">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="DescriptorSystems.gbalqual" href="#DescriptorSystems.gbalqual"><code>DescriptorSystems.gbalqual</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">qs = gbalqual(sys; SysMat = false)</code></pre><p>Compute the 1-norm based scaling quality of the matrices of the descriptor system <code>sys = (A-λE,B,C)</code>.</p><p>If <code>SysMat = false</code>, the resulting <code>qs</code> is computed as </p><pre><code class="nohighlight hljs">    qs = max(qS(A),qS(E),qS(B),qS(C)) ,</code></pre><p>where <code>qS(⋅)</code> is the scaling quality measure defined in Definition 5.5 of [1] for  nonnegative matrices, extended to also cover matrices with zero rows or columns.  </p><p>If <code>SysMat = true</code>, the resulting <code>qs</code> is computed as </p><pre><code class="nohighlight hljs">    qs = qS(S) ,</code></pre><p>where <code>S</code> is the system matrix defined as        </p><pre><code class="nohighlight hljs">         S =  ( abs(A)+abs(E)  abs(B) )
              (    abs(C)        0    )</code></pre><p>A large value of <code>qs</code> indicates a possibly poorly scaled state-space model.  For a standard system with <code>E = I</code>, the above formulas are used assuming <code>E = 0</code>.  </p><p>[1] F.M.Dopico, M.C.Quintana and P. van Dooren,      &quot;Diagonal scalings for the eigenstructure of arbitrary pencils&quot;, SIMAX, 43:1213-1237, 2022. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/e85406267c8f6f9e3e518637eaa65dc5e7e3f9ac/src/conversions.jl#L501-L527">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="order_reduction.html">« Simplification of descriptor system models</a><a class="docs-footer-nextpage" href="factorizations.html">Factorization of descriptor system transfer function matrices »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 24 January 2024 11:54">Wednesday 24 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
