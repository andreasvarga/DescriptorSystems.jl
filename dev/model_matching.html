<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solution of model-matching problems · DescriptorSystems.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">DescriptorSystems.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="rtf.html">Building rational transfer functions</a></li><li><a class="tocitem" href="operations.html">Basic operations on system models</a></li><li><a class="tocitem" href="operations_rtf.html">Some operations on rational transfer functions and matrices</a></li><li><a class="tocitem" href="conversions.html">Basic conversions of descriptor system models</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li><li><a class="tocitem" href="advanced_operations.html">Advanced operations on transfer function matrices</a></li><li class="is-active"><a class="tocitem" href="model_matching.html">Solution of model-matching problems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li><a class="tocitem" href="dstools.html">System utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href="model_matching.html">Solution of model-matching problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="model_matching.html">Solution of model-matching problems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/master/docs/src/model_matching.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solution-of-model-matching-problems"><a class="docs-heading-anchor" href="#Solution-of-model-matching-problems">Solution of model-matching problems</a><a id="Solution-of-model-matching-problems-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-of-model-matching-problems" title="Permalink"></a></h1><ul><li><strong><a href="model_matching.html#DescriptorSystems.gnehari"><code>gnehari</code></a></strong>  Generalized Nehari approximation.</li><li><strong><a href="model_matching.html#DescriptorSystems.glinfldp"><code>glinfldp</code></a></strong>  Solution of the least distance problem.</li><li><strong><a href="model_matching.html#DescriptorSystems.grasol"><code>grasol</code></a></strong>   Approximate solution of the linear rational matrix equation <code>G(λ)*X(λ) = F(λ)</code>.</li><li><strong><a href="model_matching.html#DescriptorSystems.glasol"><code>glasol</code></a></strong>   Approximate solution of the linear rational matrix equation <code>X(λ)*G(λ) = F(λ)</code>.</li></ul><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.gnehari" href="#DescriptorSystems.gnehari"><code>DescriptorSystems.gnehari</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gnehari(sys[, γ]; fast = true, offset = β, 
                atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, σ1)</code></pre><p>Compute for the descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code> the optimal or suboptimal stable Nehari approximation <code>sysx = (Ax-λEx,Bx,Cx,Dx)</code>  with the transfer function matrix <code>X(λ)</code>. The optimal Nehari approximation  <code>X(λ)</code> satisfies</p><p class="math-container">\[     \| G(\lambda) - X(\lambda) \|_\infty = \| G^{*}_u(\lambda) \|_H := \sigma_1,\]</p><p>where <span>${\small G_u(\lambda)}$</span> is the antistable part of <code>G(λ)</code>. The resulting <span>$σ_1$</span> is the Hankel-norm of <span>${\small G^{*}_u(\lambda)}$</span>  (also the L∞-norm of the optimal approximation error).  For a given <span>$γ &gt; σ_1$</span>, the suboptimal approximation satisfies</p><p class="math-container">\[     \| G(\lambda) - X(\lambda) \|_\infty \leq \gamma .\]</p><p>The system <code>sys</code> must not have poles on the boundary of the stability domain <code>Cs</code>. </p><p>To assess the presence of poles on the boundary of the stability domain <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time system,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time system, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The separation of the finite and infinite eigenvalues is performed using  rank decisions based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em> The Hankel-norm approximation methods of [1] and [2],  with extensions for descriptor systems, are used for the approximation of the unstable part.   </p><p><em>References:</em></p><p>[1] K. Glover. All optimal Hankel-norm approximations of linear        multivariable systems and their L∞ error bounds,        Int. J. Control, vol. 39, pp. 1115-1193, 1984.</p><p>[2] M. G. Safonov, R. Y. Chiang, and D. J. N. Limebeer.         Optimal Hankel model reduction for nonminimal systems.         IEEE Trans. Automat. Control, vol. 35, pp. 496–502, 1990.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/409c44cbd325d8d5630acbb7a1df4a24ff2e79a5/src/model_matching.jl#L557-L611">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glinfldp" href="#DescriptorSystems.glinfldp"><code>DescriptorSystems.glinfldp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">glinfldp(sys1, sys2, [, γ]; nehari = false, reltol = 0.0001, fast = true, offset = β, 
         atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, mindist)</code></pre><p>Determine for the descriptor systems <code>sys1 = (A1-λE1,B1,C1,D1)</code> and  <code>sys2 = (A2-λE2,B2,C2,D2)</code> with the transfer function matrices <span>$G_1(λ)$</span> and <span>$G_2(λ)$</span>,  respectively, the descriptor system <code>sysx</code> with the transfer function matrix <span>$X(λ)$</span>  such that <span>$X(λ)$</span> is the a stable solution of the 2-block <code>L∞</code> <em>least distance problem</em> (<code>LDP</code>)</p><p class="math-container">\[      \text{mindist} := \min \|G_1(λ)-X(λ) \mid   G_2(λ) \|_\infty \]</p><p><code>mindist</code> is the achieved minimum distance corresponding to the optimal solution.  If <code>sys2 = []</code>, an 1-block <code>LDP</code> is solved.  <code>sys1</code> and <code>sys2</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If  <span>${\small γ &gt; \|G_2(λ)\|_\infty}$</span> is a desired sub-optimality degree, then the  <code>γ</code>-suboptimal <code>LDP</code> </p><p class="math-container">\[     \text{mindist} := \|G_1(λ)-X(λ) \mid G_2(λ) \|_\infty &lt; γ\]</p><p>is solved and <code>mindist</code> is the achieved suboptimal distance.</p><p>The call with</p><pre><code class="nohighlight hljs">glinfldp(sys[, m2[, γ]]; nehari = false, fast = true, offset = β, 
         atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, mindist)</code></pre><p>uses the compound descriptor system <code>sys = (A-λE,[B1 B2],C,[D1 D2])</code>,  where <code>B2</code> has <code>m2</code> columns, to define   the descriptor systems <code>sys1 = (A-λE,B1,C,D1)</code> and <code>sys2 = (A-λE,B2,C,D2)</code> (i.e., <code>A1-λE1 = A2-λE2 = A-λE</code> and <code>C1 = C2 = C</code>).  If <code>m2 = 0</code>, an 1-block <code>LDP</code> is solved.  <code>sys</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If <code>nehari = true</code>, the optimal or suboptimal Nehari approximation is used to solve the <code>LDP</code>. If <code>nehari = false</code> (default), the optimal solution is computed using the <code>γ</code>-iteration [1]. </p><p>The keyword argument <code>reltol</code> specifies the relative tolerance for the desired accuracy of <code>γ</code>-iteration.  The iterations are performed until the current estimations of maximum <span>$γ_u$</span> and minimum <span>$γ_l$</span> of   the optimal distance <span>$γ_o$</span>, <span>$γ_l \leq γ_o \leq γ_u$</span>, satisfies </p><p class="math-container">\[     γ_u-γ_l \leq \text{reltol} * \text{gap} ,\]</p><p>where <code>gap</code> is the original gap (internally determined). To assess the presence of poles on the boundary of the stability domain <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time setting,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discete-time setting, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>A</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance  for the nonzero elements of <code>A</code> and <code>E</code>. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sys</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em> The approach of [1] is used for the solution of the 2-block least distance problem.</p><p><em>References:</em> [1] C.-C. Chu, J. C. Doyle, and E. B. Lee     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/409c44cbd325d8d5630acbb7a1df4a24ff2e79a5/src/model_matching.jl#L344-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.grasol" href="#DescriptorSystems.grasol"><code>DescriptorSystems.grasol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">grasol(sysg, sysf[, γ]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, 
       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, info)</code></pre><p>Determine for the descriptor systems <code>sysg = (Ag-λEg,Bg,Cg,Dg)</code> and <code>sysf = (Af-λEf,Bf,Cf,Df)</code>  with the transfer function matrices <code>G(λ)</code> and <code>F(λ)</code>,  respectively, the descriptor system <code>sysx</code> with the transfer function matrix <code>X(λ)</code>  such that <code>X(λ)</code> is the approximate solution of the linear rational equation <code>G(λ)X(λ) = F(λ)</code>, which achieves the minimum error norm <span>${\small \text{mindist} := \min \|G(λ)X(λ) - F(λ)\|}$</span>.  The resulting <code>X(λ)</code> has all poles stable or lying on the boundary of the stability domain <code>Cs</code>.  If <code>L2sol = false</code> (default) then the <code>L∞</code>-norm optimal solution is computed, while if <code>L2sol = true</code> the <code>L2</code>-norm optimal solution is computed.  <code>sysg</code> and <code>sysf</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If  <code>γ &gt; 0</code> is a desired sub-optimality degree, then the <code>γ</code>-suboptimal model-matching problem</p><p class="math-container">\[     \text{mindist} := \|G(λ)X(λ) - F(λ) \| &lt; γ\]</p><p>is solved and <code>mindist</code> is the achieved suboptimal distance.</p><p>The call with</p><pre><code class="nohighlight hljs">grasol(sysgf[, mf[, γ]]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, 
       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, info)</code></pre><p>uses the compound descriptor system <code>sysgf = (A-λE,[Bg Bf],C,[Dg Df])</code>,  where <code>Bf</code> and <code>Df</code> have <code>mf</code> columns, to define   the descriptor systems <code>sysg = (A-λE,Bg,C,Dg)</code> and <code>sysf = (A-λE,Bf,C,Df)</code> (i.e., <code>Ag-λEg = Af-λEf = A-λE</code> and <code>Cg = Cf = C</code>).  <code>sysgf</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If <code>nehari = true</code>, the optimal or suboptimal Nehari approximation is used to  compute a <code>L∞</code>-suboptimal solution of the underlying <em>least-distance problem</em> (<code>LDP</code>). If <code>nehari = false</code> (default), the <code>L∞</code>-optimal solution is computed using the <code>γ</code>-iteration  in the underlying <code>LDP</code> [2]. </p><p>If <code>mindeg = true</code>, a minimum order solution is determined (if possible),  while if <code>mindeg = false</code> (default) a particular solution of non-minimal order is determined. </p><p>The resulting named tuple <code>info</code> contains additional information: <code>info.nrank</code> is the normal rank of <code>G(λ)</code>,  <code>info.nr</code> is the number of freely assignable poles of the solution <code>X(λ)</code>,   <code>info.mindist</code> is the achieved approximation error norm and  <code>info.nonstandard</code> is <code>true</code> for a non-standard problem, with <code>G(λ)</code>  having zeros on the boundary of the stability domain, and <code>false</code> for a standard problem, when <code>G(λ)</code> has no zeros on the boundary  of the stability domain.  </p><p>The keyword argument <code>reltol</code> specifies the relative tolerance for the desired accuracy of  the <code>γ</code>-iteration employed to solve the underlying least-distance problem.   The iterations are performed until the current estimations of maximum <span>$γ_u$</span> and minimum <span>$γ_l$</span> of   the optimal distance satisfies  <span>${\small γ_u-γ_l \leq \text{reltol} * \text{gap}}$</span>, where <code>gap</code> is the initial estimation of the error gap.</p><p>To assess the presence of poles on the boundary of the stability domain <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time setting,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time setting, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The vector <code>poles</code> specified as a keyword argument, can be used to specify the desired poles of <code>sysx</code> alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of poles. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>Ag</code>, <code>Af</code>, <code>A</code>, <code>Bg</code>, <code>Bf</code>, <code>Cg</code>, <code>Cf</code>, <code>Dg</code>, <code>Df</code>,   the absolute tolerance for the nonzero elements of <code>Eg</code>, <code>Ef</code>, and the relative tolerance  for the nonzero elements of all above matrices. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sysg</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  An extension of the approach of [1] to descriptor systems is used.</p><p><em>References:</em></p><p>[1]  B. A. Francis. A Course in H-infinity Theory,         Vol. 88 of Lecture Notes in Control and Information Sciences,         Springer-Verlag, New York, 1987.</p><p>[2] C.-C. Chu, J. C. Doyle, and E. B. Lee.     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/409c44cbd325d8d5630acbb7a1df4a24ff2e79a5/src/model_matching.jl#L1-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.glasol" href="#DescriptorSystems.glasol"><code>DescriptorSystems.glasol</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">glasol(sysg, sysf[, γ]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, 
       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, info)</code></pre><p>Determine for the descriptor systems <code>sysg = (Ag-λEg,Bg,Cg,Dg)</code> and  <code>sysf = (Af-λEf,Bf,Cf,Df)</code> with the transfer function matrices <code>G(λ)</code> and <code>F(λ)</code>,  respectively, the descriptor system <code>sysx</code> with the transfer function matrix <code>X(λ)</code>  such that <code>X(λ)</code> is the approximate solution of the linear rational equation <code>X(λ)G(λ) = F(λ)</code>, which achieves the minimum error norm <span>${\small \text{mindist} := \min \|X(λ)G(λ) - F(λ)\|}$</span>.  The resulting <code>X(λ)</code> has all poles stable or lying on the boundary of the stability domain <code>Cs</code>.  If <code>L2sol = false</code> (default) then the <code>L∞</code>-norm optimal solution is computed, while if <code>L2sol = true</code> the <code>L2</code>-norm optimal solution is computed.  <code>sysg</code> and <code>sysf</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If  <code>γ &gt; 0</code> is a desired sub-optimality degree, then the <code>γ</code>-suboptimal model-matching problem</p><p class="math-container">\[     \text{mindist} := \|X(λ)G(λ) - F(λ) \| &lt; γ\]</p><p>is solved and <code>mindist</code> is the achieved suboptimal distance.</p><p>The call with</p><pre><code class="nohighlight hljs">glasol(sysgf[, pf[, γ]]; L2sol = false, nehari = false, reltol = 0.0001, mindeg = false, poles, sdeg, 
       fast = true, offset = β, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (sysx, info)</code></pre><p>uses the compound descriptor system <code>sysgf = (A-λE,B,[Cg; Cf],[Dg; Df])</code>,  where <code>Cf</code> and <code>Df</code> have <code>pf</code> rows, to define   the descriptor systems <code>sysg = (A-λE,B,Cg,Dg)</code> and <code>sysf = (A-λE,B,Cf,Df)</code> (i.e., <code>Ag-λEg = Af-λEf = A-λE</code> and <code>Bg = Bf = B</code>).  <code>sysgf</code> must not have poles on the boundary of the stability domain <code>Cs</code>.</p><p>If <code>nehari = true</code>, the optimal or suboptimal Nehari approximation is used to solve the  underlying <em>least-distance problem</em> (<code>LDP</code>). If <code>nehari = false</code> (default), the optimal solution is computed using the <code>γ</code>-iteration  in the underlying <code>LDP</code> [2]. </p><p>If <code>mindeg = true</code>, a minimum order solution is determined (if possible),  while if <code>mindeg = false</code> (default) a particular solution of non-minimal order is determined. </p><p>The resulting named tuple <code>info</code> contains additional information: <code>info.nrank</code> is the normal rank of <code>G(λ)</code>,  <code>info.nl</code> is the number of freely assignable poles of the solution <code>X(λ)</code>,   <code>info.mindist</code> is the achieved approximation error norm and  <code>info.nonstandard</code> is <code>true</code> for a non-standard problem, with <code>G(λ)</code>  having zeros on the boundary of the stability domain, and <code>false</code> for a standard problem, when <code>G(λ)</code> has no zeros on the boundary  of the stability domain.  </p><p>The keyword argument <code>reltol</code> specifies the relative tolerance for the desired accuracy of  the <code>γ</code>-iteration employed to solve the underlying least-distance problem.   The iterations are performed until the current estimations of maximum <span>$γ_u$</span> and minimum <span>$γ_l$</span> of   the optimal distance satisfies  <span>${\small γ_u-γ_l &lt; \text{reltol}* \text{gap}}$</span>, where <code>gap</code> is the initial estimation of the error gap.</p><p>To assess the presence of poles on the boundary of the stability domain <code>Cs</code>, a boundary offset  <code>β</code>  can be specified via the keyword parameter <code>offset = β</code>.  Accordingly, for a continuous-time setting,  the boundary of <code>Cs</code> contains the complex numbers with real parts within the interval <code>[-β,β]</code>,  while for a discrete-time setting, the boundary of <code>Cs</code> contains the complex numbers with moduli within the interval <code>[1-β,1+β]</code>.  The default value used for <code>β</code> is <code>sqrt(ϵ)</code>, where <code>ϵ</code> is the working machine precision. </p><p>The vector <code>poles</code> specified as a keyword argument, can be used to specify the desired poles of <code>sysx</code> alternatively to or jointly with enforcing a desired stability degree <code>sdeg</code> of poles. </p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of <code>Ag</code>, <code>Af</code>, <code>A</code>, <code>Bg</code>, <code>Bf</code>, <code>Cg</code>, <code>Cf</code>, <code>Dg</code>, <code>Df</code>,   the absolute tolerance for the nonzero elements of <code>Eg</code>, <code>Ef</code>, and the relative tolerance  for the nonzero elements of all above matrices. The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon  and <code>n</code> is the order of the system <code>sysg</code>. The keyword argument <code>atol</code> can be used  to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The rank decisions in the underlying pencil manipulation algorithms are  based on rank revealing QR-decompositions with column pivoting  if <code>fast = true</code> or the more reliable SVD-decompositions if <code>fast = false</code>.</p><p><em>Method:</em>  An extension of the approach of [1] to descriptor systems is used.</p><p><em>References:</em></p><p>[1]  B. A. Francis. A Course in H-infinity Theory,         Vol. 88 of Lecture Notes in Control and Information Sciences,         Springer-Verlag, New York, 1987.</p><p>[2] C.-C. Chu, J. C. Doyle, and E. B. Lee.     The general distance problem in H∞  optimal control theory,     Int. J. Control, vol 44, pp. 565-596, 1986.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/409c44cbd325d8d5630acbb7a1df4a24ff2e79a5/src/model_matching.jl#L171-L261">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="advanced_operations.html">« Advanced operations on transfer function matrices</a><a class="docs-footer-nextpage" href="dstools.html">System utilities »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Friday 5 November 2021 20:27">Friday 5 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
