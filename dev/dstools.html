<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>System utilities · DescriptorSystems.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">DescriptorSystems.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="dss.html">Building descriptor system state-space models</a></li><li><a class="tocitem" href="rtf.html">Building rational transfer functions</a></li><li><a class="tocitem" href="operations.html">Basic operations on system models</a></li><li><a class="tocitem" href="operations_rtf.html">Some operations on rational transfer functions and matrices</a></li><li><a class="tocitem" href="conversions.html">Basic conversions of descriptor system models</a></li><li><a class="tocitem" href="order_reduction.html">Simplification of descriptor system models</a></li><li><a class="tocitem" href="analysis.html">Descriptor system analysis</a></li><li><a class="tocitem" href="factorizations.html">Factorization of descriptor system transfer function matrices</a></li><li><a class="tocitem" href="advanced_operations.html">Advanced operations on transfer function matrices</a></li><li><a class="tocitem" href="model_matching.html">Solution of model-matching problems</a></li></ul></li><li><span class="tocitem">Utilities</span><ul><li class="is-active"><a class="tocitem" href="dstools.html">System utilities</a></li></ul></li><li><a class="tocitem" href="makeindex.html">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Utilities</a></li><li class="is-active"><a href="dstools.html">System utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="dstools.html">System utilities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/main/docs/src/dstools.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="System-utilities"><a class="docs-heading-anchor" href="#System-utilities">System utilities</a><a id="System-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#System-utilities" title="Permalink"></a></h1><ul><li><strong><a href="dstools.html#DescriptorSystems.order"><code>order</code></a></strong>   Order of a system.</li><li><strong><a href="dstools.html#Base.size"><code>size</code></a></strong>    Number of outputs and inputs of a descriptor system .</li><li><strong><a href="dstools.html#Base.iszero"><code>iszero</code></a></strong>   Checking whether the transfer function matrix of a descriptor system is zero.</li><li><strong><a href="dstools.html#DescriptorSystems.evalfr"><code>evalfr</code></a></strong>   Gain of the transfer function matrix at a single frequency value.</li><li><strong><a href="dstools.html#DescriptorSystems.freqresp"><code>freqresp</code></a></strong>   Frequency response of a descriptor system.</li><li><strong><a href="dstools.html#DescriptorSystems.timeresp"><code>timeresp</code></a></strong>   Time response of a descriptor system.</li><li><strong><a href="dstools.html#DescriptorSystems.stepresp"><code>stepresp</code></a></strong>   Step response of a descriptor system.</li><li><strong><a href="dstools.html#DescriptorSystems.dcgain"><code>dcgain</code></a></strong>   DC gain of a system.</li><li><strong><a href="dstools.html#LinearAlgebra.opnorm"><code>opnorm</code></a></strong>   <code>L2</code>- and <code>L∞</code>-norms of a descriptor system.</li><li><strong><a href="dstools.html#DescriptorSystems.rss"><code>rss</code></a></strong>   Generation of randomized standard state-space systems.</li><li><strong><a href="dstools.html#DescriptorSystems.rdss"><code>rdss</code></a></strong>   Generation of randomized descriptor state-space systems.</li><li><strong><a href="dstools.html#DescriptorSystems.dsxvarsel"><code>dsxvarsel</code></a></strong>   Building a descriptor systems by selecting a set of state variables.</li><li><strong><a href="dstools.html#DescriptorSystems.dssubset"><code>dssubset</code></a></strong>   Assigning a subsystem to a given descriptor system.</li><li><strong><a href="dstools.html#DescriptorSystems.dszeros"><code>dszeros</code></a></strong>   Setting a subsystem to zero.</li><li><strong><a href="dstools.html#DescriptorSystems.dssubsel"><code>dssubsel</code></a></strong>   Selecting a subsystem according to a given zero-nonzero pattern.</li><li><strong><a href="dstools.html#DescriptorSystems.dsdiag"><code>dsdiag</code></a></strong>   Building a <code>k</code>-times diagonal concatenation of a descriptor system. </li></ul><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.order" href="#DescriptorSystems.order"><code>DescriptorSystems.order</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">n = order(r)</code></pre><p>Determine the order <code>n</code> of a rational transfer function <code>r</code> as the maximum of degrees of its numerator and denominator polynomials (<code>n</code> is also known as the <em>McMillan degree</em> of <code>r</code>).  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/types/RationalTransferFunction.jl#L488-L493">source</a></section><section><div><pre><code class="nohighlight hljs">nx = order(sys)</code></pre><p>Return the order <code>nx</code> of the descriptor system <code>sys</code> as the dimension of the state variable vector.  For improper or non-minimal systems, <code>nx</code> is less than the McMillan degree of the system.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L100-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.size" href="#Base.size"><code>Base.size</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">size(sys) -&gt; (p,m)
size(sys,1) -&gt; p
size(sys,2) -&gt; m</code></pre><p>Return the number of outputs <code>p</code> and the number of inputs <code>m</code> of a descriptor system <code>sys</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L117-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.iszero" href="#Base.iszero"><code>Base.iszero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> iszero(sys; atol = 0, atol1 = atol, atol2 = atol, rtol, fastrank = true)</code></pre><p>Return <code>true</code> if the transfer function matrix of the descriptor system <code>sys</code> is zero.  For a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code> it is checked  that the normal rank of <code>G(λ)</code> is zero, or equivalently (see [1]), that the normal rank of  the system matrix pencil </p><pre><code class="nohighlight hljs">          | A-λE | B | 
  S(λ) := |------|---|
          |  C   | D |</code></pre><p>is equal to <code>n</code>, the order of the system <code>sys</code>. </p><p>If <code>fastrank = true</code>, the normal rank of <code>S(λ)</code> is evaluated by counting how many singular values of <code>S(γ)</code> have magnitudes  greater than <code>max(max(atol1,atol2), rtol*σ₁)</code>, where <code>σ₁</code> is the largest singular value of <code>S(γ)</code> and <code>γ</code> is a randomly generated value.  If <code>fastrank = false</code>, the rank is evaluated as <code>nr + ni + nf + nl</code>, where <code>nr</code> and <code>nl</code> are the sums of right and left Kronecker indices,  respectively, while <code>ni</code> and <code>nf</code> are the number of infinite and finite eigenvalues, respectively. The sums <code>nr+ni</code> and   <code>nf+nl</code>, are determined from an appropriate Kronecker-like form of the pencil <code>S(λ)</code>, exhibiting the spliting of the right and left structures.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>,   the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>[1] A. Varga,  On checking null rank conditions of rational matrices, 2018.  <a href="https://arxiv.org/pdf/1812.11396">arXiv:2006.06825</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L138-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.evalfr" href="#DescriptorSystems.evalfr"><code>DescriptorSystems.evalfr</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Rval = evalfr(R,val)</code></pre><p>Evaluate the rational transfer function matrix <code>R(λ)</code> for <code>λ = val</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/types/RationalTransferFunction.jl#L611-L615">source</a></section><section><div><pre><code class="nohighlight hljs">Rval = evalfr(R; fval = 0)</code></pre><p>Evaluate the rational transfer function matrix <code>R(λ)</code> for <code>λ = val</code>, where <code>val = im*fval</code>  for a continuous-time system or <code>val = exp(im*fval*abs(Ts))</code> for a discrete-time system,  with <code>Ts</code> the system sampling time.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/types/RationalTransferFunction.jl#L619-L625">source</a></section><section><div><pre><code class="nohighlight hljs">rval = evalfr(r,val)</code></pre><p>Evaluate the rational transfer function  <code>r(λ)</code> for <code>λ = val</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/types/RationalTransferFunction.jl#L632-L636">source</a></section><section><div><pre><code class="nohighlight hljs">rval = evalfr(r; fval = 0)</code></pre><p>Evaluate the rational transfer function  <code>r(λ)</code> for <code>λ = val</code>, where <code>val = im*fval</code>  for a continuous-time system or <code>val = exp(im*fval*Ts)</code> for a discrete-time system,  with <code>Ts</code> the system sampling time.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/types/RationalTransferFunction.jl#L640-L646">source</a></section><section><div><pre><code class="nohighlight hljs">Gval = evalfr(sys, val; atol1 = 0, atol2 = 0, rtol, fast = true)</code></pre><p>Evaluate for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, <code>Gval</code>, the value of the rational matrix <code>G(λ) = C*inv(λE-A)*B+D</code> for <code>λ = val</code>.  The computed <code>Gval</code> has infinite entries if <code>val</code> is a pole (finite or infinite) of <code>G(λ)</code>. If <code>val</code> is finite and <code>val*E-A</code> is singular or if <code>val = Inf</code> and <code>E</code> is singular,  then the entries of <code>Gval</code> are evaluated separately for minimal realizations of each input-output channel.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>. </p><p>The computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L173-L190">source</a></section><section><div><pre><code class="nohighlight hljs">Gval = evalfr(sys; fval = 0, atol = 0, atol1 = atol, atol2 = atol, rtol, fast = true)</code></pre><p>Evaluate for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, <code>Gval</code>, the value of the rational matrix <code>G(λ) = C*inv(λE-A)*B+D</code> for <code>λ = val</code>, where <code>val = im*fval</code>  for a continuous-time system or <code>val = exp(im*fval*sys.Ts)</code> for a discrete-time system.  The computed <code>Gval</code> has infinite entries if <code>val</code> is a pole (finite or infinite) of <code>G(λ)</code>. If <code>val</code> is finite and <code>val*E-A</code> is singular or if <code>val = Inf</code> and <code>E</code> is singular,  then the entries of <code>Gval</code> are evaluated separately for minimal realizations of each input-output channel.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>. The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p><p>The computation of minimal realizations of individual input-output channels relies on pencil manipulation algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L194-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.freqresp" href="#DescriptorSystems.freqresp"><code>DescriptorSystems.freqresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> H = freqresp(sys, ω)</code></pre><p>Compute the frequency response <code>H</code> of the descriptor system <code>sys = (A-λE,B,C,D)</code> at the real frequencies <code>ω</code>. </p><p>For a system with <code>p</code> outputs and <code>m</code> inputs, and for <code>N</code> frequency values in <code>ω</code>, <code>H</code> is a <code>p × m × N</code> array, where <code>H[:,:,i]</code> contains the <code>i</code>-th value of the frequency response computed as <code>C*((w[i]*E - A)^-1)*B + D</code>, where <code>w[i] = im*ω[i]</code> for a continuous-time system and <code>w[i] = exp(im*ω[i]*|Ts|)</code>  for a discrete-time system with sampling time <code>Ts</code>. </p><p><em>Method:</em> For an efficient evaluation of <code>C*((w[i]*E - A)^-1)*B + D</code> for many values of <code>w[i]</code>, a preliminary  orthogonal coordinate transformation is performed such that for the input-output equivalent transformed  system <code>sys = (At-λEt,Bt,Ct,Dt)</code>, the matrix <code>w[i]*Et - At</code> is upper Hessenberg.  This allows an efficient computation of the frequency response using the Hessenberg-form based  approach proposed in [1].</p><p><em>Reference:</em></p><p>[1] Laub, A.J., &quot;Efficient Multivariable Frequency Response Computations&quot;,     IEEE Transactions on Automatic Control, AC-26 (1981), pp. 407-408.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.timeresp" href="#DescriptorSystems.timeresp"><code>DescriptorSystems.timeresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">timeresp(sys, u, t, x0 = 0; interpolation = &quot;zoh&quot;, state_history = false, 
         fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (y, tout, x)</code></pre><p>Compute the time response of a proper descriptor system <code>sys = (A-λE,B,C,D)</code> to the input signals  described by <code>u</code> and <code>t</code>. The time vector <code>t</code> consists of regularly spaced time samples. The  matrix <code>u</code> has as many columns as the inputs of <code>sys</code> and its <code>i</code>-th row specifies  the input values at time <code>t[i]</code>. For discrete-time models, <code>u</code> should be sampled at the same rate as <code>sys</code> if <code>sys.Ts &gt; 0</code> and <code>t</code> must have all time steps equal to <code>sys.Ts</code> or can be set to an empty vector.  The vector <code>x0</code> specifies the initial state vector at time <code>t[1]</code> and is set to zero when omitted. </p><p>The matrix <code>y</code> contains the resulting time history of the outputs of <code>sys</code> and  the vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row of <code>y</code> contains the output values at time <code>tout[i]</code>.   If the keyword parameter value <code>state_history = false</code> is used, then the matrix <code>x</code> contains  the resulting time history of the state vector and its <code>i</code>-th row contains  the state values at time <code>tout[i]</code>. By default, the state history is not computed and <code>x = nothing</code>.</p><p>For continuous-time models, the input values are interpolated between samples. By default,  zero-order hold based interpolation is used. The linear interpolation method can be selected using  the keyword parameter <code>interpolation = &quot;foh&quot;</code>.</p><p>By default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair <code>(A,E)</code>  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code> (default), or the SVD-decomposition, if <code>fast = false</code>. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of the square matrices <code>A</code> and <code>E</code>, and  <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/timeresp.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.stepresp" href="#DescriptorSystems.stepresp"><code>DescriptorSystems.stepresp</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">stepresp(sys[, tfinal]; x0 = zeros(sys.nx), ustep = ones(sys.nu), timesteps = 100, 
         state_history = false, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = n*ϵ) -&gt; (y, tout, x)</code></pre><p>Compute the step response of a proper descriptor system <code>sys = (A-λE,B,C,D)</code> to step input signals.  The final time <code>tfinal</code>, if not specified, is set to 10 for a continuous-time system or to <code>abs(sys.Ts)*timesteps</code> for a discrete-time system, where the keyword argument <code>timesteps</code> specifies the number of desired simulation time steps (default: <code>timesteps = 100</code>).  The keyword argument <code>ustep</code> is a vector with as many components  as the inputs of <code>sys</code> and specifies the desired amplitudes of step inputs (default: all components are set to 1).    The keyword argument <code>x0</code> is a vector which specifies the initial state vector at time <code>0</code>  and is set to zero when omitted. </p><p>If <code>ns</code> is the total number of simulation values, <code>n</code> the number of state components,  <code>p</code> the number of system outputs and <code>m</code> the number of system inputs, then the resulting <code>ns×p×m</code> array <code>y</code> contains the resulting time histories of the outputs of <code>sys</code>, such  that <code>y[:,:,j]</code> is the time response for the <code>j</code>-th input set to <code>ustep[j]</code> and the rest of inputs set to zero.   The vector <code>tout</code> contains the corresponding values of the time samples. The <code>i</code>-th row <code>y[i,:,j]</code> contains the output values at time <code>tout[i]</code> of the <code>j</code>-th step response.   If the keyword parameter value <code>state_history = true</code> is used, then the resulting <code>ns×n×m</code> array<code>x</code> contains  the resulting time histories of the state vector and  the <code>i</code>-th row <code>x[i,:,j]</code> contains the state values at time <code>tout[i]</code> of the <code>j</code>-th step response.   By default, the state history is not computed and <code>x = nothing</code>.</p><p>By default, the uncontrollable infinite eigenvalues and simple infinite eigenvalues of the pair <code>(A,E)</code>  are eliminated.  The underlying pencil manipulation algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code> (default), or the SVD-decomposition, if <code>fast = false</code>. The rank decision based on the SVD-decomposition is generally more reliable,  but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code> and <code>rtol</code> specify, respectively,  the absolute tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,  and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.   The default relative tolerance is <code>n*ϵ</code>, where <code>n</code> is the order of the square matrices <code>A</code> and <code>E</code>, and  <code>ϵ</code> is the working machine epsilon.  The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/timeresp.jl#L102-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dcgain" href="#DescriptorSystems.dcgain"><code>DescriptorSystems.dcgain</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">Gval = dcgain(sys; atol1, atol2, rtol, fast = true)</code></pre><p>Evaluate for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>, <code>Gval</code>, the DC (or steady-state) gain. <code>Gval</code> is the value of the  rational matrix <code>G(λ)</code> for <code>λ = val</code>, where for a continuous-time system <code>val = 0</code> and  for a discrete-time system <code>val = 1</code>. The computed <code>Gval</code> has infinite entries if <code>val</code> is a pole of <code>G(λ)</code>. In this case (i.e., <code>val*E-A</code> is singular), the entries of <code>Gval</code> are evaluated separately for minimal realizations  of each input-output channel.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>. </p><p>The computation of minimal realizations of individual input-output channels relies on pencil manipulation  algorithms, which employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L219-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> opnorm(sys[, p = Inf]; kwargs...) 
 opnorm(sys, 2; kwargs...) -&gt; sysnorm
 opnorm(sys, Inf; kwargs...) -&gt; (sysnorm, fpeak)
 opnorm(sys; kwargs...) -&gt; (sysnorm, fpeak)</code></pre><p>Compute for a descriptor system <code>sys = (A-λE,B,C,D)</code> with the transfer function matrix <code>G(λ)</code>,  the <code>L2</code> or <code>L∞</code> system norm <code>sysnorm</code> induced by the vector <code>p</code>-norm, where valid values of <code>p</code> are <code>2</code> or <code>Inf</code>.  For the <code>L∞</code> norm, the frequency <code>fpeak</code> is also returned, where <code>G(λ)</code> achieves its peak gain.  See <a href="analysis.html#DescriptorSystems.gh2norm"><code>gh2norm</code></a> and <a href="analysis.html#DescriptorSystems.ghinfnorm"><code>ghinfnorm</code></a> for a description of the allowed keyword arguments.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L242-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.rss" href="#DescriptorSystems.rss"><code>DescriptorSystems.rss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sys = rss(n, p, m; disc = false, T = Float64, stable = false, nuc = 0, nuo = 0, randt = true)</code></pre><p>Generate a randomized <code>n+nuc+nuo</code>-th order standard state-space system <code>sys = (A,B,C,D)</code> with <code>p</code> outputs and <code>m</code> inputs, with all matrices  randomly generated of type <code>T</code>. The resulting <code>sys</code> is a continuous-time system if <code>disc = false</code> and a discrete-time system if <code>disc = true</code>. If <code>stable = true</code>, the resulting system is stable, with <code>A</code> having all eigenvalues with negative real parts for a continuous-time system,  or with moduli less than one for a discrete-time system.  If <code>nuc+nuo &gt; 0</code>, the system <code>sys</code> is non-minimal, with <code>A</code> having <code>nuc</code> uncontrollable and <code>nuo</code> unobservable eigenvalues.  If  <code>randt = true</code>, a randomly generated orthogonal or unitary similarity transformation is additionally applied.     If <code>randt = false</code>, the system matrices <code>A</code>, <code>B</code>, and <code>C</code> result in block stuctured forms exhibitting the  uncontrollable and unobservable eigenvalues of <code>A</code>:</p><pre><code class="nohighlight hljs">A = diag(A1, A2, A3),  B = [B1; 0; B3], C = [C1 C2 0]</code></pre><p>with the diagonal blocks <code>A1</code>, <code>A2</code>, <code>A3</code> of orders <code>n</code>, <code>nuc</code>, and <code>nuo</code>, respectively. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L264-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.rdss" href="#DescriptorSystems.rdss"><code>DescriptorSystems.rdss</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sys = rdss(n, p, m; id = [ ], disc = false, T = Float64, stable = false, nfuc = 0, iduc = [ ], 
           nfuo = 0, iduo = [ ], randlt = true, randrt = true)</code></pre><p>Generate a randomized descriptor state-space system <code>sys = (A-λE,B,C,D)</code> with <code>p</code> outputs and <code>m</code> inputs, with all matrices  randomly generated of type <code>T</code>.  The resulting <code>sys</code> is a continuous-time system if <code>disc = false</code> and a discrete-time system if <code>disc = true</code>.</p><p>If the vector <code>id</code> is nonempty, then <code>id[i]</code> specifies the order of the <code>i</code>-th infinite elementary divisor of the resulting pencil <code>A-λE</code>, which thus has <code>n</code> finite eigenvalues and <code>ni = sum(id)</code> infinite eigenvalues which are controllable and observable.  If <code>nfuc+nfuo &gt; 0</code>, the system <code>sys</code> is non-minimal, with <code>A</code> having <code>nfuc</code> uncontrollable and <code>nfuo</code> unobservable finite eigenvalues.  If the vector <code>iduc</code> is a nonempty, then <code>iduc[i]</code> specifies the order of the <code>i</code>-th infinite elementary divisor  with uncontrollable infinite eigenvalues of the resulting pencil <code>A-λE</code>, which thus has <code>niuc = sum(iduc)</code> uncontrollable infinite eigenvalues.  If the vector <code>iduo</code> is a nonempty, then <code>iduo[i]</code> specifies the order of the <code>i</code>-th infinite elementary divisor with  unobservable infinite eigenvalues of the resulting pencil <code>A-λE</code>, which thus has <code>niuo = sum(iduo)</code> unobservable infinite eigenvalues.  If <code>niuc+niuo &gt; 0</code>, the system <code>sys</code> is non-minimal, with <code>A</code> having <code>niuc</code> uncontrollable and <code>niuo</code> unobservable infinite eigenvalues. </p><p>It follows, that the resulting pencil <code>A-λE</code> has  <code>n+nfuc+nfuo</code> finite eigenvalues and <code>ni+niuc+niuo</code> infinite eigenvalues.  If <code>stable = true</code>, the proper part of the system <code>sys</code> is stable, with <code>A</code> having all finite eigenvalues with negative real parts  for a continuous-time system, or with moduli less than one for a discrete-time system. </p><p>If  <code>randlt = true</code>, a randomly generated orthogonal or unitary transformation is additionally applied to <code>A</code>, <code>E</code>, and <code>B</code> from the left.     If  <code>randrt = true</code>, a randomly generated orthogonal or unitary transformation is additionally applied to <code>A</code>, <code>E</code>,  and <code>C</code> from the right.     If <code>randlt = false</code> and <code>randrt = false</code>, the system matrices <code>A</code>, <code>E</code>, <code>B</code>, and <code>C</code> result in block stuctured forms exhibitting the  uncontrollable and unobservable finite and infinite eigenvalues of <code>A-λE</code>:</p><pre><code class="nohighlight hljs">A-λE = diag(A1-λE1, A2-λE2, A3-λE3, A4-λE4, A5-λE5, A6-λE6),  
B = [B1; B2; 0; 0; B5; B6 ], 
C = [C1 C2 C3 C4 0 0]</code></pre><p>with the diagonal blocks <code>A1</code>, <code>A2</code>, <code>A3</code>, <code>A4</code>, <code>A5</code>, <code>A6</code> of orders <code>n</code>, <code>ni</code>, <code>nfuc</code>, <code>niuc</code>, <code>nfuo</code> and <code>niuo</code>, respectively. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L295-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dsxvarsel" href="#DescriptorSystems.dsxvarsel"><code>DescriptorSystems.dsxvarsel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">sysr = dsxvarsel(sys,ind)</code></pre><p>Construct for the descriptor system <code>sys = (A-λE,B,C,D)</code> of order <code>n</code> the descriptor system   <code>sysr = (A[ind,ind]-λE[ind,ind],B[ind,:],C[:,ind],D)</code> of order <code>nr = length(ind)</code>,  by selecting the state variables of <code>sys</code> with indices specified by <code>ind</code>.  If <code>ind</code> is a permutation vector of length <code>n</code>, then <code>sysr</code> has the same transfer function matrix as <code>sys</code>  and permuted state variables. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L347-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dssubset" href="#DescriptorSystems.dssubset"><code>DescriptorSystems.dssubset</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> res = dssubset(sys, subsys, rows, cols; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)</code></pre><p>Assign for a given descriptor system <code>sys = (A-λE,B,C,D)</code> its subsystem <code>sys[row,cols]</code> to <code>subsys</code> and  return the modified system in <code>res</code>. <code>rows</code> and <code>cols</code> are indices, vectors of indices, index ranges, <code>:</code> or  any combinations of them. </p><p>If <code>minimal = true</code> (default), an irreducible realization of the resulting system <code>res</code> is computed, otherwise a possibly non-minimal realization is returned if <code>minimal = false</code>. </p><p>The underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>nϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>  and <code>n</code> is the order of the system <code>sys</code>.   The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L453-L474">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dszeros" href="#DescriptorSystems.dszeros"><code>DescriptorSystems.dszeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> res = dszeros(sys, rows, cols; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)</code></pre><p>Set for a given descriptor system <code>sys = (A-λE,B,C,D)</code> its subsystem <code>sys[row,cols]</code> to zero and  return the modified system in <code>res</code>. <code>rows</code> and <code>cols</code> are indices, vectors of indices, index ranges, <code>:</code> or  any combinations of them. </p><p>If <code>minimal = true</code> (default), an irreducible realization of the resulting system <code>res</code> is computed, otherwise a possibly non-minimal realization is returned if <code>minimal = false</code>. </p><p>The underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>nϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>  and <code>n</code> is the order of the system <code>sys</code>.   The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L502-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dssubsel" href="#DescriptorSystems.dssubsel"><code>DescriptorSystems.dssubsel</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> res = dssubsel(sys, S; minimal = true, fast = true, atol = 0, atol1 = atol, atol2 = atol, rtol = nϵ)</code></pre><p>Select for a given descriptor system <code>sys = (A-λE,B,C,D)</code> its subsystem <code>res</code> corresponding to the zero-one pattern specified by  the binary structure matrix <code>S</code>. If <code>G(λ)</code> is the transfer function matrix of <code>sys</code>, then the transfer function matrix of <code>res</code> is the element-wise product <code>S .* G(λ)</code>. </p><p>If <code>minimal = true</code> (default), an irreducible realization of the resulting system <code>res</code> is computed, otherwise a possibly non-minimal realization is returned if <code>minimal = false</code>. </p><p>The underlying pencil manipulation based minimal realization algorithms employ rank determinations based on either the use of  rank revealing QR-decomposition with column pivoting, if <code>fast = true</code>, or the SVD-decomposition. The rank decision based on the SVD-decomposition is generally more reliable, but the involved computational effort is higher.</p><p>The keyword arguments <code>atol1</code>, <code>atol2</code>, and <code>rtol</code>, specify, respectively, the absolute tolerance for the  nonzero elements of matrices <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, the absolute tolerance for the nonzero elements of <code>E</code>,   and the relative tolerance for the nonzero elements of <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code> and <code>E</code>.  The default relative tolerance is <code>nϵ</code>, where <code>ϵ</code> is the working <em>machine epsilon</em>  and <code>n</code> is the order of the system <code>sys</code>.   The keyword argument <code>atol</code> can be used to simultaneously set <code>atol1 = atol</code> and <code>atol2 = atol</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L546-L566">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DescriptorSystems.dsdiag" href="#DescriptorSystems.dsdiag"><code>DescriptorSystems.dsdiag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> sysdiag = dsdiag(sys, k)</code></pre><p>Build for a given descriptor system <code>sys</code> and non-negative integer <code>k</code> a descriptor system <code>sysdiag</code> obtained as <code>sysdiag = diag( sys, ..., sys )</code> (i.e., <code>k</code>-times repeated application of <code>append</code>).   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/andreasvarga/DescriptorSystems.jl/blob/dc147ee05e3323ac52a6ade63f33ecd24f95c932/src/dstools.jl#L581-L586">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="model_matching.html">« Solution of model-matching problems</a><a class="docs-footer-nextpage" href="makeindex.html">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 26 November 2022 11:54">Saturday 26 November 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
